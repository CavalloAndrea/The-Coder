titolo£[C] - Hello world|
linguaggio£C|
lezione£ Iniziamo vedendo un primo semplice esempio di programma realizzato in linguaggio C.<br>
Programma <b>Hello World</b>:<br><br>
<code>#include<stdio.h><br>
int main() {<br>
printf("Hello World\n");<br>
return 0;<br>
}</code><br><br>
Il programma dopo la sua esecuzione stamperà sullo schermo la riga di testo <i>Hello World</i>.
Analizziamo ora riga per riga il funzionamento di questo programma per comprenderne tutti gli aspetti. <br>
La nostra analisi inizia dalla riga numero 2 con la Funzione <code>int main(){ </code> questa è la funzione principale del programma e tutto ciò che viene scritto all'interno delle parentesi graffe (all'interno del <b>blocco</b>) che seguono la scritta <b>main()</b>, farà parte di questa funzione. Un programma scritto in C può contenere molte funzioni, ma non può mai mancare la funzione main() dalla quale inizia l'esecuzione del programma stesso. L'elemento che ci fa capire che questa è una funzione sono le parentesi tonde <b>( )</b> subito dopo il nome; all'interno delle parentesi si possono scrivere elementi che saranno gli <b>argomenti</b> della funzione (la funzione main è priva di argomenti). Vedremo più avanti il funzionamento dettagliato delle funzioni. <br> Continuando con l'analisi del programma troviamo la riga <code>printf("Hello World\n");</code> . Si tratta di una funzione che consente di stampare sul monitor il contenuto delle parentesi tonde; nel nostro caso all'interno delle parentesi troviamo una <b>Stringa di testo</b>, ossia una serie di caratteri racchiusi tra apici (singoli o doppi). Ci accorgiamo però che a differenza della stringa che troviamo all'interno della funzione printf, quella stampata in output è leggermente differente; infatti non compaiono i due caratteri finali <b>\n</b>. Il carattere <b>\</b> si chiama <b>carattere di escape (fuga) </b> e combinato con altri caratteri ha delle funzioni speciali. Nel nostro caso combinato con la lettera <b>n</b> indica un ritorno a capo e quindi una nuova riga; se infatti proviamo a stampare sul monitor un'altra stringa di testo, vedremo che non verrà visualizzata sulla stessa riga di Hello World, bensì sulla riga sottostante.
Alla riga 4 del programma troviamo l'istruzione <code>return 0;</code>, questa se usata all'interno della funzione main determina la fine dell'esecuzione del programma e in questo caso, restituendo il valore 0 indica che il programma è terminato correttamente senza errori.<br> Infine vediamo il significato dell'istruzione <code>#include<stdio.h></code>; <b>#include</b> dice al compilatore di includere nel programma il contenuto del file posto tra <b> <  > </b>. In questo caso il file <b>stdio.h</b> contiene le librerie per la gestione di funzioni di input/output come printf(). Senza questa istruzione il compilatore non saprebbe interpretare l'istruzione <i>printf(..)</i> e restituirebbe un errore in fase di compilazione.|

titolo£[C] - Variabili|
linguaggio£C|
lezione£ Il concetto di <b>variabile</b> nel linguaggio C rappresenta una astrazione della cella di memoria.
L'istruzione di assegnamento, quindi, e` l'astrazione dell'operazione di scrittura nella cella che la variabile rappresenta e si fa con il carattere <b>=</b>. <br>
Esempi: <br>
<code>int a;<br> 
float pi;<br> 
char ch; <br>
... <br>
a=100; <br>
pi=3.1457;<br> 
ch='p';</code><br><br>
In ogni linguaggio di alto livello una variabile e` caratterizzata da un nome (identificatore) e quattro attributi base: <br>
 tipo, definisce l'insieme dei valori che la variabile puo` assumere e degli operatori applicabili. <br>
 valore, e` rappresentato (secondo la codifica adottata) nellarea di memoria legata alla variabile; <br>
 campo d'azione (scope), e` linsieme di istruzioni del programma in cui la variabile e` nota e puo` essere manipolata;<br>
 tempo di vita (o durata o estensione), e` lintervallo di tempo in cui unarea di memoria e` legata alla variabile;<br><br>
Esempio: <br>
/* programma che letto un numero a terminale stampa il valore della circonferenza del cerchio con quel raggio */<br><br>
<code>#include main() { <br>
	float X, Y; <br>
/* variabili locali */ <br>
	scanf("%f",&X); <br>
	Y = 2*3.14*X;<br>
 	printf("%f",Y); <br>
} </code><br><br>
<b>Definizione di costanti </b><br>
Una costante rappresenta un dato che non puo` cambiare di valore nel corso dellesecuzione.
La dichiarazione di una costante associa ad un identificatore (nome della costante) un valore (numero o altro identificatore di costante). <br><br>
Esempi: <br><br>
<code>
const float pigreco = 3.14; <br>
const float pigreco = 3.1415926; <br>
e = 2.7182;<br>
menoe = - e; </code><br>

Prima di essere usato, un identificatore deve essere gia` stato definito (ad es., e per definire menoe). Si aumenta la leggibilita` e modificabilita` dei programmi. <br>
Altra soluzione:  <b>#define</b> e` una direttiva del precompilatore C: provoca una sostituzione nel testo: <br><br>
<code>#define pigreco 3.14<br>
 #define e 2.7182<br> 
 #define menoe -e //non si alloca spazio in memoria </code> <br><br>
Esempio: <br>
/* programma che, letto un numero a terminale stampa il valore della circonferenza del cerchio con quel raggio */ <br><br>
<code>#include main() { <br>
	const float pigreco = 3.1415926; <br>
	float X, Y; <br>
	scanf("%f",&X); <br>
	Y = 2*pigreco*X; <br>
	printf("%f",Y); <br>
} </code><br>|


titolo£[C]-Tipo di dato|
Linguaggio£C|
lezione£
<b>Tipo di dato </b>

Un tipo di dato T e` definito come: <br>
 Un insieme di valori D (dominio) <br>
 Un insieme di funzioni (operazioni) f1,...,fn, definite sul dominio D; <br>
In pratica: Un tipo T e` definito: <br>
 dallinsieme di valori che variabili di tipo T potranno assumere, <br>
 dallinsieme di operazioni che possono essere applicate ad operandi del tipo T.<br>
Esempio: Consideriamo i numeri naturali naturali = [N, {+, *, =, >, < }] <br>
3*4 ---> 12<br>
3>=4 ---> falso<br>
<br>
Rappresentazione per un tipo di dato: descrizione del tipo di dato attraverso le strutture linguistiche fornite dal linguaggio di programmazione scelto. <br>
<br>
<b>Il concetto di Tipo</b> <br>
Proprieta`: <br>
--> Ciascun dato (variabile o costante) del programma deve appartenere ad un solo tipo.<br> 
--> Ciascun operatore richiede operandi di tipo specifico e produce risultati di tipo specifico. <br>
<br>
Vantaggi: Se un linguaggio di programmmazione e` tipato: <br>
--> Astrazione:Lutente esprime i dati ad un livello di astrazione piu` alto della loro organizzazione fisica. Linsieme di bit che rappresenta un valore di un certo tipo non e` accessibile. Maggior portabilita`. <br>
--> Protezione: Il linguaggio protegge lutente da combinazioni errate di dati ed operatori (controllo statico sulluso di variabili, etc. in fase di compilazione). <br>
--> Portabilita`: lindipendenza dallarchitettura rende possibile la compilazione dello stesso programma su macchine profondamente diverse. <br>
<br>
<br>
<b>Tipo di Dato in C </b><br>
In C si possono utilizzare: <br>
 tipi primitivi: sono tipi di dato previsti dal linguaggio (built-in) e quindi rappresentabili direttamente. <br>
 tipi non primitivi: sono tipi definibili dallutente (mediante appositi costruttori di tipo, v. typedef). Inoltre si distingue tra:<br> 
 tipi scalari, il cui dominio e` costituito da elementi atomici, cioe` logicamente non scomponibili. <br>
 tipi strutturati, il cui dominio e` costituito da elementi non atomici (e quindi scomponibili in altri componenti). <br>
<br>
<br>
<b>Tipi primitivi </b><br>
Il C prevede quattro tipi primitivi: <br>
 <b>char</b> (caratteri) <br>
 <b>int</b> (interi) <br>
 <b>float</b> (reali) <br>
 <b>double</b> (reali in doppia precisione) <br>
<b>Qualificatori e Quantificatori</b><br>
  E` possibile applicare ai tipi primitivi dei quantificatori e dei qualificatori: <br>
 I quantificatori (long e short) influiscono sullo spazio in memoria richiesto per lallocazione del dato. <br>
	 short (applicabile al tipo int)<br> 
	 long (applicabile ai tipi int e double) int X; long int Y; <br>
 I qualificatori condizionano il dominio dei dati:<br> 
	 signed (applicabile ai tipo int e char) <br>
	 unsigned (applicabile ai tipo int e char) int A; unsigned int B; <br>
<br>
<br>
<b>Il tipo int </b><br>
Il dominio associato al tipo int rappresenta linsieme dei numeri interi (cioe` Z, insieme dei numeri relativi): ogni variabile di tipo int e` quindi l'astrazione di un intero. <br>
int A; /* A e` un dato intero */ <br>
? Poiche` si ha sempre a disposizione un numero finito di bit per la rappresentazione dei numeri interi, il dominio rappresentabile e` di estensione finita. <br>
Ad esempio: se il numero n di bit a disposizione per la rappresentazione di un intero e` 16, allora il dominio rappresentabile e` composto di: (2^n-1)= 216-1= 65.536 valori <br>
<u>Uso dei quantificatori short/long: </u><br>
Aumentano/diminuiscono il numero di bit a disposizione per la rappresentazione di un intero: spazio(short int) <= spazio(int) <= spazio(long int) <br>
<u>Uso dei qualificatori: </u><br>
 signed: viene usato un bit per rappresentare il segno. <br>
Quindi lintervallo rappresentabile e`: [-2^(n-1)-1, +2^(n-1)-1] <br>
 unsigned: vengono rappresentati valori a priori positivi. <br>
Intervallo rappresentabile: [0, (2^n - 1)] <br>
<br>
<b>Operatori relativi ai puntatori (&, *)</b> <br>
Ci sono due operatori particolarmente importanti per lavorare con i puntatori: & e *. <br>
Loperatore <b>&</b<> applicato ad una variabile restituisce il suo indirizzo di memoria (puntatore alla variabile). <br>
Loperatore <b>*</b> applicato ad un indirizzo di memoria (puntatore) restituisce il valore contenuto in quellindirizzo. <br>
Se a è una variabile e pa il suo puntatore avremo quindi: <br>
&a restituisce pa <br>
*pa restituisce a <br>
<u>Esempio </u><br>
Il comando &x individua il puntatore corrispondente alla variabile x mentre, fuori da un blocco di definizione, lespressione *pminimo indica il valore della variabile puntata da pminimo<br>
|
titolo£[C]-Operatori su Interi|
Linguaggio£C|
lezione£
<b>Operatori sugli interi </b><br>
Al tipo int (e tipi ottenuti da questo mediante qualificazione/quantificazione) sono applicabili i seguenti operatori: <br>
<br>
<b>Operatori aritmetici: </b><br>
forniscono risultato intero:<br>
+, -, *, / -->  somma, sottrazione, prodotto, divisione intera.<br>
% operatore modulo -->   resto della divisione intera: 10%3 "<br> 
1 ++, --   -->  incremento e decremento: richiedono un solo operando (una variabile) e possono essere postfissi (a++) o prefissi (++a)<br>
<br>
<b>Operatori relazionali: </b><br>
si applicano ad operandi interi e producono risultati booleani (cioe`, il cui valore puo` assumere soltanto uno dei due valori {vero, falso}): <br>
==, != uguaglianza, disuguaglianza: <br>
10==3 -->falso  <br>
10!=3 --> vero <br>
< , > , <=, >=   minore, maggiore, minore o uguale, maggiore o uguale <br>
10>=3 --> vero <br>
<br>
<u>Esempio: </u><br>
<code><br>
/*programma che, letti due numeri a terminale, effettua la stampa del maggiore dei due */ <br>
<br>
#include main() { <br>
<br>
	int X,Y; <br>
<br>
	scanf("%d%d",&X,&Y); <br>
	if ( X > Y )<br>
		 printf("%d",X); <br>
	else <br>
		 printf("%d",Y); <br>
}</code><br>
<br>
<b>Booleani </b><br>
Sono dati il cui dominio e` di due soli valori (valori logici): {vero, falso} <br>
In C non esiste un tipo primitivo per rappresentare dati booleani. <br>
Come vengono rappresentati i risultati di espressioni relazionali ? Il C prevede che i valori logici vengano rappresentati attraverso interi: <br>
 Ad esempio, l'espressione A == B restituisce: " 0, se la relazione non e` vera " 1 , se la relazione e` vera <br>
<br>
<b>Operatori logici: </b><br>
si applicano ad operandi di tipo int e producono risultati booleani, cioe` interi appartenenti all'insieme {0,1} (il valore 0 corrisponde a falso, il valore 1 corrisponde a vero). <br>
In particolare linsieme degli operatori logici e`:<br>
&& operatore AND logico<br>
\\ operatore OR logico <br>
! operatore di negazione (NOT) <br>
<br>
In C, gli operandi di operatori logici sono di tipo int: <br>
 se il valore di un operando e` diverso da zero, viene interpretato come vero. <br>
 se il valore di un operando e` uguale a zero, viene interpretato come falso. <br>
<br>
<b>I tipi float e double (reali) </b><br>
Rappresentano linsieme dei numeri reali.<br> 
In realta`, sono un'approssimazione dei reali, sia come precisione che come intervallo di valori. Lo spazio allocato (e quindi l'insieme dei valori rappresentabili) dipende dalla rappresentazione adottata.<br>
 Uso del quantificatore long: si puo` applicare a double, per aumentare la precisione: <br>
spazio(float) <= spazio(double) <= spazio(long double) <br>
<br>
<b>Il tipo char </b><br>
Rappresenta linsieme dei caratteri disponibili sul sistema di elaborazione (set di caratteri). <br>
Per carattere si intende ogni simbolo grafico rappresentabile all'interno del sistema. <br>
Ad esempio: <br>
 le lettere dell'alfabeto (maiuscole, minuscole) <br>
 le cifre decimali ('0',..'9')  i segni di punteggiatura (',', '.' etc.) <br>
 altri simboli di vario tipo ('+', '-', '&', '@', etc.).<br> 
Ogni valore viene specificato tra singoli apici. <br>
Ad esempio: a b A 0 2 Come per i numeri, anche il dominio associato al tipo char e` ordinato.<br>
 Lordine dipende dal codice utilizzato nella macchina.<br>
 Di solito, codice ASCII esteso. <br>
<br>
<b>Operatori sui caratteri</b><br>
 Il linguaggio C rappresenta i dati di tipo char come degli interi: ogni carattere viene mappato sull'intero che rappresenta il codice nella tabella dei set di caratteri.<br> 
--> sui dati char e` possibile eseguire tutte le operazioni previste per gli interi.<br> 
Ogni operazione, infatti, e` applicata ai codici associati agli operandi.<br>
|
titolo£[C]-Espressioni|
Linguaggio£C|
lezione£
<b>Espressioni </b><br>
Un'espressione e` una regola per il calcolo di un valore. <br>
E` una combinazione di operandi tramite operatori. <br>
3 * (17 - 193) % 19 (3 < 7) && (4 <= 5) (X > 10) <br>
--> A ciascuna variabile che compare in una espressione deve essere gia` stato attribuito un valore: lespressione utilizza il valore corrente della variabile.<br>
 Una espressione C puo` essere un'espressione aritmetica, relazionale, logica, di assegnamento o sequenziale. <br>
<br>
<b>Espressioni Aritmetiche: </b><br>
A seconda del tipo degli operandi, restituiscono valore intero oppure reale. <br>
 Espressioni aritmetiche di incremento e decremento: Si applicano ad operandi di tipo intero (o reale, o carattere) e producono un risultato dello stesso tipo. <br>
int A=10; <br>
A++; /*equivale a: A=A+1; */ <br>
A--; /*equivale a: A=A-1; */<br>
 Notazione Prefissa: (ad esempio, ++A) significa che l'incremento viene fatto prima dell'impiego del valore di A nella espressione.<br> 
 Notazione Postfissa: (ad esempio, A++) significa che l'incremento viene effettuato dopo l'impiego del valore di A nella espressione. <br>
<br>
Ad esempio: <br>
<code><br>
int A=10, B; <br>
char C='a'; <br>
B=++A;                      /*A e B valgono 11 */ <br>
B=A++;                       /* A=12, B=11 */ <br>
C++;                               /* C vale 'b' */<br>
 int i, j, k; k = 5;<br>
 i = ++k;                        /* i = 6, k = 6 */<br>
 j = i + k++;                             /* j=12, i=6,k=7 */ <br>
j = i + k++;                         /*equivale a: j=i+k; k=k+1;*/ <br>
</code><br>
--> Si possono scrivere espressioni il cui valore e` difficile da predire:<br>
<code><br>
 k = 5; <br>
j = ++k + k++;                /* j=12,k=7 */ <br>
</code><br>
<br>
<b>Espressioni relazionali:</b><br>
 Restituiscono un valore vero (in C, uguale a 1) o falso (in C, uguale a 0). <br>
Sono ottenute applicando gli operatori relazionali ad operandi compatibili. (3 < 7) x <= y<br>
<br>
 <b>Espressioni logiche:</b><br>
 Sono ottenute mediante gli operatori di: <br>
 complemento (not) ! <br>
 congiunzione (and) && <br>
 disgiunzione (or) \\ <br>
<br>
<b>Espressione di assegnamento:</b> <br>
Il simbolo <b>=</b> e` un operatore l'istruzione di assegnamento e` una espressione che ritorna un valore: <br>
 il valore ritornato e` quello assegnato alla variabile a sinistra del simbolo = <br>
 il tipo del valore ritornato e` lo stesso tipo della variabile oggetto dell'assegnamento <br>
<br>
|
titolo£[C]-Istruzioni di Input/Output|
Linguaggio£C|
lezione£
<b>Istruzioni di ingresso ed uscita (input/output) </b><br>
<br>
L'immissione dei dati di un programma e luscita dei suoi risultati avvengono attraverso operazioni di lettura e scrittura. 
Il C non ha istruzioni predefinite per l'input/output. <br>
In ogni versione ANSI C, esiste una Libreria Standard (stdio) che mette a disposizione alcune funzioni (dette funzioni di libreria) per effettuare l'input e l'output. <br>
Le dichiarazioni delle funzioni messe a disposizione da tale libreria devono essere essere incluse nel programma: <code>#include</code><br> 
<code> #include</code> e` una direttiva per il preprocessore C: nella fase precedente alla compilazione del programma ogni direttiva #... provoca delle modifiche testuali al programma sorgente. <br>
Nel caso di #include viene sostituita listruzione stessa con il contenuto del file specificato. Dispositivi standard di input e di output: per ogni macchina, sono periferiche predefinite (generalmente tastiera e video). <br>
<br>
<b>Input/Output </b><br>
Il C vede le informazioni lette/scritte da/verso i dispositivi standard di I/O come file sequenziali, cioe` sequenze di caratteri (o stream). Gli stream di input/output possono contenere dei caratteri di controllo: <br>
 End Of File (EOF) <br>
 End Of Line ... <br>
Sono Disponibili funzioni di libreria per: <br>
 Input/Output a caratteri <br>
 Input/Output a stringhe di caratteri <br>
 Input/Output con formato <br>
<br>
<b>I/O con formato </b><br>
Nell'I/O con formato occorre specificare il formato (tipo) dei dati che si vogliono leggere oppure stampare.<br> 
Il formato stabilisce: <br>
 come interpretare la sequenza dei caratteri immessi dal dispositivo di ingresso (nel caso della lettura) <br>
 con quale sequenza di caratteri rappresentare in uscita i valori da stampare (nel caso di scrittura) <br>
<br>
<b>Lettura: scanf </b><br>
E` una particolare forma di assegnamento: la scanf assegna i valori letti alle variabili specificate come argomenti (nell'ordine di lettura).<br>
<br>
Ad esempio: <br>
<code>int X; <br>
float Y; <br>
scanf("%d%f", &X, &Y);</code> <br>
<br>
 legge una serie di valori in base alle specifiche contenute in : in questo caso "%d%f" indica che devo leggere due valori, uno decimale (%d) ed uno reale (%f) <br>
 memorizza i valori letti nelle variabili (X, Y nell'esempio) <br>
 e` una funzione che restituisce il numero di valori letti e memorizzati, oppure EOF in caso di end of file <br>
 Gli identificatori delle variabili a cui assegnare i valori sono (quasi) sempre preceduti dal simbolo &. Ad esempio: <code>scanf(%d%d%d, &A, &B, &C)</code>; => richiede tre dati interi da leggere <br>
<br>
<b>Scrittura: printf</b> <br>
La printf viene utilizzata per fornire in uscita il valore di una variabile, o, piu` in generale, il risultato di una espressione. Anche in scrittura e` necessario specificare (mediante una stringa di formato) il formato dei dati che si vogliono stampare. <br>
Ad esempio:<br>
<code> int X; <br>
float Y; <br>
printf("%d%f", X*X,Y);</code> <br>
<br>
 scrive una serie di valori in base alle specifiche contenute in <stringa-formato> . In questo caso, un intero (%d), ed un reale (%f). <br>
 i valori visualizzati sono i risultati delle espressioni che compaiono come argomenti <br>
 restituisce il numero di caratteri scritti. <br>
 la stringa di formato della printf puo` contenere sequenze costanti di caratteri da visualizzare, ad esempio il carattere di controllo \n (newline). <br>
|
titolo£[C]-Cicli|
Linguaggio£C|
lezione£

<b>Cicli</b><br>
Ci sono almeno tre modi diversi per costruire un ciclo in C e occorre utilizzare quello che meglio si
adatta alle esigenze del problema che si vuole risolvere.<br>
<code>while (espressione){<br>
istruzione;<br>
}</code><br>
<code>do<br>
istruzione;<br>
while (espressione);<br>
for (variabile di controllo= espressione iniziale; condizione di ciclo; legge di incremento){<br>
istruzione; }</code><br>
Le espressioni possono essere espressioni logiche (condizioni) che hanno un valore booleano
(vero/falso), ma possono anche essere espressioni qualsiasi.<br>
Nel secondo caso vengono considerate false quando il loro valore è zero, vere altrimenti.<br>
Le istruzioni possono essere istruzioni composte (racchiuse tra {}). Il ciclo do...while corrisponde al
ciclo repeat...until del Pascal. I cicli possono essere uno dentro l’altro (nidificazione).<br>
L’esecuzione di un <b>break</b> interrompe il ciclo più interno ma non gli altri.<br>
<b>While</b><br>
<code>while (condizione){<br>
istruzione</code>;<br>
}<br>
esegue l’istruzione finché il valore della condizione è true, appena quel valore diventa false esce dal ciclo<br>
<u>Esempio</u><br>
<code>Calcola 1 + 1/2 + 1/3 + ... + 1/n /*programma per while*/<br>
void main (void) {<br>
int n;<br>
float h;<br>
scanf (“%d”,&n);<br>
printf(“%d”,n);<br>
h= 0;<br>
while (n>0) {<br>
h= h + 1/n; /*oppure h+=1/n*/<br>
n = n-1; /* oppure n--*/ }<br>
printf (“Somma=%e \n”,h); }</code><br>
Produce (se n=10): 10 Somma = 0.292896E+1<br>
<br>
<b>Do ... While</b>
<code>do<br>
istruzione;<br>
while (condizione){...;<br>
}</code><br>
Ripete le istruzioni finché il valore della condizione è true. Poiché l’istruzione viene eseguita prima
della valutazione della espressione, il ciclo viene eseguito almeno una volta. Vediamo lo stesso
esempio con la nuova costruzione<br>
<u>Esempio</u><br>
</code><br>
/*programma per do ... while*/<br>
void main (void) {<br>
int n;<br>
float h;<br>
scanf (“%d”,&n);<br>
printf(“%d”,n);<br>
h=0;<br>
do{<br>
h = h+1/n; /*oppure h+=1/n */<br>
n=n-1; /* oppure n-- */<br>
}<br>
while (n!=0);<br>
printf(“Somma=%e \n”,h);</code><br>
<br>
Il risultato è lo stesso ma ilsecondo programma non va bene se n!0 perché, se n=0 c’è un errore di
division by zero mentre se n<0 il ciclo viene ripetuto infinite volte (visto che la variabile n in quel
caso non può annullarsi mai).<br>
<br>

<b>for</b><br>
<code>for (variabile di controllo=espressione iniziale; condizione di ciclo; legge di incremento)<br>
istruzione;</code><br>
In C e C++ il ciclo for è molto flessibile. Può semplicemente eseguire le instruzioni all’interno del
ciclo al variare della variabile di controllo tra un valore iniziale ed un valore finale oppure può
eseguirle fino a che non si verifica una condizione di uscita (NOT(condizione di ciclo)).<br>
Normalmente il valore iniziale ed il valore finale sono variabili interi, inoltre devono soddisfare le
condizioni seguenti:<br>
valore iniziale<(>)valore finale se la variabile di controllo decresce (cresce) nel ciclo
E’ obbligatorio specificare l’incremento della variabile di controllo.<br>
<u>Esempio</u><br>
<code>/* programma per for*/<br>
main (void){<br>
int n,i;<br>
float h;<br>
scanf(“%d”,&n); <br>
printf(“%d”,n); h= 0;<br>
for (i=1; i<=n;i++)<br>
h = h+1/i; /*oppure h+=1/i */<br>
printf(“Somma=%e \n”,h); }</code><br>
Anche per le alternative ci sono varie istruzioni che vengono usate per scopi diversi :<br>
<br>
<b>if...else</b><br>
<code>if (condizione )istruzione;<br>
else istruzione;</code><br>
oppure, in una versione leggermente semplificata,<br>
<code>switch (espressione case)<br>
{<br>
case const_1: istruzione1;<br>
break;<br>
case const_2: istruzione2;<br>
break;<br>
case const_N: istruzioneN;<br>
break;<br>
default : istruzione _alternativa;<br>
break; }</code><br>
|
titolo£[C]-Vettori e Matrici|
Linguaggio£C|
lezione£
<b>Vettori/Matrici (array) </b><br>
In C le matrici e i vettori si definiscono indicando il tipo dei loro elementi e le loro dimensioni tra <b>[ ]</b>. Non si possono definire <br>matrici di matrici. <br>
Esempio<code> <br>
int vettore V[10] <br>
int matrice_A [2][10] <br>
float matrice_M [5] [20] </code><br>
sono rispettivamente un vettore a 10 componenti intere, una matrice di interi 2x10 ed una matrice di reali 5x20. In C il primo elemento di un vettore/matrice ha indice 0, dunque il primo elemento di V č V[0] e lultimo č V[9] mentre il il primo elemento di M č M[0][0] e lultimo è <code>M[4][19]</code>. Loccupazione di memoria di una matrice nxm č pari a n x m x occupazione di un reale (o intero) <br>
<br>
In realtà, le matrici vengono memorizzate per riga sotto forma di vettori. <br>
Come vedremo, questa particolaritŕ rende un pň piů complessa una efficiente gestione di matrici/vettori. <br>
Esempio  <br>      
Matrice A<br>
1 0 2 3 <br>
6 -1 5 4 <br>
7 8 -3 9  <br>
<br>
diventa in memoria Vettore a 1 0 2 3 6 -1 5 4 7 8 -3 9 <br>
In questo modo lelemento A[i][j] di una matrice nxm viene memorizzato nellelemento a[i*m+j] del vettore (perchč il primo indice č comunque 0). Come vedremo, questa equivalenza è importante, per individuare gli elementi di una matrice attraverso i loro indirizzi di memoria. <br>
<br>
Come abbiamo visto, le variabili possono essere anche di tipo puntatore ad una variabile. Una variabile di tipo puntatore conterrà lindirizzo di memoria di unaltra variabile di tipo int, char, float,... Non č possibile (nč avrebbe senso) definire una variabile puntatore universale, cioč che punti indifferentemente ad una variabile intera, reale, character,... <br>
Di conseguenza, a fianco del puntatore bisogna sempre indicare qual è il tipo di variabile cui punta. Per indicare che una variabile è un puntatore, nella sua dichiarazione occorre mettere * prima del nome.<br> 
<br>
Esempio <br>
<code>int *pn,*pm; <br>
float *px,*py, x; <br>
</code><br>
definiscono rispettivamente 2 puntatori ad interi (pn,pm), 2 puntatori a reali (px,py) e 1 variabile reale x. Ci sono due operatori particolarmente importanti per lavorare con i puntatori: & e *. Loperatore <b>&</b> applicato ad una variabile restituisce il suo indirizzo di memoria (puntatore alla variabile). Loperatore <b>*</b> applicato ad un indirizzo di memoria (puntatore) restituisce il valore contenuto in quellindirizzo. <br>
In C è essenziale avere un controllo diretto sugli indirizzi di memoria corrispondenti alle variabili. Due funzioni (della libreria stdlib.h) sono particolarmente utili a questo scopo: <br>
&ensp; -<b>sizeof</b>(tipo_della_variabile) <br>
&ensp; -<b>malloc</b>(numero_di_bytes) <br>
La funzione sizeof restituisce il valore in bytes delloccupazione di memoria del tipo di variabile specificata nellargomento.<br> 
La gestione della memoria che viene occupata da matrici e vettori (array) è un po piů complessa rispetto ad altri linguaggi perché in C si utilizzano in maniera piů trasparente gli indirizzi di memoria delle singole componenti di un vettore/matrice. Una matrice A[n][m] č una matrice a n righe e m colonne e gli indici dei suoi elementi A[i][j] sono tali che 0!i!n-1 e 0!j!m-1. <br>
Una matrice in C viene trattata come un vettore di vettori (array di array) e viene memorizzata per righe in un unico vettore a nxm componenti. 
Lelemento A[i][j] della matrice viene quindi memorizzato nellelemento di posto i*m+j. Il suo indirizzo di memoria è &A[i][j] e corrisponde allindirizzo di memoria<br>
 <code>&A[0][0]+i*m+j</code><br>
 cioè nellindirizzo che si ottiene sommando allindirizzo di memoria del primo elemento A[0][0] il numero degli elementi che precedono A[i][j]. <br>
Questo è vero qualunque sia il tipo degli elementi della matrice e dipende dal fatto che le operazioni sui puntatori tengono conto del tipo di dato cui punta la variabile. <br>
|
titolo£[C]-Passaggio di Variabili|
Linguaggio£C|
lezione£
<b>Passaggio di variabili nelle funzioni </b><br>
Come abbiamo già visto, un programma C è articolato in sottoprogrammi che vengono chiamati funzioni. E naturale passare le variabili da una funzione ad unaltra oppure dal programma principale (che in C è comunque una funzione) ad unaltra funzione. La prima funzione viene solitamente indicata come funzione chiamante . In C il passaggio delle variabili è per valore, per questo motivo eventuali modifiche delle variabili passate potrebbero rimanere inaccessibili alla funzione chiamante. Se si vuole permettere ad una funzione di cambiare una variabile x occorre passarne lindirizzo in memoria, cioè il programma chiamante deve passare alla funzione &x ( e non x).<br> 
<u>Esempio:</u> <br>
<b>Passaggio per valore </b><br>
<code><br>
float media(float x,y,z){ <br>
	return((x+y+z)/3) <br>
}<br>
</code><br>
La chiamata a questa funzione è media(a,b,c) dove a,b,c, devono essere tre reali in semplice precisione (float). Il comando return serve ad assegnare a media il valore tra () alluscita dalla funzione. In questo modo vengono create tre variabili di appoggio temporanee per contenere x,y,z. All'uscita della procedura quelle variabili vengono cancellate e non sono più recuperabili. Dalla procedura esce solo il valore della media. <br>
Viene usato quando si vuole recuperare il contenuto delle variabili che vengono passate alla fine della esecuzione della funzione. Questo permette di utilizzare i valori in uscita in altre funzioni. <br>
<br>
<u>Esempio</u> <br>
<code><br>
lettura_dati(float *x,*y)<br>
{ /* x e y sono puntatori reali*/ <br>
	printf(inserisci il valore della prima variabile \n); <br>
	scanf(%e,x); <br>
	printf(inserisci il valore della seconda variabile \n); <br>
	scanf(%e,y); <br>
	return() } <br>
	</code><br>
la chiamata alla funzione è lettura_dati(&a,&b) /*vengono passati gli indirizzi*/ <br>
<br>
Ovviamente a, b devono essere variabili reali (float) altrimenti il tipo con corrisponderebbe alla definizione della funzione. In questo modo le variabili non vengono create perché già esistono (come indirizzi) e sono utilizzabili anche in seguito. Si evita la duplicazione. Si può passare ad una funzione un numero arbitrario di variabili, alcune saranno passate per valore altre per indirizzo. <br>
|
titolo£[C]-Ricorsione|
Linguaggio£C|
lezione£
<b>Ricorsione</b><br>
Si parla di funzione ricorsiva quando una funzione richiama se stessa. <br>
Supponiamo che la funzione p che vogliamo definire sia lelevamento a potenza, xn.<br>
Ovviamente possiamo scrivere una assegnazione del tipo p=x*x*x*x*x.......*x n volte <br>
In modo più elegante, possiamo definire xn in modo ricorsivo come 1 se n=0 per ogni x xn = x* xn-1 altrimenti <br>
Il linguaggio C, come altri linguaggi moderni, permette di scrivere funzioni ricorsive.<br> 
Vediamo come possiamo definire una funzione ricorsiva per x^n<br> 
<u>Esempio</u> <br>
Supponiamo che n sia >=0. <br>
La funzione richiede una variabile di appoggio app<br>
 <code><br>
float p(float x; int n) { <br>
	float app; <br>
	if (n=0) <br>
		then app=1 <br>
	else {<br>
		app=x; <br>
		for(i=1;i <n;i++){<br>
			app= x*app } <br>
	return app;<br>
}<br>
</code><br>
La sua versione ricorsiva <br>
<code><br>
float p(float x; int n) {<br>
 /*indirizzo 1*/ <br>
if (n>0) <br>
	return(x*p(x,n-1)); <br>
/*indirizzo 2*/ <br>
else 	<br>
	return(1); } <br>
	</code><br>
non la richiede ed è molto più compatta. <br>
Si osservi anche che ambedue le funzioni producono un risultato sbagliato per n<0. La chiamata alla funzione è, ad esempio, p(y,4).
 Bisogna sapere che la definizione di una funzione ricorsiva è certamente più elegante ma non necessariamente più efficiente dal punto di vista del calcolo. <br>
Infatti, scrivere una funzione ricorsiva corrisponde fare il calcolo in due tempi: 1. Prima si costruisce una tabella (pila) in cui c'è l'indirizzo dell'istruzione da cui viene fatta la chiamata (indirizzo 1) e lindirizzo della istruzione chiamata nella definizione (indirizzo 2). <br>
Se il numero delle iterazioni è noto dallinizio (come ad esempio nel prodotto matrice per vettore) converrà usare un ciclo for evitando in questo modo la creazione della pila.<br>
|

titolo£[Java]-Introduzione|
Linguaggio£Java|
lezione£
il linguaggio e la tecnologia Chi si avvicina a Java per la prima volta ne resta al contempo affascinato ma a volte anche piuttosto confuso, data la vastità degli argomenti che compongono il panorama legato a questa tecnologia. In questo capitolo verrà fatta una breve panoramica sui concetti introduttivi legati a Java, in modo da poter iniziare a scrivere i primi programmi: al termine dovrebbero essere stati acquisiti gli elementi basilari di pratica e teoria tali da permettere di addentrarsi nella teoria vera e propria esposta nei capitoli successivi. <br>
<br>
<b>Sviluppo di applicazioni Java</b> <br>
Il problema delle performance è probabilmente il tallone di Achille dei programmi scritti in Java: lutilizzo di codice bytecode interpretato, unitamente alla presenza di un software interpretato, fa si che unapplicazione Java mediamente sia meno efficiente di una scritta in codice nativo. Questa osservazione è meno vera nel caso di applicazioni distribuite o fortemente orientate alluso della rete. La semplicità con cui Java permette di costruire applicazioni netoriented basate su architetture distribuite o multi-layer, consente di sfruttare a pieno i vantaggi di questi modelli di computazione e di ridurre limportanza delle velocità assoluta. Spesso le applicazioni Java, benché lente in senso assoluto. Le innumerevoli classi contenute nel JDK coprono tutte le casistiche di programmazione, dalla grafica alla gestione del multithreading, alla programmazione per la rete, alla manipolazione delle basi di dati. Le classi sono raggruppate in <b>packages</b> secondo una organizzazione molto precisa. Attualmente è disponibile una quantità impressionante di classi e package aggiuntivi.<br> 
<br>
<b>I packages</b> <br>
Lorganizzazione delle classi in gerarchie di oggetti è un fatto ormai consolidato in ogni linguaggio a oggetti, mentre lutilizzo dei package, sebbene non sia prerogativa di Java, ha avuto nuovo impulso grazie a questo linguaggio. Un package è un particolare contenitore che può raccogliere al suo interno una serie di classi o altri packages: strutturalmente seguono il modello delle directory del filesystem, le quali possono contenere sia file che altre directory. Fra i vari motivi che hanno spinto Sun ad adottare una organizzazione a package, vi è la volontà di semplificare e ordinare il codice. Utilizzo dei package Più classi possono essere impacchettate logicamente in un unico contenitore, un package, e in tal caso esse vengono individuate dallindicazione nomepackage.nomeclasse. <br>
<br>
<b>Gli specificatori: static e final </b><br>
Le <b>keyword public</b>, <b>private</b> e <b>protected</b> non sono le uniche che si possono utilizzare in abbinamento a un metodo o a una classe per specificarne ulteriormente la natura. Esiste anche static, che ha un significato completamente differente, e varia a seconda che si riferisca a un metodo o a una proprietà. Nel caso si definisca una proprietà <b>static</b>, allora tale proprietà sarà condivisa fra tutte le istanze di tale classe.Lo specificatore static applicato invece a un metodo indica che esso può essere invocato anche se la classe di cui fa parte non è stata istanziata. Un caso tipico è quello del metodo main che può  e anzi deve  essere chiamato senza che la classe sia stata creata con una chiamata a new: in questo caso non potrebbe essere altrimenti, dato che tale metodo ha proprio lo scopo di far partire lapplicazione, quando nessuna classe ancora esiste. <br>
Il metodo statico può quindi essere invocato sulla classe e non necessariamente sulloggetto: ad esempio avendo <br>
<code><br>
Public class MyClass { <br>
Public static myMethod() {} <br>
Public static void main(String args[]) { <br>
MyClass.myMethod(); } <br>
} </code><br>
Anche la key final assume un significato differente a seconda che venga abbinata a un metodo o a una proprietà. In questo secondo caso infatti serve per definire un valore costante che non può più essere modificato dopo la definizione e che quindi, proprio per questo motivo, deve essere specificato al momento della definizione/creazione .<br>
|
titolo£[Java]-Controllo del flusso|
Linguaggio£Java|
lezione£
<b>Controllo del flusso </b><br>
Per controllare il flusso delle operazioni allinterno dei metodi, Java mette a disposizione una serie di parole chiave e di costrutti molto simili a quelli che si trovano negli altri linguaggi di programmazione procedurali. In particolare i vari ifthenelse, for e while si basano su una sintassi molto semplice che ricalca più o meno fedelmente quella messa a disposizione dal linguaggio C. Di seguito è riportato un breve promemoria della sintassi e del significato di ogni costrutto. <br>
<br>
<b>Costrutto if else </b><br>
<code><br>
if(espressione booleana) <br>
	istruzione1 <br>
else <br>
	istruzione2 <br>
</code><br>
Esegue il blocco istruzione1 se espressione booleana assume il valore booleano true, altrimenti esegue il blocco istruzione2. <br>
<br>
<b>Costrutto while e do while </b><br>
<code><br>
while(espressione booleana) <br>
	istruzione <br>
</code><br>
Esegue il blocco istruzione fino a che espressione booleana assume il valore booleano true. Funzionalità analoga è offerta dal costrutto dowhile do istruzione while(espressione booleana) 
La differenza fra i due costrutti è che nel primo caso il controllo viene effettuato prima di eseguire istruzione, mentre, nel secondo caso, dopo. <br>
<br>
<b>Costrutto for</b><br>
<code> <br>
for(espressione di inizializzazione; espressione booleana; espressione di incremento)<br>
	 { istruzione } <br>
</code><br>
Esegue il blocco for fino a che espressione booleana assume valore booleano true; la espressione di inizializzazione viene eseguita solo la prima volta, mentre espressione di incremento ad ogni iterazione. <br>
<br>
<b>Costrutto switch </b><br>
<code><br>
switch variabile <br>
	case valore1: istruzione1 <br>
	case valore2: istruzione2 <br>
	case valore3: istruzione3 <br>
	case valore4: istruzione4 <br>
	default: <br>
</code><br>
Esegue un controllo sulla variabile intera variabile ed esegue il blocco di codice che segue il case corrispondente al valore assunto dalla variabile. Infine viene sempre eseguito il blocco default. Tale costrutto prevede che lesecuzione del blocco relativo al case n non impedisca lesecuzione dei blocchi successivi. Per imporre invece tale restrizione si utilizza la parola chiave break, la quale inoltre viene utilizzata genericamente per uscire da un qualsiasi blocco di codice (dallinterno del corpo di un metodo come da un ciclo for o while). <br>
<br>
<b>Costrutto continue </b><br>
<br>
Unespressione continue provoca il salto alla fine del ciclo dove è inserita, passando direttamente alla valutazione della espressione booleana che controlla tale ciclo. In un ciclo è possibile specificare una etichetta di un ciclo più esterno, in modo da applicare la funzionalità continue a tale ciclo e non a quello interno. Si tenga presente che in Java non è presente il goto: una delle funzioni di tale costrutto, presente in altri linguaggi procedurali, è quella ad esempio di controllare cicli esterni a quello annidato, cosa che può essere fatta con il break e continue con etichetta. Altro scopo del break è quello di saltare un blocco di codice (non interno a un ciclo) in concomitanza di una qualche condizione di errore: anche in questo caso il break con etichetta può essere utilizzato in sostituzione. 
Infine un ulteriore impiego del goto è quello che consente di eseguire codice di pulizia prima delluscita da un metodo o da un blocco: anche in questo caso in Java si utilizza il break con etichetta o il costrutto finally se si è allinterno di una <b>trycatch. </b>
<br>
<b>Costrutto return </b><br>
<br>
Viene utilizzato per permettere a un metodo di restituire un valore allesterno. Ad esempio: <br>
<code><br>
public int add(int i1, int i2) <br>
{ return i1 + i2; } <br>
</code><br><br>
return deve restituire un valore assegnabile a quello definito nella firma del metodo: la regola base da seguire è quella utilizzata normalmente in tutte le operazioni di assegnazione, quindi se il tipo non è esattamente lo stesso, deve essere effettuato un cast implicito o forzato. Si veda a tal proposito la parte relativa ai tipi riportata poco più avanti. Per quanto riguarda il costrutto trycatch si veda la sezione dedicata alla gestione delle eccez<br>ioni. <br>
<br>
<b>Definizione/invocazione di metodi e passaggio di parametri</b><br>
 Una delle caratteristiche fondamentali di Java è che i parametri nelle invocazioni dei metodi sono passati per valore. Questa modalità, come ben noto è una delle due alternative possibili utilizzabile insieme a quella per riferimento nella maggior parte dei linguaggi procedurali: essa si traduce nella realizzazione di una copia del parametro tutte le volte che si effettua una chiamata a un determinato parametro. Ad esempio, nel caso in cui si abbia <br>
<code><br>
Public void myMethod (String str) {<br> 
... fai qualcosa con il parametro str }<br>
 </code><br>
e supponendo di invocare tale metodo nel seguente modo ... <br>
<code><br>
String stringa = "casa"; <br>
myMethod(casa); <br>
</code><br>
allora dentro il metodo myMethod() verrà utilizzata una copia della variabile e le modifiche effettuate allinterno di tale metodo non verranno viste dallesterno. Questo è ciò che formalmente accadrebbe sulla base della modalità di passaggio dei parametri per valore. In realtà le cose non stanno esattamente in questi termini. <br>
Infatti la copia di cui sopra non è esattamente quella della area di memoria che contiene la stringa casa, ma piuttosto del reference che punta a tale area di memoria (di fatto è come se in linguaggio C effettuassimo una copia del puntatore allarea di memoria ma non dellarea vera e propria). Dovrebbe essere piuttosto chiaro quindi che, utilizzando tale reference per modificare il contenuto della cella dallinterno del metodo, si otterrà una modifica visibile allesterno anche se abbiamo utilizzato una copia del reference (proprio per quanto mostrato nella figura 2.4). Quindi il risultato finale dipende dal tipo di modifica che si effettua con il reference: se infatti da dentro il metodo si scrivesse Str = "auto"; si otterrà solamente di deviare il puntatore copia a unaltra area di memoria lasciando inalterata quella che conteneva la stringa casa.<br> 
|
titolo£[Java]-I costruttori di Classe|
Linguaggio£Java|
lezione£
<b>I costruttori di classe </b><br>
Il costruttore di una classe è un particolare metodo che serve per creare una istanza della classe stessa. Linvocazione avviene per mezzo della keyword new, come ad esempio <code>String str = new String();</code> <br>
A differenza di altri linguaggi in Java non è possibile definire e quindi utilizzare il distruttore, anche se esiste un metodo particolare, detto <b>finalize</b>, che sarà esaminato più avanti. Per definire il costruttore della classe è necessario e sufficiente creare un metodo con lo stesso nome della classe. Ad esempio, se si ha una classe detta MyClass, il costruttore avrà questa forma // Costruttore di default public MyClass() {} // Un altro costruttore <code>public MyClass(String str) {}</code> Il primo dei due viene detto costruttore di default, dato che non prende nessun parametro. Normalmente il costruttore è definito pubblico, in modo che possa essere utilizzato per creare istanze di oggetti come ad esempio <br>
<br><code>MyClass mc = new MyClass(); </code><br>
<br>Non è sempre detto che sia così, dato che utilizzando particolari pattern di programmazione si possono definire costruttori privati e delegare il compito di creare le istanze ad apposite classi che per questo motivo a volte sono denominate factory (si veda [javapattern]). Ad esempio si potrebbe avere:<br>
<br>
<code> MyClass Mc = MyClassFactory.getMyClass(); <br>
</code><br>
<br>In Java ogni oggetto definito deve obbligatoriamente avere un costruttore; nel caso non lo si definisca esplicitamente, il compilatore, al momento della compilazione, ne inserisce uno vuoto che non riceve parametri in input (per questo motivo è detto di default) e che in questo caso non compie alcuna azione. Nel caso in cui si definisca un costruttore, allora il costruttore di default non verrà generato, e si avrà un errore in esecuzione nel tentativo di invocarlo. In Java non è possibile definire funzioni (compresi i costruttori) con valori default, come avviene ad esempio nel linguaggio C. Per esempio, una scrittura del genere <br>
<br><code>public myFunction(int valore=10) {}</code><br>
 <br>non è consentita, ma si può utilizzare una tecnica apposita, che in genere si adotta per i costruttori. Ad esempio è piuttosto frequente trovare situazioni come :<br>
<br>
<code>publi<br>c MyClass() <br>
{ this("stringa_di_default"); }</code><br>
<br>
 // Un altro costruttore public <code>MyClass(String str) {}</code> dove il costruttore di default non svolge nessuna operazione ma chiama semplicemente il costruttore con parametri passandogli un valore di default come parametro. Si noti in questo caso lutilizzo della keyword this, la quale è un reference interno alla classe stessa. Scrivendo this() di fatto si chiama un costruttore, ma è possibile fare riferimento a una qualsiasi proprietà o metodo della classe stessa scrivendo unespressione del tipo this.myMethod() <br>
Funzione analoga alla this è svolta dalla parola super che serve per fare riferimento alla classe padre rispetto a quella in uso. Da notare che, proprio a causa della mancanza dei puntatori, da una determinata classe non è possibile fare riferimento a quelle superiori appartenenti alla stessa scala gerarchica, fatta eccezione per il padre accessibile proprio grazie alla super. Da notare che, dallinterno di una classe, scrivere this.myMethod() oppure direttamente myMethod() è del tutto equivalente: il this in genere viene utilizzato per rendere il codice più elegante e comprensibile. In particolare risulta essere particolarmente utile, e in questo caso non solo per motivi estetici, quando un metodo è presente sia nella classe padre che in quella derivata, e si desidera di volta in volta specificare quale versione del metodo invocare. Un costruttore non può restituire nessun valore, dato che implicitamente restituisce un oggetto della classe stessa. Non è proibito dichiarare un metodo che abbia il nome della classe ma che ritorni un valore, come ad esempio // semplice metodo <br>
<br><code>public int MyClass() {}</code><br>
<br>che però viene visto come semplice metodo e non come costruttore di classe. <br>
Oltre che attraverso linvocazione del costruttore, in Java per creare un oggetto è possibile clonare larea di memoria per mezzo del metodo clone().Tale metodo, utilizzabile con ogni tipo di oggetto, essendo proprio della classe Object, effettua una copia fedele dellarea di memoria e quindi restituisce un clone identico a quello di partenza. Ad esempio <br>
<code>MyClass Mc2 = Mc1.clone();</code><br>
 <br>Da notare che in questo caso Mc1 e Mc2 sono due oggetti differenti anche se identici, e che per creare Mc2 non è stato invocato il costruttore della classe MyClass: ecco un altro esempio di creazione senza linvocazione diretta del costruttore tramite una new ma grazie ad un metodo factory. Si può dire che Mc2 prende vita quindi nel momento in cui viene invocato il metodo clone del reference Mc1, e quindi nasce in funzione dello stato in cui Mc1 si trova. <br>
<br>
<b>Polimorfismo e programmazione dinamica </b><br>
Java è un linguaggio fortemente tipato e per questo la gestione dellinterazione fra variabili (primitive e reference) differenti fra loro è di fondamentale importanza. Nella tabella 2.1 sono illustrati tipi primitivi e reference utilizzabili; fatta eccezione per alcune particolarità, si potrà notare come vi sia una notevole somiglianza con i corrispettivi tipi messi a disposizione dagli altri linguaggi. In Java i tipi disponibili sono quelli che si è abituati a trovare nei più importanti linguaggi procedurali e a oggetti. Per quanto riguarda i tipi primitivi, la regola fondamentale da seguire è piuttosto semplice e si basa sulla precisione dei tipi: è consentita infatti e senza nessuna forzatura esplicita, la conversione da un tipo a precisione minore verso uno a precisione maggiore. Ad esempio, supponendo di avere <br>
<br>
<code>int i = 10; <br>
long j = 10; </code><br>
è possibile scrivere senza incorrere in errori :<br>
<code>j = i;</code> <br>
<br>
mentre per effettuare la conversione opposta si deve forzare lassegnazione per mezzo di una operazione di cast:<br>
<br>
 <code>i = (int)j; </code><br>
<br>
Ovviamente in questo caso, se in j è memorizzato un valore che supera la dimensione massima supportata da i, allora si avranno risultati imprevedibili, dovuti al taglio dei bit in eccesso. Per quanto riguarda i reference si segue essenzialmente lo stesso principio, tenendo conto che lassegnazione, sia automatica che forzata, può avvenire solo fra tipi appartenenti alla stessa scala gerarchica. In questo caso infatti la precisione del numero di bit che una variabile può contenere non è di particolare rilievo. Supponendo che sia <br>
<br>
<code><br>
public class A {<br>
 int a1;<br>
 int a2; } </code><br>
<code><br>
<br>
public class B extends A{ <br>
int b1;<br>
int b2; } </code><br>
<br>
allora, in base al principio della ereditarietà, B implementerà tutte le caratteristiche di A (quindi possiede le variabili a1 e a2), aggiungendone eventualmente delle altre (b1 e b2). La classe B quindi possiede 4 variabili di classe, mentre la A solamente 2. Si tralasciano le considerazioni sui metodi, essendo del tutto analoghe. In tal senso il contenuto di una classe può essere visto come una estensione del concetto di precisione dei tipi primitivi. La conversione quindi può avvenire in maniera diretta da B ad A semplicemente eliminando le proprietà in eccesso; il contrario non è altrettanto automatico, dato che per passare da A a B non è possibile sapere come valorizzare quelle variabili presenti solo nella classe figlio. Quindi si può scrivere <br>
<br>
<code>A a = new A();<br>
B b = new B(); </code><br>
<br>
Questo tipo di cast viene detto implicito o upcast, dato che si risale nella gerarchia delle classi. Il downcast invece deve essere forzato e quindi si può scrivere <br>
<br>
<code>b =(B)a;</code><br>
<br>
 Si faccia attenzione comunque che, pur non ricevendo nessun errore in fase di compilazione, tentando di eseguire questa ultima riga, si riceve un messaggio di errore del tipo <i>RuntimeCastException</i>: il downcast è possibile infatti solo nel caso in cui b discenda da a, ovvero proprio lopposto del caso in esame .<br>
|
titolo£[Java]-Eccezioni|
Linguaggio£Java|
lezione£
<b>Gestione delle eccezioni </b><br>
Il concetto di eccezione, pur non essendo una prerogativa esclusiva di Java, ha avuto un nuovo impulso proprio grazie a questo linguaggio che ne fa uno dei suoi punti di forza. Si può addirittura dire che, senza il meccanismo di gestione delle eccezioni, buona parte della struttura di Java non avrebbe ragione di esistere. Si potrebbe definire sinteticamente il concetto di eccezione come unanomalia di funzionamento del programma che non può essere prevista in fase di scrittura del codice. Si può prendere ad esempio il caso in cui la connessione verso un database remoto venga chiusa per un qualche motivo, oppure il collegamento via socket verso una applicazione server-side non sia più disponibile per motivi non prevedibili o non dipendenti dalla correttezza del codice dellapplicazione. Spesso fonte di problemi è data dagli effetti derivanti dalla contestualizzazione delle variabili (effettuare una divisione potrebbe essere impossibile se il divisore è nullo), ed anche la presenza di situazioni dinamiche, polimorfiche può portare alla non predicibilità del flusso delle operazioni. Una eccezione quindi non è un errore di programmazione, situazione questa ben più grave, ma un evento non previsto e non dipendente dalla volontà del programmatore<br> 
<br>
<b>Cosa sono le eccezioni e come si gestiscono</b> <br>
La leggenda narra che i progettisti che allepoca definirono tutta la struttura del linguaggio fossero appassionati di uno degli sport più popolari negli USA, il baseball, ed è per tale ragione che nellambito della gestione delle eccezioni si trovano termini tipici di tale sport, come lanciare (throw) o catturare (catch) una eccezione. La struttura sintattica di base è un qualcosa del tipo <br>
<code><br>
try { ... // porzione di codice che potrebbe dare dei problemi ... } <br>
catch(Exception1 e) <br>
	{ ... // gestione delleventuale problema nato nel blocco try ... } <br>
catch(Exception2 e) <br>
	{ ... // gestione delleventuale problema nato nel blocco try ... }<br>
 finally <br>
	{ ... // codice da eseguire sempre } <br>
</code><br>
Questa organizzazione del codice permette di eseguire quella porzione di codice in cui si potrebbero verificare delle situazioni incongruenti in una zona protetta (allinterno del blocco try) e di gestire le eccezioni che si potrebbero verificare (blocco catch). Grazie a tale organizzazione, in concomitanza del verificarsi di una eccezione, evento che normalmente può portare al blocco irrimediabile della applicazione, il controllo viene passato al costrutto catch dove si possono implementare soluzioni di gestione di tale anomalia (dal settare le variabili con valori opportuni a un semplice messaggio di avvertimento per lutente). Il blocco catch potrebbe essere anche vuoto, ma è necessario che sia presente. Infine si può pensare di inserire il blocco finally per eseguire tutte quelle istruzioni che debbano essere effettuate comunque. <br>Si tenga presente che la catch è in grado di gestire solo il tipo di eccezione per la quale è definita (ovvero quella del tipo specificato fra parentesi). Quando una catch corrisponde alleccezione verificatasi, il controllo passa alla parte di codice in essa contenuta e non prosegue nelle seguenti, passando eventualmente al blocco finally. Il grosso vantaggio derivante dalla organizzazione ad Object Oriented di Java, è che anche le eccezioni sono oggetti, e che sono organizzate in maniera gerarchica.<br>
Quando si genererà un errore di I/O quindi verrà prodotta dal runtime una IOException, e tale eccezione potrà essere intrappolata con una istruzione del tipo <br>
<br>
<code><br>
catch(IOException IO e) <br>
ma anche con una <br>
catch(Exception e) <br>
</code><br>
<br>
dato che una IOException è anche una Exception. Ovviamente non è vero il contrario.<br>
 In Java si hanno due tipi di eccezioni, le <b>checked </b>e le<b> unchecked</b>: la differenza principale è che le seconde non devono essere obbligatoriamente controllate, cosa che invece è necessaria per le eccezioni di tipo checked. <br>
sia la classe Error che la Exception derivano dalla più generica Throwable, la quale ha lo scopo di permettere a un qualsiasi oggetto che la dichiari come classe padre di generare eccezioni. In ogni caso tutto quello che sta sotto Error è di fatto unchecked, e quindi non obbligatorio da controllare. Dato che una eccezione non gestita può portare nei casi peggiori a crash dellapplicazione, linsorgere di un errore piuttosto che di una eccezione deve essere considerata una situazione più grave.<br>
|
titolo£[Java]-Ereditarietà|
Linguaggio£Java|
lezione£
<b>Ereditarietà multipla</b><br>
 Come noto Java non supporta lereditarietà multipla fra classi. Una classe può però implementare più interfacce e in questo modo è possibile definire per essa diversi comportamenti. Si riconsideri ora lesempio precedente aggiungendo il supporto alla persistenza.<br> 
Linterfaccia <b>Persistent</b> è ciò che serve per questo scopo <br>
<code><br>
public interface Persistent { <br>
public void save();<br>
 }<br>
</code><br>
 Le classi viste in precedenza diventano quindi <br>
 <code><br>
public class Book implements PricedItem, Persistent { <br>
... } <br>
public class CD implements PricedItem, Persistent {<br>
 ... <br>
} <br>
</code><br>
Quindi si può scrivere il codice di gestione del salvataggio nel seguente modo <br>
<code><br>
public void saveAll(Collection items) { <br>
Iterator it = items.iterator(); <br>
Persistent item; <br>
while (it.hasNext()) { <br>
item = (Persistent)it.next(); <br>
item.save(); } <br>
} <br>
</code><br>
Si osservi che linterfaccia Persistent nasconde completamente i dettagli di salvataggio che potrebbe avvenire su file oppure su DB attraverso JDBC.<br> 
<br>
<b>Composizione </b><br>
La programmazione OO permette di riutilizzare funzionalità esistenti principalmente attraverso ereditarietà fra classi e composizione di oggetti. La composizione permette di ottenere sistemi più flessibili mentre lereditarietà dovrebbe essere utilizzata principalmente per modellare relazioni costanti nel tempo. Non si pensi però di poter ottenere il polimorfismo solo con lereditarietà: lutilizzo combinato di interfacce e composizione permette di progettare soluzioni molto interessanti dal punto di vista architetturale. Si supponga infatti di dover sviluppare il supporto alla validazione per le classi Book viste prima. Le logiche di validazione saranno incorporate allinterno di unopportuna classe che implementa uninterfaccia <b>Validator</b> <br>
<code><br>
public interface Validator { <br>
public void validate(Object o);<br>
 } <br>
</code><br>
<code><br>
public class BookValidator implements Validator { <br>
public void validate(Object o) {<br>
 if (o instanceof Book) { ... } <br>
} </code><br>
} 
|
titolo£[Java]-Processi e Multitasking|
Linguaggio£Java|
lezione£
Una delle potenti caratteristiche del linguaggio Java è il supporto per la programmazione concorrente o parallela. Tale feature permette di organizzare il codice di una stessa applicazione in modo che possano essere mandate in esecuzione contemporanea piů parti di codice differenti fra loro. Prima di descrivere questi aspetti del linguaggio saranno introdotti alcuni concetti fondamentali che aiuteranno ad avere unidea piů chiara dellargomento e delle problematiche correlate.<br>
<br>
<b>Processi e multitasking </b><br>
Tutti i moderni sistemi operativi offrono il supporto per il multitasking, ossia permettono lesecuzione simultanea di più processi. In un sistema Windows, Unix o Linux si può, ad esempio, scrivere una e-mail o un documento di testo mentre si effettua il download di un file da Internet. In apparenza questi diversi programmi vengono eseguiti contemporaneamente, anche se il computer è dotato di un solo processore. In realtŕ i processori dei calcolatori su cui si è abituati a lavorare analizzano il flusso delle istruzioni in maniera sequenziale in modo che in ogni istante una sola istruzione sia presa in esame ed eseguita (questo almeno in linea di massima, dato che esistono architetture particolari che permettono il parallelismo a livello di microistruzioni).<br>  
Ma anche se, per sua natura, un computer è una macchina sequenziale, grazie a una gestione ciclica delle risorse condivise (prima fra tutte il processore centrale), si ottiene una specie di parallelismo, che permette di simulare lesecuzione contemporanea di più programmi nello stesso momento. Grazie alla elevata ottimizzazione degli algoritmi di gestione di questo pseudoparallelismo, e grazie alla possibilitŕ di un processo di effettuare certi compiti quando gli altri sono in pausa o non sprecano tempo di processore, si ha in effetti una simulazione del parallelismo fra processi, anche se le risorse condivise sono in numero limitato. Nel caso in cui si abbiano diversi processori operanti in parallelo, è possibile che il parallelismo sia reale, nel senso che un processore potrebbe eseguire un processo mentre un altro processore esegue un diverso processo, senza ripartizione del tempo: in generale non č possibile perň fare una simile assunzione, dato che normalmente il numero di processi in esecuzione č maggiore (o comunque puň esserlo) del numero di processori fisici disponibili, per cui č sempre necessario implementare un qualche meccanismo di condivisione delle risorse. <br>
Vi sono due tipi di multitasking: il cooperative multitasking la cui gestione č affidata agli stessi processi, che mantengono il controllo del processore fino a che non lo rilasciano esplicitamente. Si tratta di una tecnica abbastanza rudimentale in cui il funzionamento dipende dalla bontŕ dal codice del programma, quindi in sostanza dal programmatore. Cè sempre la possibilità che un programma scritto in modo inadeguato monopolizzi le risorse impedendo il reale funzionamento multitasking. Esempi di sistemi che usano questo tipo di multitasking sono Microsoft Windows 3.x e alcune versioni del MacOS; il preemptive multitasking č invece gestito interamente dal sistema operativo con il sistema del time-slicing (detto anche time-sharing), assegnando ad ogni processo un intervallo di tempo predefinito, ed effettuando il cambio di contesto anche senza che il processo intervenga o ne sia a conoscenza. Il processo ha sempre la possibilitŕ di rilasciare volontariamente le risorse, ma questo non č necessario per il funzionamento del sistema. Il sistema operativo in questo caso utilizza una serie di meccanismi per il controllo e la gestione del tempo del processore, in modo da tener conto di una serie di parametri, legati al tempo trascorso e allimportanza (priorità) di un determinato processo. <br>
Si č detto che per simulare il parallelismo fra processi differenti si effettua una spartizione del tempo trascorso in esecuzione nel processore. Il meccanismo di simulazione si basa sul cambio di contesto (context-switch) fra processi diversi: in ogni istante un solo processo viene messo in esecuzione, mentre gli altri restano in attesa. Il contesto di un processo P1 è linsieme delle informazioni necessarie per ristabilire esattamente lo stato in cui si trova il sistema al momento in cui interrompe lesecuzione del processo P1 per passare a un altro processo P2. Tra queste informazioni di contesto le principali sono lo stato dei registri del processore, e la memoria del processo, che a sua volta contiene il testo del programma, ossia la sequenza di istruzioni, i dati gestiti dal processo e lo stack (spazio di memoria per le chiamate di funzioni e le variabili locali). Infatti, un aspetto fondamentale della gestione dei processi è il fatto che ogni processo ha un suo spazio di memoria privato, a cui esso soltanto puň accedere. Quindi, salvo casi eccezionali (memoria condivisa) un processo non ha accesso alla memoria gestita da un altro processo. I processi sono normalmente organizzati secondo una struttura gerarchica in cui, a partire da un primo processo iniziale creato alla partenza del sistema operativo, ogni successivo processo č figlio di un altro processo che lo crea e che ne diviene il padre. <br>
Nei sistemi preemptive vi è poi un processo particolare che gestisce tutti gli altri processi, lo scheduler, responsabile della corretta distribuzione del tempo della CPU tra i processi in esecuzione. A tale scopo esistono diversi algoritmi di scheduling, che comunque generalmente si basano sul tempo di attesa (maggiore è il tempo trascorso dallultima esecuzione, maggiore è la priorità del processo) e su livelli di prioritŕ intrinseci assegnati dal sistema sulla base della natura del processo, oppure dallutente sulla base delle sue esigenze particolari. A prescindere da questo normale avvicendamento di esecuzione, i processi possono subire delle interruzioni (interrupt) dovute al verificarsi di eventi particolari, originati dallhardware come linput di una periferica (interrupt hardware), dal software (interrupt software) oppure da errori di esecuzione che causano le cosiddette eccezioni. In questi casi viene effettuato un context-switch come nel normale scheduling, viene eseguito del codice specifico che gestisce linterruzione, dopodiché si torna al processo interrotto con un altro context-switch. I processi, durante il loro ciclo di vita, assumono stati differenti, in conseguenza del loro funzionamento interno e dellattività dello scheduler. Semplificando al massimo, questi sono i principali stati che un processo puň assumere: <br>
 <b>in esecuzione</b>: il processo č attualmente in esecuzione;<br>
 <b>eseguibile</b>: il processo non č in esecuzione, ma č pronto per essere eseguito, appena la CPU si   rende disponibile; <br>
 <b>in attesa</b>: il processo č in attesa di un dato evento, come lo scadere di una frazione di tempo, la terminazione di un altro <br>processo, linvio di dati da un canale I/O. <br>
I processi normalmente sono entitŕ tra loro separate ed estranee ma, qualora risultasse opportuno, sono in grado di comunicare tra di loro utilizzando mezzi di comunicazione appositamente concepiti, genericamente identificati dalla sigla IPC (Inter Process Communication). Tra questi si possono citare la memoria condivisa (shared-memory), i pipe, i segnali, i messaggi, i socket. A seconda della tipologia di comunicazione tra processi, possono sorgere dei problemi derivanti dallacceso contemporaneo, diretto o indiretto, alle medesime risorse. Per evitare che questo dia origine a errori e incongruenze, generalmente le risorse vengono acquisite da un singolo processo con un lock, e rilasciate una volta che loperazione č terminata. Solo a quel punto la risorsa sarŕ disponibile per gli altri processi. Per gestire questo tipo di problemi di sincronizzazione esistono appositi meccanismi, tra cui il piů conosciuto č quello dei semafori. Per maggiori approfondimenti legati a questi argomenti si faccia riferimento alla bibliografia <br>
<br>
<b>Thread e multithreading </b><br>
Lesecuzione parallela e contemporanea di piů tasks (intendendo per task lesecuzione di un compito in particolare), risulta utile non solo nel caso di processi in esecuzione su un sistema operativo multitasking, ma anche allinterno di un singolo processo. Si pensi, ad esempio, a un editor di testo in cui il documento corrente viene automaticamente salvato su disco ogni n minuti. In questo caso il programma č composto da due flussi di esecuzione indipendenti tra loro: da un lato leditor che raccoglie i dati in input e li inserisce nel documento, dallaltra il meccanismo di salvataggio automatico che resta in attesa per la maggior parte del tempo e, a intervalli prestabiliti, esegue la sua azione. Sulla base di simili considerazioni č nata lesigenza di poter usare la programmazione concorrente allinterno di un singolo processo, e sono stati concepiti i thread, i quali in gran parte replicano il modello dei processi concorrenti, applicato perň nellambito di una singola applicazione. Un processo quindi non č piů un singolo flusso di esecuzione, ma un insieme di flussi: ogni processo contiene almeno un thread (thread principale) e puň dare origine ad altri thread generati a partire dal thread principale. Come per il multitasking, anche nel multithreading lo scheduling dei thread puň essere compiuto dal processo (dal thread principale), eventualmente appoggiandosi ai servizi offerti dal sistema operativo, se questo adotta il time-slicing; in alternativa puň essere affidato ai singoli thread, ed allora il programmatore deve fare attenzione a evitare che un singolo thread monopolizzi le risorse, rilasciandole periodicamente secondo criteri efficienti. La differenza fondamentale tra processi e thread sta nel fatto che i thread condividono lo stesso spazio di memoria, se si prescinde dallo stack, ossia dai dati temporanei e locali usati dalle funzioni. Questo porta diverse conseguenze: il cambio di contesto fra thread č molto meno pesante di quello tra processi, e quindi luso di thread diversi causa un dispendio di risorse inferiore rispetto a quello di processi diversi; inoltre la comunicazione fra thread č molto piů semplice da gestire, dato che si ha condivisione dello stesso spazio di memoria. Daltra parte, proprio questa condivisione rende molto piů rilevanti e frequenti i problemi di sincronizzazione, come si vedrŕ dettagliatamente in seguito. <br>
<br>
<b>Gioco di squadra: il metodo yield() </b><br>
Si è visto precedentemente, parlando dei processi, che esiste una forma di multitasking chiamato cooperativo, in cui ogni processo cede volontariamente il controllo del processore, dato che il sistema non gestisce lo scheduling dei processi. Si è anche detto che le specifiche della virtual machine non prevedono il time-slicing per cui, in presenza di thread di uguale prioritŕ non č garantito che un thread che non rilasci le risorse di sua iniziativa non resti in esecuzione indefinitamente, impedendo di fatto agli altri thread di funzionare. Per questi motivi, normalmente č buona norma non definire blocchi di istruzioni che possono richiedere molto tempo per essere eseguite ma, in alternativa, spezzare tali blocchi in entitŕ piů piccole. Lo scopo č quello di facilitare il compito dellalgoritmo di schedulazione in modo da evitare che un solo thread monopolizzi il processore per periodi troppo lunghi. Anche nel caso in cui il sistema si faccia carico di partizionare il tempo di esecuzione, spesso lo scheduler non č in grado di stabilire in maniera automatica dove e quando risulti piů opportuno interrompere un thread. <br>
Il metodo <b>yield()</b> permette di gestire in maniera ottimale queste situazioni: esso consente infatti di cedere luso del processore a un altro thread in attesa con il grosso vantaggio che, nel caso in cui nessuno sia in attesa di essere servito, permette il proseguimento delle operazioni del thread invocante senza un inutile e costoso cambio di contesto. Linvocazione di yield() non provoca un cambio di contesto (il thread rimane runnable), ma piuttosto viene spostato alla fine della coda dei thread della sua stessa prioritŕ. Ciň significa che questo metodo ha effetto solo nei confronti di altri thread di uguale prioritŕ, dato che i thread a prioritŕ inferiore non prendono il posto del thread corrente anche se questo usa il metodo yield(). Utilizzando yield č il programmatore che stabilisce come e dove č opportuno cedere il processore, indipendentemente da quello che č poi il corso storico dei vari thread. E' bene eseguire una chiamata a tale funzione in quei casi in cui si ritiene che il thread possa impegnare troppo a lungo il processore, in modo da facilitare la cooperazione fra thread, permettendo una migliore gestione delle risorse condivise.<br> 
<code><br>
private class CounterThread extends Thread { <br>int count = 0; <br>
public void run() { <br>
while (!terminated) {<br>
 count++; <br>
for (int i = 0; i < 1000; i++) { <br>
} <br>
} <br>
public void terminate() { <br>
terminated = true; <br>
} <br>
public int getCount() {<br>
 return count; } <br>
} <br>
</code><br>
<br>
<b>E lultimo chiuda la porta: il metodo join() </b><br>
Il metodo join resta semplicemente in attesa finché il thread per il quale č stato chiamato non termina la sua esecuzione. Con questo metodo č quindi possibile eseguire una determinata operazione nel momento in cui un thread termina la sua esecuzione. Risulta pertanto utile in tutti i casi in cui un thread compie delle operazioni che utilizzano dei risultati dellelaborazione di un altro thread. Di seguito č riportato un breve esempio nel quale č mostrato come utilizzare tale metodo. In esso si č utilizzata una versione modificata della classe CounterThread, in cui č possibile specificare, come parametro del costruttore, il massimo valore raggiungib<br>ile dal counter. In tal modo possiamo limitare la durata di esecuzione del thread senza dover ricorrere al metodo terminate(). 
<code><br>
private class CounterThread extends Thread { <br>
boolean terminated = false; <br>
int count = 0; <br>
int maxCount = Integer.MAX_VALUE; <br>
public CounterThread() { } <br>
public CounterThread(int maxCount) {<br>
 this.maxCount = maxCount; <br>
} <br>
public void run() { <br>
while (!terminated) {<br>
 count++; <br>
for (int i = 0; i < 1000; i++) { <br>
// fai qualcosa } <br>
} <br>
public void terminate() { <br>
terminated = true; }<br>
 public int getCount() { <br>
return count; } } <br>
</code><br>
<br><b>Interruzione di un thread </b><br>
Unaltra caratteristica che accomuna thread e processi, č quella di essere soggetti a interruzioni. Come si è visto, linterruzione è legata a un evento particolare, in qualche modo eccezionale, che determina cambiamenti tali nel contesto dellesecuzione da richiedere (o poter richiedere) una gestione particolare dellevento, ossia lesecuzione di un codice specifico che fa fronte allevento occorso. In un thread linterruzione ha luogo quando da un altro thread viene chiamato il metodo interrupt() per quel thread; formalmente č vero che un thread potrebbe interrompere se stesso, ma la cosa avrebbe poco senso. <br>Laspetto piů rilevante di questo metodo č che č in grado di interrompere uno stato di attesa causato da una chiamata a sleep() o join() (il discorso vale anche per il metodo wait() di cui si parlerŕ in seguito). Se si ripensa per un momento agli esempi precedenti in cui vengono usati questi metodi, si nota che le chiamate sono allinterno di un blocco try e che nel catch viene intercettata uneccezione del tipo InterruptedException anche se in questi casi leccezione non viene gestita. Questo č appunto leffetto di una chiamata al metodo interrupt(): se il thread interrotto č in stato di attesa, viene generata uneccezione del tipo InterruptedException e lo stato di attesa viene interrotto. <br>

|
titolo£[Java]-Input/Output|
Linguaggio£Java|
lezione£
<b>Input/Output </b><br>
Introduzione In questo capitolo verrà illustrato il package java.io, che supporta il sistema fondamentale di input/output (I/O) di Java. Nei programmi Java vengono spesso utilizzate istruzioni per stampare sullo schermo delle stringhe; utilizzare linterfaccia a caratteri, invece che quella grafica, risulta molto comodo sia per scrivere esempi semplici, che per stampare informazioni di debug. Del resto se si scrive unapplicazione che utilizza intensamente la grafica, è comunque possibile stampare informazioni in una finestra di testo. In effetti il supporto di Java per lI/O della console (testo) è un po limitato, e presenta qualche complessità di utilizzo, anche nei programmi più semplici. Comunque Java fornisce un ottimo supporto per lI/O per quanto riguarda i file e la rete, tramite un sistema stabile e coerente. Si tratta di un ottimo esempio di libreria orientata agli oggetti che permette di sfruttare a pieno le feature della programmazione object oriented. Una volta compresi i concetti fondamentali dellI/O di Java, è semplice sfruttare la parte restante del sistema I/O e, se si progettano le proprie classi tenendo presente la filosofia object oriented, si noterà come tali classi saranno riutilizzabili, ed indipendenti dal particolare mezzo di input/output. <br>
<br>
<b>Stream </b><br>
I programmi in Java comunicano (cioè effettuano lI/O) tramite gli stream (in italiano flussi). Uno stream è unastrazione ad alto livello che produce o consuma informazioni: rappresenta una connessione a un canale di comunicazione. Uno stream quindi è collegato a un dispositivo fisico dal sistema I/O di Java. Gli stream possono sia leggere da un canale di comunicazione che scrivere su tale canale: quindi si parla di stream di input, e stream di output. Gli stream si comportano in modo omogeneo, indipendentemente dal dispositivo fisico con cui sono collegati (da qui il concetto di astrazione ad alto livello). Infatti le stesse classi e gli stessi metodi di I/O possono essere applicati a qualunque dispositivo. Uno stream (astratto) di input può essere utilizzato per leggere da un file su disco, da tastiera, o dalla rete; allo stesso modo uno stream di output può fare riferimento alla console (e quindi scrivere sullo standard output), a un file (e quindi scrivere e aggiornare un file), o ancora ad una connessione di rete (e quindi spedire dei dati in rete). Un flusso quindi rappresenta unestremità di un canale di comunicazione a un senso solo. Le classi di stream forniscono metodi per leggere da un canale o per scrivere su un canale. Quindi un output stream scrive dei dati su un canale di comunicazione, mentre un input stream legge dati da un canale di comunicazione. Non esistono delle classi di stream che forniscano funzioni sia per leggere che per scrivere su un canale. Se si desidera sia leggere che scrivere su uno stesso canale di comunicazione si dovranno aprire due stream (uno di input ed uno di output) collegati allo stesso canale. Di solito un canale di comunicazione collega uno stream di output al corrispondente stream di input. Tutti i dati scritti sullo stream di output, potranno essere riletti (nello stesso ordine) dallo stream di input. Poiché, come si è già detto, gli stream sono indipendenti dal particolare canale di comunicazione, essi mettono a disposizione uno strumento semplice e uniforme per la comunicazione fra applicazioni. Due applicazioni che si trovano su due macchine diverse, ad esempio, potrebbero scambiarsi i dati tramite uno stream collegato alla rete, oppure unapplicazione può semplicemente comunicare con lutente utilizzando gli stream collegati alla console. Gli stream implementano una struttura FIFO (First In First Out), nel senso che il primo dato che sarà scritto su uno stream di output sarà il primo che verrà letto dal corrispondente stream di input. Fondamentalmente, quindi, gli stream mettono a disposizione un accesso sequenziale alle informazioni scambiate. Quando si parla di input/output, si parla anche del problema dellazione bloccante di una richiesta di input (il concetto di input/output tra laltro si ritrova anche nelle architetture dei processori). Ad esempio, se un thread cerca di leggere dei dati da uno stream di input che non contiene dati, verrà bloccato finché non saranno presenti dei dati disponibili per essere letti. In effetti, quando un thread cerca di leggere dei caratteri immessi da un utente da tastiera, rimarrà in attesa finché lutente non inizierà a digitare qualcosa. Il problema dellazione bloccante è valido anche per le operazioni di output: se si cerca di scrivere qualcosa in rete, si rimarrà bloccati finché loperazione non sarà terminata. Questo può avvenire anche quando si scrive su un file su disco, ma le operazioni in rete di solito sono le più lente. Il thread bloccato sarà risvegliato solo quando sarà stata completata loperazione bloccante. Se si vuole evitare di essere bloccati da queste operazioni si dovrà utilizzare il multithreading; si vedranno degli esempi nel capitolo che riguarda il networking. <br>
<br>
<b>Le classi </b><br>
Le classi degli stream sono contenute nel pacchetto java.io, che dovrà quindi essere incluso nei programmi che ne fanno uso. Tutti gli stream fanno parte di una gerarchia. In realtà si hanno due sottogerarchie: una per gli stream di output ed una per quella di input. In cima a questa gerarchia ci sono due classi astratte i cui nomi sono abbastanza ovvi: InputStream e OutputStream. Trattandosi di classi astratte, non si potranno istanziare direttamente oggetti appartenenti a queste classi. Comunque si possono dichiarare delle variabili appartenenti a queste classi e a queste si potrà assegnare qualsiasi oggetto appartenente ad una classe derivata; in questo modo si potrà utilizzare a pieno il polimorfismo, rendendo le proprie classi indipendenti dal particolare stream (e quindi anche dal particolare canale di comunicazione). Java ovviamente mette a disposizione diverse sottoclassi che specializzano gli stream per i diversi dispositivi e canali di comunicazione, ma vediamo prima i metodi messi a disposizione da queste due classi base. <br>
<br>
<b>La classe OutputStream </b><br>
La classe OutputStream rappresenta una porta verso un canale di comunicazione; tramite questa porta si possono scrivere dati sul canale con il quale la porta è collegata. Si ricorda che si tratta di una classe astratta, che quindi fornisce uninterfaccia coi metodi caratteristici di ogni stream di output. Saranno le sottoclassi a fornire unimplementazione effettiva di tali metodi, che ovviamente dipenderà dal particolare canale di comunicazione. Descrizione classe <br>
<code>public abstract class OutputStream extends Object </code><br>
Trattandosi di una classe astratta, non sono presenti costruttori utilizzabili direttamente. <br>
<br>
<b>Metodi </b><br>
<code>public abstract void write(int b) throws IOException </code><br>
Viene accettato un singolo byte, che verrà scritto sul canale di comunicazione con il quale lo stream è collegato. Notare che, nonostante largomento sia di tipo intero, verrà scritto solo il byte meno significativo. Ovviamente si tratta di un metodo astratto, in quanto la scrittura dipende fortemente dal particolare dispositivo fisico del canale di comunicazione. <br>
<br><code>public void write(byte b[], int off, int len) throws IOException <br>
public void write(byte b[]) throws IOException </code><br>
<br>Questi metodi permettono di scrivere un array di byte sul canale di comunicazione. <br>
<br>
<b>La classe InputStream </b><br>
La classe InputStream è la classe complementare della classe OutputStream, che fornisce funzionalità per linput, quindi per la lettura di dati da un canale di comunicazione. Quanto si è detto sui metodi astratti è valido anche per questa classe. <br>
<br> 
|
titolo£[Java]-File|
Linguaggio£Java|
lezione£
<b>I file </b><br>
Trattando linput/output non si può certo tralasciare largomento file. Java fornisce laccesso ai file tramite gli stream. In questo modo, per la genericità degli stream, unapplicazione progettata per leggere e/o scrivere utilizzando le classi InputStream e OutputStream, può utilizzare i file in modo trasparente. Java inoltre mette a disposizione altre classi per facilitare laccesso ai file e alle directory<br>
<br>
<b>Descrizione classe </b><br>
File public class File extends Object implements Serializable<br> 
La classe File fornisce laccesso a file e directory in modo indipendente dal sistema operativo. Tale classe mette a disposizione una serie di metodi per ottenere informazioni su un certo file e per modificarne gli attributi; tramite questi metodi, ad esempio, è possibile sapere se un certo file è presente in una certa directory, se è a sola lettura, e via dicendo. Si è parlato di indipendenza dal sistema operativo: effettivamente ogni sistema operativo utilizza convenzioni diverse per separare le varie directory in un path. Quando si specifica un file e/o un path, si suppone che vengano utilizzate le convenzioni del sistema operativo sottostante. I vari metodi che sono messi a disposizione dalla classe permettono di ottenere le informazioni relative a tali convenzioni. Inoltre è possibile cancellare file, rinominarli, e ottenere la lista dei file contenuti in una certa directory.<br>
<br>
 <b>Costruttori</b><br>
<br>
<code><br>
 public File(String path) <br>
public File(String path, String name)<br>
public File(File dir, String name)<br>
</code><br>
<br>
 È possibile creare un oggetto File specificando un path e anche un nome di file. Il path deve essere specificato utilizzando le convenzioni del sistema operativo sottostante. Se viene specificato anche il nome del file, oltre al percorso, verrà creato un path concatenando il percorso specificato ed il file con il separatore utilizzato dal sistema operativo. Con la terza versione è possibile specificare la directory del file tramite un altro oggetto File.<br> 
<br>
<b>Metodi </b><br>
Come già detto, tale classe è utile per avere un meccanismo in grado di utilizzare file e directory in modo indipendente dalle convenzioni del sistema operativo e per eseguire le classiche operazioni sui file e sulle directory. Tali metodi non lanciano unIOException, in caso di fallimento, ma restituiscono un valore booleano.<br>
<br>
<code> public String getName() <br>
public String getPath()</code> <br>
<br>
Restituiscono rispettivamente il nome e il percorso delloggetto File. <br>
<br>
<code><br>
public String getAbsolutePath() <br>
public String getCanonicalPath() throws IOException </code><br>
<br>
Restituiscono rispettivamente il percorso assoluto delloggetto File, e il percorso canonico. Questultimo è un percorso completo in cui eventuali riferimenti relativi e simbolici sono già stati valutati e risolti. Questultimo concetto ovviamente dipende fortemente dal sistema operativo. <br>public String getParent() <br>
Restituisce il nome della parent directory dell'oggetto File. <br>
Per un file si tratta del nome della directory. <br>
<br>
<code>public boolean exists()<br>
public boolean canWrite() <br>
public boolean canRead() </code><br>
<br>
Questi metodi permettono di capire se un file con il nome specificato esiste, se è scrivibile e se è leggibile.<br>
<br>
<code>public boolean isFile() <br>
public boolean isDirectory() <br>
public boolean isAbsolute()</code> <br>
<br>
Permettono di capire se loggetto File rappresenta un file, una directory o un percorso assoluto. public long lastModified() <br>
<br>
<code>public long length() </code><br>
Permettono di conoscere la data dellultima modifica del file, e la sua lunghezza in byte. public boolean renameTo(File dest) <br>
<br>
<code>public boolean delete() </code><br>
Permettono di rinominare e di cancellare un file.<br>
<br>
<code>public boolean mkdir() <br>
public boolean mkdirs()</code><br>
 Permette di creare una directory che corrisponde alloggetto File.<br>
La seconda versione crea se necessario tutte le directory del percorso delloggetto File. <br>
<code>public String[] list() <br>
public String[] list(FilenameFilter filter)</code><br>
Restituiscono lelenco di tutti i file della directory corrispondente alloggetto File. Nella seconda versione è possibile specificare un filtro. <br>
|
titolo£[Java]-Classi Reader e Writer|
Linguaggio£Java|
lezione£
<b>Classi Reader e Writer </b><br>
Dalla versione 1.1 del JDK, sono stati introdotti gli stream che gestiscono i caratteri (character stream). Tutti gli stream esaminati fino ad adesso gestiscono solo byte; i character stream sono come i byte stream, ma gestiscono caratteri Unicode a 16 bit, invece che byte (8 bit). Le classi base della gerarchia di questi stream sono Reader e Writer; tali classi supportano le stesse operazioni che erano presenti in InputStream e OutputStream, tranne che per il fatto che, laddove i byte stream operano su byte e su array di byte, i character stream operano su caratteri, array di caratteri, o stringhe. Il vantaggio degli stream di caratteri è che rendono i programmi indipendenti dalla particolare codifica dei caratteri del sistema su cui vengono eseguite le applicazioni (a tal proposito si veda anche il capitolo sullinternazionalizzazione). Java infatti per memorizzare le stringhe utilizza lUnicode; lUnicode è una codifica con la quale è possibile rappresentare la maggior parte dei caratteri delle varie lingue. I character stream quindi rendono trasparente la complessità di utilizzare le varie codifiche, mettendo a disposizione delle classi che automaticamente provvedono a eseguire la conversione fra gli stream di byte e gli stream di caratteri. La classe InputStreamReader, ad esempio, implementa un input stream di caratteri che legge i byte da un input stream di byte e li converte in caratteri. Allo stesso modo un OutputStreamWriter implementa un output stream di caratteri che converte i caratteri in byte e li scrive in un output stream di byte. Per creare un InputStreamReader basterà quindi eseguire la seguente operazione: InputStreamReader in = new InputStreamReader(System.in);
Inoltre gli stream di caratteri sono più efficienti dei corrispettivi stream di byte, in quanto, mentre questi ultimi eseguono spesso operazioni di lettura e scrittura un byte alla volta, i primi tendono a utilizzare di più la bufferizzazione. A tal proposito esistono anche le classi <br>
<code>BufferedReader e BufferedWriter, che corrispondo a BufferedInputStream e BufferedOutputStream;</code><br> si può quindi scrivere 
<code>BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); </code><br>
<br>
Le classi <b>PrintStream</b> e <b>PrintWriter</b> <br>
Della classe PrintStream si è già parlato allinizio del capitolo quando si sono introdotti gli stream predefiniti in, out ed err. Tale classe, nel JDK 1.1, è stata modificata in modo da utilizzare la codifica dei caratteri della piattaforma sottostante. Quindi in realtà ogni PrintStream incorpora un OutputStreamWriter e utilizza tale stream per gestire in modo adeguato i caratteri da stampare. Invece di rendere deprecated lintera classe PrintStream, sono stati resi deprecati i suoi costruttori. In questo modo tutti i programmi esistenti che, per stampare informazioni di debug o errori sullo schermo, utilizzano il metodo System.out.println o System.err.println potranno essere compilati senza ottenere warning. Si otterrà invece un warning se si costruisce esplicitamente un PrintStream. In questi casi si dovrebbe invece costruire un PrintWriter, a cui si può passare un OutputStream, e che provvederà automaticamente a utilizzare un OutputStreamWriter intermedio per codificare in modo corretto i caratteri da stampare. I metodi per stampare sono quelli di PrintStream e cioè print e println, in grado di gestire i vari tipi primitivi di Java.<br>
|
titolo£[Java]-Networking|
Linguaggio£Java|
lezione£
<b>Networking</b><br>
Si sente spesso affermare che Java è il linguaggio di programmazione per Internet. Effettivamente la maggior parte del grande successo e della diffusione di Java è dovuta a questo, vista soprattutto limportanza sempre maggiore che Internet sta assumendo. Java è quindi particolarmente adatto per sviluppare applicazioni che devono fare uso della rete. Ciò non deve indurre a pensare che con Java si scrivono principalmente solo Applet, per animare e rendere più carine e interattive le pagine web. Con Java si possono sviluppare vere e proprie applicazioni che devono girare in rete interagendo con più computer (le cosiddette applicazioni distribuite). Non si dimentichi che un altro fattore determinante per il suo successo è lindipendenza dalla piattaforma, ottenuta grazie allutilizzo del bytecode. Il linguaggio astrae da problemi di portabilità come il byte ordering, e quindi anche il programmatore non deve preoccuparsi dei classici problemi di interoperabilità cross-platform. A questo punto il programmatore di una applicazione network based non deve preoccuparsi di scrivere ex novo particolari librerie o funzioni per le operazioni di base, ma può dedicarsi totalmente ai dettegli veri e propri dellapplicazione. Inoltre ciò che rende Java un linguaggio adatto per il networking sono le classi definite nel pacchetto java.net che sarà analizzato in questo capitolo, in cui, oltre alla descrizione delle varie classi e dei rispettivi metodi, saranno forniti anche semplici esempi estendibili e funzionanti. <br>
<br>
<b>Socket</b><br>
 Le classi di networking incapsulano il paradigma socket presentato per la prima volta nella Berkeley Software Distribution (BSD) della University of California at Berkeley. Una socket è come una porta di comunicazione e non è molto diversa da una presa elettrica: tutto ciò che è in grado di comunicare tramite il protocollo standard TCP/IP può collegarsi ad una socket e comunicare tramite questa porta, allo stesso modo in cui un qualsiasi apparecchio che funziona a corrente può collegarsi a una presa elettrica e sfruttare la tensione messa a disposizione. Nella rete gestita dalle socket, invece dellelettricità, viaggiano pacchetti TCP/IP. Tale protocollo e le socket forniscono quindi unastrazione che permette di far comunicare dispositivi diversi che utilizzano lo stesso protocollo. Quando si parla di networking, ci si imbatte spesso nel termine client-server. Si tratta in realtà di un paradigma: unentità (spesso un programma) client per portare a termine un particolare compito richiede dei servizi ad unaltra entità (anche questa spesso è un programma): un server che ha a disposizione delle risorse da condividere. Una tale situazione si ritrova spesso nellutilizzo quotidiano dei computer (anche senza saperlo): un programma che vuole stampare qualcosa (client) richiede alla stampante (server) lutilizzo di tale risorsa. Il server è una risorsa costantemente disponibile, mentre il client è libero di scollegarsi dopo che è stato servito. Tramite le socket inoltre un server è in grado di servire più client contemporaneamente Come si è detto, tipicamente, sia il server che il client sono dei programmi che possono girare su macchine diverse collegate in rete. Il client deve conoscere lindirizzo del server e il particolare protocollo di comunicazione utilizzato dal server. Lindirizzo in questione è un classico indirizzo IP. Un client, quindi, per comunicare con un server usando il protocollo TCP/IP dovrà per prima cosa creare una socket con tale server, specificando lindirizzo IP della macchina su cui il server è in esecuzione e il numero di porta sulla quale il server è in ascolto. Il concetto di porta permette ad un singolo computer di servire più client contemporaneamente: su uno stesso computer possono essere in esecuzione server diversi, in ascolto su porte diverse. Se si vuole unanalogia si può pensare al fatto che più persone abitano nella medesima via, ma a numeri civici diversi. In questo caso i numeri civici rappresenterebbero le porte. Un server rimarrà in ascolto su una determinata porta finché un client non creerà una socket con la macchina del server, specificando quella porta. Una volta che il collegamento con il server, tramite la socket è avvenuto, il client può iniziare a comunicare con il server, sfruttando la socket creata. A collegamento avvenuto si instaura un protocollo di livello superiore che dipende da quel particolare server: il client deve utilizzare quel protocollo di comunicazione, per richiedere servizi al server. Il numero di porta è un intero compreso fra 1 e 65535. Il TCP/IP riserva le porte minori di 1024 a servizi standard. Ad esempio la porta 21 è riservata allFTP, la 23 al Telnet, la 25 alla posta elettronica, la 80 allHTTP (il protocollo delle pagine web), la 119 ai news server. Si deve tenere a mente che una porta in questo contesto non ha niente a che vedere con le porte di una macchina (porte seriali, parallele, ecc.), ma è unastrazione utile per smistare informazioni a più server in esecuzione su una stessa macchina. Si presentano adesso le classi messe a disposizione da Java nel pacchetto java.net per la gestione di comunicazioni in rete.<br>
|
titolo£[Python]-Introduzione|
linguaggio£Python|
lezione£
<b>Python</b> è un linguaggio di programmazione moderno, dalla sintassi semplice e potente che ne facilita l’apprendimento. Gli ambiti di applicazione di questo linguaggio di programmazione sono svariati: sviluppo di siti o applicazioni Web e desktop, realizzazione di interfacce grafiche, amministrazione di sistema, calcolo scientifico e numerico, database, giochi, grafica 3D, eccetera.<br>
L’obiettivo di questa guida è quello di fornire una panoramica generale sulla programmazione in Python, che permetta al lettore di sviluppare in modo facile e veloce le proprie applicazioni.<br>
<br><b>Python: i punti di forza</b><br>
<br>&ensp; -Python è completamente <b>gratuito</b> ed è possibile usarlo e distribuirlo senza restrizioni di copyright. Nonostante sia free, da oltre 25 anni Python ha una comunità molto attiva, e riceve costantemente miglioramenti che lo mantengono aggiornato e al passo coi tempi.<br>
<br>
&ensp; -Python è un <b>linguaggio multi-paradigma</b>, che supporta sia la programmazione procedurale (che fa uso delle funzioni), sia la programmazione ad oggetti (includendo funzionalità come l’ereditarietà singola e multipla, l’overloading degli operatori, e il duck typing). Inoltre supporta anche diversi elementi della programmazione funzionale (come iteratori e generatori).<br>
<br>
&ensp; -Python è un linguaggio <b>portabile</b> sviluppato in ANSI C. È possibile usarlo su diverse piattaforme come: Unix, Linux, Windows, DOS, Macintosh, Sistemi Real Time, OS/2, cellulari Android e iOS. Ciò è possibile perché si tratta di un linguaggio interpretato, quindi lo stesso codice può essere eseguito su qualsiasi piattaforma purché abbia l’interprete Python installato.<br>
<br>
&ensp; -Python è un linguaggio di alto livello che è al tempo stesso <b>semplice e potente</b>. La sintassi e i diversi moduli e funzioni che sono già inclusi nel linguaggio sono consistenti, intuitivi, e facili da imparare, e il design del linguaggio si basa sul principio del least astonishment (cioè della “minor sorpresa”: il comportamento del programma coincide con quanto ci si aspetta).<br>
<br>
&ensp; -Ogni installazione di Python include la <b>standard library</b>, cioè una collezione di oltre 200 moduli per svolgere i compiti più disparati, come ad esempio l’interazione con il sistema operativo e il filesystem, o la gestione di diversi protocolli. Inoltre, il Python Package Index consente di scaricare ed installare migliaia di moduli aggiuntivi creati e mantenuti dalla comunità.<br>
<br>
&ensp; -Anche se Python è considerato un linguaggio interpretato, i programmi vengono automaticamente compilati in un formato chiamato bytecode prima di essere eseguiti. Questo formato è più <b>compatto ed efficiente</b>, e garantisce quindi prestazione elevate. Inoltre, diverse strutture dati, funzioni, e moduli di Python sono implementati internamente in C per essere ancora più performanti.<br>
<br>
&ensp; -Python è un linguaggio di alto livello che adotta un meccanismo di garbage collection che si occupa automaticamente dell’allocazione e del rilascio della <b>memoria</b>. Questo consente al progammatore di usare variabili liberamente, senza doversi preoccupare di dichiararle e di allocare e rilasciare spazi di memoria manualmente (cosa che è invece necessaria in linguaggi di più basso livello come il C o il C++).<br>
<br>
&ensp; - all’interprete classico scritto in C (e chiamato CPython), esistono anche altri interpreti che consentono l’integrazione con diversi altri linguaggi. IronPython consente di utilizzare Python all’interno del framework .NET, di usarne le sue funzioni, e di interagire con altri linguaggi .NET. Per poter invece integrare Python e Java è possibile utilizzare Jython. Esistono poi altri interpreti, come PyPy: un’implementazione altamente performante scritta in Python.<br>
|
titolo£[Python]-print e input|
linguaggio£Python|
lezione£
<br>
In questa lezione facciamo la conoscenza di due funzioni basilari di Python: print e input. Queste funzioni servono rispettivamente a mostrare e a chiedere valori all’utente. Entrambe sono particolarmente utili durante la creazione dei primi test e programmi a riga di comando, ma lo saranno anche in futuro.<br>
<br><b>print</b><br>
<br>
Abbiamo già visto, nelle passate lezioni, la funzione print, che serve a “stampare” in output (tipicamente sullo schermo, ma volendo anche su file o altri stream) il valore di una variabile o di una espressione.<br>
<code><br>
>>> a = 12<br>
>>> b = 3<br>
>>> print(a, b, a-b)<br>
12 3 9<br>
>>><br>
>>> c = 'Hello'<br>
>>> print(c, 'World!')<br>
Hello World!<br>
</code><br>
Si può notare che la funzione print accetta in input un numero variabile di argomenti (anche di tipi diversi), li converte in stringhe, e li mostra in output separati da uno spazio e seguiti da un carattere di ritorno a capo <b>(\n)</b>. print consente inoltre di specificare il separatore, il carattere finale, lo stream, e altri parametri.<br>
<br>
Quando si lavora dall’interprete interattivo non è necessario utilizzare print per vedere il valore di una variabile o espressione, ma è sufficiente digitarla:<br>
<code><br>
>>> x = 10<br>
>>> x<br>
10<br>
>>> x * 2<br>
20<br>
</code><br>
Questa possibilità è disponibile solo dall’interprete interattivo; quando si esegue un programma, invece, è necessario utilizzare print esplicitamente.<br>
<br>
<b>input</b><br>
<br>
La funzione input viene usata per consentire all’utente di immettere dati da tastiera, che verranno poi utilizzati dal programma.<br>
<br>
input accetta un singolo argomento opzionale: una stringa che viene mostrata a video prima di leggere il valore digitato. Una volta che l’utente ha digitato un valore e premuto il tasto Invio, input restituisce il valore come stringa, come mostra il seguente esempio:<br>
<code><br>
>>> nome = input('Inserisci il tuo nome: ')<br>
Inserisci il tuo nome: Ezio<br>
>>> nome<br>
'Ezio'<br>
</code><br>
In questo esempio possiamo vedere che:<br>
<br>
    la stringa passata a input che chiede di inserire il nome viene mostrata a video;<br>
    input attende che l’utente digiti il nome (Ezio) e prema Invio;<br>
    input restituisce il nome inserito come stringa;<br>
    la stringa restituita da input viene assegnata alla variabile nome;<br>
    la variabile nome può poi essere utilizzata per accedere al nome inserito dall’utente.<br>
<br>
Se si desidera immettere valori numerici o di altri tipi, è possibile convertire la stringa restituita da input usando funzioni come int o float:<br>
<code><br>
>>> raggio = input('Inserisci il raggio: ')<br>
Inserisci il raggio: 8.4<br>
>>> r = float(raggio)<br>
>>> raggio, r<br>
('8.4', 8.4)<br>
>>> print('Area:', 3.14 * r**2)<br>
Area: 221.5584<br>
>>> print('Circonferenza:', 2 * 3.14 * r)<br>
Circonferenza: 52.752<br>
</code><br>
In questo esempio possiamo vedere che:<br>
<br>
	&ensp; 1)input chiede all’utente di inserire un raggio che viene assegnato alla variabile raggio;<br>
    &ensp; 2)la funzione float viene usata per convertire raggio (che è una stringa) in un valore numerico con la virgola che viene assegnato alla variabile r;<br>
    &ensp; 3)le due variabili (raggio e r) vengono stampate per mostrare che la prima è una stringa (quindi rappresentata tra '...') mentre la seconda è un numero;<br>
    &ensp; 4)r viene poi usata per calcolare l’area del cerchio (** è l’operatore di elevazione a potenza) e la funzione print viene usata per stampare la stringa 'Area:' e il risultato dell’espressione 3.14 * r**2;<br>
    &ensp; 5)r viene usata anche per calcolare la circonferenza e print per stampare la stringa 'Circonferenza:' e il risultato dell’espressione 2 * 3.14 * r;<br>
<br>
|
titolo£[Python]-Indentazione e Variabili|
linguaggio£Python|
lezione£
<b>Indentazione e blocchi di codice</b><br>
<br>
A differenza di altri linguaggi che delimitano blocchi di codice con parentesi grafe (come C, C++ e Java) o con parole riservate come begin/end, Python usa l’indentazione. Indentare il codice è una pratica comune in tutti i linguaggi, perché semplifica la lettura del codice e la compresione della sua struttura. Anzichè usare due meccanismi separati per compilatori/interpreti (parentesi o keyword) e persone (indentazione), per Python si è scelto di usare l’indentazione per entrambi. Questa scelta ha diversi aspetti positivi, tra cui:<br>
<br>
&ensp; -    il linguaggio risulta più chiaro e leggibile;<br>
&ensp; -    la struttura del programma coincide sempre con quella dell’indentazione;<br>
&ensp; -    lo stile di indentazione è necessariamente uniforme in qualsiasi listato.<br>
<br>
Questo significa che, in Python, l’indentazione è significativa, e che indentare in modo incorretto può portare a comportamenti sbagliati del programma o a errori.<br>
<br>
Vediamo un semplice esempio. Di seguito usiamo il costrutto if, che approfondiremo in una lezione successiva.<br>
<code><br>
print("eseguito sempre all'inizio")<br>
if condizione:<br>
    print('eseguito in mezzo solo se la condizione è vera')<br>
    print('eseguito in mezzo solo se la condizione è vera')<br>
    print('eseguito in mezzo solo se la condizione è vera')<br>
print('eseguito sempre alla fine')<br>
</code><br>
In questo esempio possiamo vedere che:<br>
<br>
    il primo print, l’if, e l’ultimo print hanno lo stesso livello di indentazione, e vengono eseguiti sempre;<br>
    dopo l’if c’è un blocco di codice con un livello di indentazione maggiore, che include tre print;<br>
    se la condizione dell’if è vera, i tre print vengono eseguiti;<br>
    se la condizione dell’if è falsa, i tre print non vengono eseguiti.<br>
<br>
È quindi molto importante fare attenzione all’indentazione, perché viene sempre valutata nel processo di parsing del programma. 
La PEP 8 include anche una sezione sull’indentazione, che suggerisce tra le altre cose di:<br>
<br>
    usare sempre 4 spazi per livello di indentazione;<br>
    evitare l’uso dei caratteri di tabulazione;<br>
    non mischiare mai l’uso di tabulazioni e spazi.<br>
<br>
Anche se la PEP 8 suggerisce di seguire queste convenzioni, è possibile (sebbene fortemente sconsigliato) usare tab o un numero diverso di spazi. Fintanto che i livelli di indentazione sono consistenti, il programma comunque funzionerà.<br>
<br>
<b>Le Variabili</b><br>
<br>
Per definire variabili in Python, è sufficiente utilizzare l’operatore di assegnamento (=) come nei seguenti esempi:<br>
<code>numero = 10<br>
stringa = "Python"<br>
lista = [1, 2, 3]<br>
</code><br>
<br>
Come si vede, in Python non è necessario né definire le variabili prima di utilizzarle, né specificare il loro tipo.<br>
<code># codice Python<br>
x = 10<br>
x = 20<br>
</code><br>
Anche se questo codice Python può sembrare molto simile, quello che accade è diverso:<br>
<br>
    l’oggetto 10 viene creato, e l’operazione di assegnamento fa in modo che la variabile x si riferisca a questo oggetto;<br>
    l’oggetto 20 viene creato, e la variabile/etichetta x viene “spostata” da 10 a 20;<br>
    siccome non ci sono più variabili che fanno riferimento all’oggetto 10, il garbage collector lo eliminirà automaticamente.<br>
<br>
In entrambi questi esempi, il valore finale associato con la variabile x sarà 20.<br>
<br>
Come abbiamo detto precedentemente, in Python le variabili non hanno tipo e possono riferirsi a qualsiasi tipo di oggetto. Il codice seguente è quindi perfettamente valido in Python:<br>
<code><br>
x = 10<br>
x = "Python"<br>
x = [1, 2, 3]<br>
</code><br>
In questo esempio la variabile/etichetta x viene “spostata” dall’intero 10 alla stringa "Python", e infine alla lista [1, 2, 3].<br>
<br>
<b>Nomi di variabili</b><br>
<br>
Ricordiamo che le regole da seguire nella scelta dei nomi delle variabili è simile a quella dei più comuni linguaggi di programmazione, in particolare:<br>
<br>
    ogni nome di variabile deve iniziare con una lettera o con il carattere underscore (_), e può essere seguita da lettere, numeri, o underscore;<br>
    esistono delle parole riservate (keyword) che non possono essere utilizzate come nomi di variabili: False, None, True, and, as, assert, break, class, continue, def, del, elif, else, except, finally, for, from, global, if, import, in, is, lambda, nonlocal, not, or, pass, raise, return, try, while, with, yield;<br>
    Python è un linguaggio case-sensitive, che distingue tra nomi di variabili composti da caratteri minuscoli e maiuscoli;<br>
 <br>
 <b>I commenti</b><br>
<br>
In Python è possibile usare il carattere # per aggiungere commenti al codice. Ogni riga di commento deve essere preceduta da un #, ed è anche possibile aggiungere commenti in seguito a istruzioni<br>
|
titolo£[Python]-Numeri e Operatori Logici|
linguaggio£Python|
lezione£
In Python ci sono 4 tipi di dati numerici: interi (int), razionali (float), complessi (complex), e booleani (bool).<br>
<br>
Abbiamo anche visto che è possibile usare l’interprete interattivo come una calcolatrice, e come convertire diversi tipi di dato. È inoltre possibile definire numeri interi usando la notazione binaria, ottale, ed esadecimale.<br>
<br>
<b>Operatori Aritmetici</b><br>
<br>
Le operazioni sui tipi numerici sono le più classiche:<br>
+ --> addizione;<br>
- --> sottrazione;<br>
/ --> divisione;<br>
// --> divisione intera;<br>
* --> moltiplicazione;<br>
% --> modulo;<br>
<br>
<b>Operatori di Confronto</b><br>
<br>
Python supporta anche operatori di confronto, che restituiscono True o False<br>
<br>
== --> uguale a;<br>
!= --> diverso da;<br>
< --> minore di;<br>
<= --> minore o uguale di ;<br>
> --> maggiore;<br>
>= --> maggiore o uguale di;<br>
<br>
<b>Operatori Booleani</b><br>
<br>
In Python esistono anche gli operatori booleani and, or, e not:<br>
Operatore	                                        Descrizione<br>
<b>and	  </b>                              Ritorna True se entrambi gli operandi sono veri, altrimenti False<br>
<b>or	</b>                                Ritorna True se almeno uno degli operandi è vero, altrimenti False<br>
<b>not	</b>                                Ritorna False se l’operando è vero, True se l’operando è falso<br>
<br>
<b>Operatori Binari</b><br>
<br>
Esistono poi gli operatori binari (o bitwise) che permettono di lavorare al livello dei singoli bit e sono utili in particolari circostanze<br>
<br>
Operatore	                                  Descrizione<br>
x << n					esegue uno shift a sinistra di n posizioni dei bit di x<br>
x >> n					esegue uno shift a destra di n posizioni dei bit di x<br>
x & y					esegue un and tra i bit di x e di y<br>
x or y					esegue un or tra i bit di x e di y<br>
x ^ y					esegue un or esclusivo tra i bit di x e di y<br>
~x						inverte i bit di x<br>
|
titolo£[Python]-Stringhe|
linguaggio£Python|
lezione£
n questa lezione ci occupiamo di come trattare le stringhe in Python. Abbiamo già visto che per dichiarare una stringa è sufficiente assengare ad una nuova variabile un testo racchiuso tra virgolette: è possibile racchiudere il suo valore indifferentemente tra apici (carattere ') o doppi apici (carattere ").<br>
<br>
Questo permette di superare facilmente il problema dell’utilizzo dei suddetti caratteri nel valore stesso della stringa, ad esempio "l'acqua" o 'Egli disse: "Acqua"'. È anche possibile usare il carattere di escape \ prima di ' o ": 'Egli disse: "L\'acqua"'.<br>
Le stringhe, così come le liste o le tuple, sono un tipo particolare di sequenze e perciò supportano tutte le operazioni comuni alle sequenze. Vediamone alcune.<br>
<br>
<b>Indexing e Slicing</b><br>
<br>
In Python, è possibile accedere agli elementi di una sequenza, usando la sintassi sequenza[indice]. Questo restituirà l’elemento in posizione indice (il primo elemento ha sempre indice 0). È inoltre possibile specificare indici negativi che partono dalla fine della sequenza (l’ultimo elemento ha indice -1, il penultimo -2, ecc.). Questa operazione è chiamata <b>indexing</b>.<br>
<code><br>
>>> s = 'Python'<br>
>>> s[0]  # elemento in posizione 0 (il primo)<br>
'P'<br>
>>> s[5]  # elemento in posizione 5 (il sesto)<br>
'n'<br>
>>> s[-1]  # elemento in posizione -1 (l'ultimo)<br>
'n'<br>
>>> s[-4]  # elemento in posizione -4 (il quartultimo)<br>
't'<br>
</code><br>
La sintassi sequenza[inizio:fine] ci permette di ottenere una nuova sequenza dello stesso tipo che include tutti gli elementi partendo dall’indice inizio (incluso) all’indice fine (escluso). Se inizio è omesso, gli elementi verranno presi dall’inizio, se fine è omesso, gli elementi verranno presi fino alla fine. Questa operazione è chiamata <b>slicing </b>(letteralmente “affettare”).<br>
<code><br>
>>> s = 'Python'<br>
>>> s[0:2]  # sottostringa con elementi da 0 (incluso) a 2 (escluso)<br>
'Py'<br>
>>> s[:2]   # dall'inizio all'elemento con indice 2 (escluso)<br>
'Py'<br>
>>> s[3:5]  # dall'elemento con indice 3 (incluso) a 5 (escluso)<br>
'ho'<br>
>>> s[4:]   # dall'elemento con indice 4 (incluso) alla fine<br>
'on'<br>
>>> s[-2:]  # dall'elemento con indice -2 (incluso) alla fine<br>
'on'<br>
</code><br>
<b>Contenimento</b><br>
<br> 
Gli operatori in e not in possono essere usati per verificare se un elemento fa parte di una sequenza o no. Nel caso delle stringhe, è anche possibile verificare se una sottostringa è contenuta in una stringa:<br>
<code><br>
>>> s = 'Python'<br>
>>> 'P' in s  # controlla se il carattere 'P' è contenuto nella stringa s<br>
True<br>
>>> 'x' in s  # il carattere 'x' non è in s, quindi ritorna False<br>
False<br>
>>> 'x' not in s  # "not in" esegue l'operazione inversa<br>
True<br>
>>> 'Py' in s  # controlla se la sottostringa 'Py' è contenuto nella stringa s<br>
True<br>
>>> 'py' in s  # il controllo è case-sensitive, quindi ritorna False<br>
False<br>
</code><br>
<br>
<b>Concatenamento, ripetizione e lunghezza</b><br>
<br>
È possibile usare l’operatore + per concatenare sequenze, e * per ripetere sequenze:<br>
<code><br>
>>> 'Py' + 'thon'<br>
'Python'<br>
>>> 'Py' * 2<br>
'PyPy'<br>
>>> 'Ba' + 'na' * 2<br>
'Banana'<br>
</code><br>
La funzione built-in len() può essere usata per ottenere il numero di elementi in una sequenza:<br>
<code><br>
>>> len('Python')<br>
6<br>
>>> s = 'Precipitevolissimevolmente'<br>
>>> len(s)<br>
26<br>
</code><br>
<br>
<b>Funzioni e Metodi</b><br>
<br>
Prima di procedere, è necessario <br>fare una breve parentesi per spiegare la differenza tra funzioni e metodi.<br>
<br>
Abbiamo già visto alcune funzioni come len(). La funzioni accettano 0 o più argomenti e possono essere usate con oggetti di diversi tipi, usando la sintassi funzione(argomenti):<br>
<code><br>
>>> len('Python')  # lunghezza di una stringa<br>
6<br>
>>> len(['PyPy', 'Jython', 'IronPython'])  # di una lista<br>
3<br>
>>> len({'a': 3, 'b': 5})  # di un dizionario<br>
2<br>
</code><br>
I metodi sono simili alle funzioni ma sono legati al tipo dell’oggetto e hanno una sintassi diversa: oggetto.metodo(argomenti). Così come le funzioni, i metodi possono accettare 0 o più argomenti:<br>
<code><br>
>>> s = 'Python'<br>
>>> s.upper()  # il metodo upper ritorna una nuova stringa tutta uppercase<br>
'PYTHON'<br>
>>> s.lower()  # il metodo lower ritorna una nuova stringa tutta lowercase<br>
'python'<br>
</code><br>
In questo esempio potete vedere due metodi forniti dal tipo str, che non sono disponibili per altri tipi.<br>
<br> 
|
titolo£[Python]-Tuple|
linguaggio£Python|
lezione£
<b>Tuple</b><br>
<br>
Python fornisce un tipo built-in chiamato tupla, che viene solitamente usato per rappresentare una sequenza immutabile di oggetti, in genere eterogenei.<br>
<br>
<b>Definire le tuple</b><br>
<br>
L’operatore che definisce le tuple è la virgola (,), anche se per evitare ambiguità la sequenze di elementi vengono spesso racchiuse tra parentesi tonde. In alcune espressioni, dove le virgole hanno già un significato diverso (ad esempio separare gli argomenti di una funzione), le parentesi sono necessarie.<br>
<code><br>
>>> t = 'abc', 123, 45.67  # la virgola crea la tupla<br>
>>> t  # la rappresentazione di una tupla include sempre le ()<br>
('abc', 123, 45.67)<br>
>>> type(t)<br>
<class 'tuple'><br>
>>> tp = ('abc', 123, 45.67)  # le () evitano ambiguità<br>
>>> t == tp  # il risultato è equivalente<br>
True<br>
>>> len((1, 'a', 2.3))  # in questo caso le () sono necessarie<br>
3<br>
>>> len(1, 'a', 2.3)  # perché qua la , separa gli argomenti<br>
Traceback (most recent call last):<br>
  File "<stdin>", line 1, in <module><br>
TypeError: len() takes exactly one argument (3 given)<br>
</code><br>
Per creare una tupla di un elemento, è comunque necessario l’uso della virgola, mentre per creare una tupla vuota bastano le parentesi tonde:<br>
<code><br>
>>> t = 'abc',  # tupla di un solo elemento<br>
>>> t<br>
('abc',)<br>
>>> tv = ()  # tupla vuota, senza elementi<br>
>>> tv<br>
()<br>
>>> type(tv)  # verifichiamo che sia una tupla<br>
<class 'tuple'><br>
>>> len(tv)  # verifichiamo che abbia 0 elementi<br>
0<br>
</code><br>
<b> le tuple</b><br>
<br>
Le tuple sono un tipo di sequenza (come le strighe), e supportano le operazioni comuni a tutte le sequenze, come indexing, slicing,<br> contenimento, concatenazione, e ripetizione:<br>
<code><br>
>>> t = ('abc', 123, 45.67)<br>
>>> t[0]  # le tuple supportano indexing<br>
'abc'<br>
>>> t[:2]  # slicing<br>
('abc', 123)<br>
>>> 123 in t  # gli operatori di contenimento "in" e "not in"<br>
True<br>
>>> t + ('xyz', 890)  # concatenazione (ritorna una nuova tupla)<br>
('abc', 123, 45.67, 'xyz', 890)<br>
>>> t * 2  # ripetizione (ritorna una nuova tupla)<br>
('abc', 123, 45.67, 'abc', 123, 45.67)<br>
</code><br>
Le tuple sono immutabili, quindi una volta create non è possibile aggiungere, rimuovere, o modificare gli elementi:<br>
<code><br>
>>> t[0] = 'xyz'  # non è possibile modificare gli elementi<br>
Traceback (most recent call last):<br>
  File "<stdin>", line 1, in <module><br>
TypeError: 'tuple' object does not support item assignment<br>
</code><br>
È anche possibile usare funzioni e metodi comuni a tutte le sequenze: <b>len()</b> per contare gli elementi, <b>min()</b> e <b>max()</b> per trovare l’elemento più piccolo/grande (a patto che i tipi degli elementi siano comparabili), .<b>index()</b> per trovare l’indice di un elemento, e .<b>count()</b> per contare quante volte un elemento è presente nella tupla.</b><br>
|
titolo£[Python]-Liste e Dizionari|
linguaggio£Python|
lezione£
Python fornisce anche un tipo built-in chiamato <b>lista</b>, che viene solitamente usato per rappresentare una sequenza mutabile di oggetti, in genere omogenei.<br>
<br>
<b>Definire le liste</b><br>
<br>
Le liste vengono definite elencando tra parentesi quadre ([]) una serie di oggetti separati da virgole (,). È possibile creare una lista vuota usando le parentesi quadre senza nessun elemento all’interno.<br>
<code><br>
>>> nums = [0, 1, 2, 3]  # nuova lista di 4 elementi<br>
>>> nums<br>
[0, 1, 2, 3]<br>
>>> type(nums)  # verifichiamo che il tipo sia "list"<br>
<class 'list'><br>
>>> empty = []  # nuova lista vuota<br>
>>> empty<br>
[]<br>
>>> one = ['Python']  # nuova lista con un elemento<br>
>>> one<br>
['Python']<br>
</code><br>
<br>
<b>Usare le liste</b><br>
Così come le tuple e le stringhe, anche le liste sono un tipo di sequenza, e supportano quindi le operazioni comuni a tutte le sequenze, come indexing, slicing, contenimento, concatenazione, e ripetizione:<br>
<code><br>
>>> letters = ['a', 'b', 'c', 'd', 'e']<br>
>>> letters[0]  # le liste supportano indexing<br>
'a'<br>
>>> letters[-1]<br>
'e'<br>
>>> letters[1:4]  # slicing<br>
['b', 'c', 'd']<br>
>>> 'a' in letters  # gli operatori di contenimento "in" e "not in"<br>
True<br>
>>> letters + ['f', 'g', 'h']  # concatenazione (ritorna una nuova lista)<br>
['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']<br>
>>> [1, 2, 3] * 3  # ripetizione (ritorna una nuova lista)<br>
[1, 2, 3, 1, 2, 3, 1, 2, 3]<br>
</code><br>
Le liste supportano anche funzioni e metodi comuni alle altre sequenze: len() per contare gli elementi, min() e max() per trovare l’elemento più piccolo/grande (a patto che i tipi degli elementi siano comparabili), .index() per trovare l’indice di un elemento, e .count() per contare quante volte un elemento è presente nella lista:<br>
<code><br>
>>> letters = ['a', 'b', 'c', 'b', 'a']<br>
>>> len(letters)  # numero di elementi<br>
5<br>
>>> min(letters)  # elemento più piccolo (alfabeticamente nel caso di stringhe)<br>
'a'<br>
>>> max(letters)  # elemento più grande<br>
'c'<br>
>>> letters.index('c')  # indice dell'elemento 'c'<br>
2<br>
>>> letters.count('c')  # numero di occorrenze di 'c'<br>
1<br>
>>> letters.count('b')  # numero di occorrenze di 'b'<br>
2<br>
</code><br>
A differenza di tuple e stringhe che sono immutabili, le liste possono essere mutate. È quindi possibile assegnare un nuovo valore agli elementi, rimuovere elementi usando la keyword del, o cambiare gli elementi usando uno dei metodi aggiuntivi delle liste:<br>
<br>
    lista.<b>append(elem)</b>: aggiunge elem alla fine della lista;<br>
    lista.<b>extend(seq)</b>: estende la lista aggiungendo alla fine gli elementi di seq;<br>
    lista.<b>insert(indice, elem)</b>: aggiunge elem alla lista in posizione indice;<br>
    lista.<b>pop()</b>: rimuove e restituisce l’ultimo elemento della lista;<br>
    lista.<b>remove(elem)</b>: trova e rimuove elem dalla lista;<br>
    lista.<b>sort()</b>: ordina gli elementi della lista dal più piccolo al più grande;<br>
    lista.<b>reverse()</b>: inverte l’ordine degli elementi della lista;<br>
    lista.<b>copy()</b>: crea e restituisce una copia della lista;<br>
    lista.<b>clear()</b>: rimuove tutti gli elementi della lista;<br>
<br>
<b> Differenza tra tuple e liste</b><br>
Dato che le tuple sono immutabili, la loro lunghezza è fissa, e in genere ogni elemento della tupla ha un ruolo preciso. Questi elementi, che possono essere di tipi diversi, in genere vengono letti tramite indexing (tupla[indice]).<br>
<br>
Le liste, invece, sono mutabili, quindi la loro lunghezza è variabile (elementi possono essere aggiunti o rimossi). Questo significa che gli elementi singoli non hanno un ruolo preciso e vengono in genere letti mediante iterazione (ad esempio usando un for), e perciò devono anche essere dello stesso tipo.<br>
<br>
<b> Dizionari</b><br>
I dizionari (dict) sono un tipo built-in, mutabile e non ordinato che contiene elementi (items) formati da una chiave (key) e un valore (value).<br> Una volta che il dizionario è creato e valorizzato con un insieme di coppie <chiave, valore>, si può usare la chiave (che deve essere univoca) per ottenere il valore corrispondente.<br>
<br>
I dizionari sono implementati usando delle tabelle hash che consentono di ottenere il valore corrispondente alla chiave in modo molto efficiente, indipendentemente dal numero di elementi nel dizionario. La maggior parte dei linguaggi contiene una struttura dati simile, anche se chiamata in modo diverso: il tipo hash in Perl, Hashtable in Java o C#, le mappe MFC per Visual C++, gli array associativi in PHP, eccetera.<br>
<code><br>
a': 1, 'b': 2, 'c': 3}  # nuovo dizionario di 3 elementi<br>
>>> d<br>
{'c': 3, 'a': 1, 'b': 2}<br>
</code><br>
In questo esempio possiamo vedere che d è un dizionario che contiene 3 elementi formati da una chiave e un valore. 'a', 'b' e 'c' sono le chiavi, mentre 1, 2 e 3 sono i valori. Possiamo anche notare come l’ordine degli elementi sia arbitrario, dato che i dizionari non sono ordinati.<br>
<code><br>
>>> d = {'a': 1}  # dizionario di un elemento<br>
>>> d<br>
{'a': 1}<br>
>>> type(d)  # verifichiamo che il tipo sia "dict"<br>
<class 'dict'><br>
>>> d = {}  # dizionario vuoto<br>
>>> d<br>
{}<br>
</code><br>
I dizionari supportano anche diversi metodi:<br>
<br>
<b>Metodo	Descrizione</b><br>
d.<b>items()</b>-->Restituisce gli elementi di d come un insieme di tuple<br>
d.<b>keys()</b>-->Restituisce le chiavi di d<br>
d.<b>values()</b>-->Restituisce i valori di d<br>
d.<b>get(chiave, default)</b>-->Restituisce il valore corrispondente a chiave se presente, altrimenti il valore di default (None se non specificato)<br>
d.<b>pop(chiave, default)</b>-->Rimuove e restituisce il valore corrispondente a chiave se presente, altrimenti il valore di default (dà KeyError se non specificato)<br>
d.<b>popitem()</b>-->Rimuove e restituisce un elemento arbitrario da d<br>
d.<b>update(d2)</b>-->Aggiunge gli elementi del dizionario d2 a quelli di d<br>
d.<b>copy()</b>-->Crea e restituisce una copia di d<br>
d.<b>clear()</>-->Rimuove tutti gli elementi di d<br>
<br>
<br>
|

titolo£[Python]-Conversione tra Tipi|
linguaggio£Python|
lezione£
Al contrario di altri linguaggi come il C, dove il tipo di dato è legato alla variabile che lo contiene, In Python il tipo è legato all’oggetto stesso e non può essere cambiato. Questo vuol dire che non è possibile convertire (cast) una variabile o un oggetto da un tipo ad un altro. Dato che il tipo di un oggetto non può essere cambiato, in Python la conversione non modifica l’oggetto originale, ma ne crea di nuovi a partire da oggetti già esistenti.<br>
<br>
Questa operazione può essere effettuata passando l’oggetto che vogliamo convertire al tipo in cui lo vogliamo convertire. Ad esempio, se vogliamo convertire una lista in un insieme possiamo usare set(lista):<br>
<code><br>
>>> mylist = [1, 2, 3, 2, 1]  # definisco una lista<br>
>>> myset = set(mylist)       # creo un nuovo insieme a partire dalla lista<br>
>>> myset                     # l'insieme contiene gli stessi elementi (senza duplicati)<br>
{1, 2, 3}<br>
>>> mylist                    # la lista originale esiste ancora<br>
[1, 2, 3, 2, 1]<br>
</code><br>
Se vogliamo, invece, convertire una stringa in numero, possiamo procedere come segue:<br>
<code><br>
>>> mystr = '3.14'            # definisco una stringa<br>
>>> myfloat = float(mystr)    # creo un nuovo float a partire dalla stringa<br>
>>> myfloat                   # il float corrisponde al numero della stringa<br>
3.14<br>
>>> mystr                     # la stringa originale esiste ancora<br>
'3.14'<br>
</code><br>
È anche possibile convertire una lista di tuple in un dizionario:<br>
<code><br>
>>> mylist = [('a', 1), ('b', 2), ('c', 3)]<br>
>>> mydict = dict(mylist)<br>
>>> mydict<br>
{'c': 3, 'a': 1, 'b': 2}<br>
</code><br>
Ogni tipo accetta diversi input, ma non tutte le conversioni sono possibili. Ad esempio, non è possibile convertire una lista in intero, o un intero in lista. Se passiamo un oggetto che non può essere convertito, Python restituirà un TypeError o un ValueError.
Altri tipi di dato<br>
<br>
Tutti i tipi elencati nella tabella all’inizio di questa lezione sono built-in, cioè sono sempre disponibili senza bisogno di importare nulla. In aggiunta a questi tipi di dato built-in, esistono anche diversi altri tipi non built-in che possono essere importati da moduli della standard library, tra cui:<br>
<br>
    il modulo <i>decimal</i> definisce un tipo Decimal che permette di lavorare con numeri a virgola mobile accuratamente, superando alcune limitazioni dei numeri float;<br>
    il modulo <i>fractions</i> definisce un tipo Fraction che consente di rappresentare e lavorare con numeri razionali usando le frazioni;
    il modulo <i>collections</i> definisce diversi tipi di contenitori, tra cui namedtuple (una tupla che consente l’accesso agli elementi per nome, invece che per posizione), OrderedDict (un dizionario che mantiene l’ordine di inserimento degli elementi), defaultdict (un dizionario che permette di specificare un valore di default), Counter (un dizionario che conta il numero di occorrenze di ogni elemento).<br>
<br>
Prima di poter utilizzare questi tipi è necessario importarli usando <code>import</code><br>
|
titolo£[Python]-Istruzioni condizionali|
linguaggio£Python|
lezione£
In questa lezione vedremo come implementare istruzioni condizionali in Python usando il costrutto if-elif-else. Le istruzioni condizionali vengono utilizzate quando vogliamo eseguire un blocco di codice solo nel caso in cui una condizione sia vera o falsa.<br>

<b>if-elif-else</b><br>
Il costrutto if-elif-else permette di eseguire istruzioni o gruppi di istruzioni diverse a seconda del verificarsi di una o più condizioni.<br>
<br>
La forma più semplice prevede l’uso di un if seguito da una condizione, dai due punti (:) e da un blocco di codice indentato che viene eseguito solo se la condizione è vera:<br>
<code>if condizione:<br>
    # gruppo di istruzioni eseguite<br>
    # se la condizione è vera<br>
</code><br>
Per esempio, per calcolare il valore assoluto di un numero, possiamo procedere così:<br>
<code>n = int(input('Inserisci un numero: '))<br>
if n < 0:   # se il numero è negativo<br>
    n = -n  # rendilo positivo<br>
print('Il valore assoluto è', n)<br>
</code><br>
In questo caso il blocco di codice indentato sotto l’if (cioè n = -n) è eseguito solo se il numero è negativo. Se il numero è invece positivo, il programma procede ad eseguire l’istruzione che segue l’if, cioè il print().<br>
<br>
Aggiungendo un else seguito dai due punti (:) possiamo anche specificare un blocco di codice eseguito quando la condizione dell’if è falsa:<br>
<code>if condizione:<br>
    # gruppo di istruzioni eseguite<br>
    # se la condizione è vera<br>
else:<br>
    # gruppo di istruzioni eseguite<br>
    # se la condizione è falsa<br>
</code><br>
In questo caso Python eseguirà il primo blocco se la condizione è vera, oppure il secondo blocco se la condizione è falsa. Ad esempio:
<code>n = int(input('Inserisci un numero: '))<br>
if n < 0:   # se il numero è negativo<br>
    print(n, 'è negativo')<br>
else:  # altrimenti (se non è negativo)<br>
    print(n, 'è positivo')<br>
</code><br>
In questo caso il programma eseguirà uno dei due print(): il primo se il numero inserito dall’utente è negativo, il secondo se invece è positivo.<br>
<br>
È infine possibile aggiungere 1 o più elif, ognuno seguito da una condizione, dai due punti (:) e da un blocco di codice indentato che viene eseguito solo se la condizione è vera. È anche possibile aggiungere un singolo else alla fine che viene eseguito se tutte le condizioni precedenti sono false<br>
|
titolo£[Python]-Cicli for e While|
linguaggio£Python|
lezione£
In Python esistono due tipi di cicli (anche detti loop):<br>
<br>
    il ciclo for: esegue un’iterazione per ogni elemento di un iterabile;<br>
    il ciclo while: itera fintanto che una condizione è vera.<br>
<br>
<b>Ciclo for</b><br>
<br>
Il ciclo for ci permette di iterare su tutti gli elementi di un iterabile ed eseguire un determinato blocco di codice. Un iterabile è un qualsiasi oggetto in grado di restituire tutti gli elementi uno dopo l’altro, come ad esempio liste, tuple, set, dizionari (restituiscono le chiavi), ecc.<br>
<br>
Vediamo un semplice esempio di ciclo for:<br>
<code><br>
>>> # stampa il quadrato di ogni numero di seq<br>
>>> seq = [1, 2, 3, 4, 5]<br>
>>> for n in seq:<br>
...     print('Il quadrato di', n, 'è', n**2)<br>
...<br>
Il quadrato di 1 è 1<br>
Il quadrato di 2 è 4<br>
Il quadrato di 3 è 9<br>
Il quadrato di 4 è 16<br>
Il quadrato di 5 è 25<br>
</code><br>
Possiamo notare che:<br>
<br>
    il ciclo for è introdotto dalla keyword for, seguita da una variabile, dalla keyword in, da un iterabile, e infine dai due punti (:);<br>
    dopo i due punti è presente un blocco di codice indentato (che può anche essere formato da più righe);<br>
    il ciclo for itera su tutti gli elementi della sequenza, li assegna alla variabile n, ed esegue il blocco di codice;<br>
    in questo esempio la variabile n assumerà i valori di 1, 2, 3, 4, e 5 e per ogni valore stamperà il quadrato;<br>
    una volta che il blocco di codice è stato eseguito per tutti i valori, il ciclo for termina.<br>
<br>
Il seguente esempio mostra come sia possibile usare un if all’interno di un ciclo for:<br>
<code><br>
>>> # determina se i numeri di seq sono pari o dispari<br>
>>> seq = [1, 2, 3, 4, 5]<br>
>>> for n in seq:<br>
...     print('Il numero', n, 'è', end=' ')<br>
...     if n%2 == 0:<br>
...         print('pari')<br>
...     else:<br>
...         print('dispari')<br>
...<br>
Il numero 1 è dispari<br>
Il numero 2 è pari<br>
Il numero 3 è dispari<br>
Il numero 4 è pari<br>
Il numero 5 è dispari<br>
</code><br>
Anche in questo caso il blocco di codice viene eseguito 5 volte, una per ogni valore della sequenza.<br>
<br>
Chi ha familiarità con altri linguaggi avrà notato che in Python il ciclo for non usa indici che vengono incrementati manualmente (come ad esempio avviene in C), ma è invece più simile a costrutti quali il foreach.<br>
<br>
<b>range</b><br>
Dato che spesso accade di voler lavorare su sequenze di numeri, Python fornisce una funzione built-in chiamata range che permette di specificare uno valore iniziale o start (incluso), un valore finale o stop (escluso), e uno step, e che ritorna una sequenza di numeri interi:<br>
<code><br>
>>> range(5)  # ritorna un oggetto range con start uguale a 0 e stop uguale a 5<br>
range(0, 5)<br>
>>> list(range(5))  # convertendolo in lista possiamo vedere i valori<br>
[0, 1, 2, 3, 4]<br>
>>> list(range(5, 10))  # con 2 argomenti si può specificare lo start e lo stop<br>
[5, 6, 7, 8, 9]<br>
>>> list(range(0, 10, 2))  # con 3 argomenti si può specificare anche lo step<br>
[0, 2, 4, 6, 8]<br>
</code><br>
Questa funzione è particolarmente utile se combinata con il ciclo for:<br>
<code><br>
>>> for n in range(1, 6):<br>
...     print('Il quadrato di', n, 'è', n**2)<br>
...<br>
Il quadrato di 1 è 1<br>
Il quadrato di 2 è 4<br>
Il quadrato di 3 è 9<br>
Il quadrato di 4 è 16<br>
Il quadrato di 5 è 25<br>
</code><br>
range può anche essere usato in combinazione con il ciclo for se vogliamo ripetere un blocco di codice un numero fisso di volte:<br>
<code><br>
>>> # stampa 'Python' 3 volte<br>
>>> for x in range(3):<br>
...     print('Python')<br>
...<br>
Python<br>
Python<br>
Python<br>
</code><br>
In questo caso si ottiene un comportamento più simile al for “tradizionale” (come quello di C) e la variabile x non è utilizzata.<br>
<br>
<b>Ciclo while</b><br>
<br>
Il ciclo while itera fintanto che una condizione è vera:<br>
<code><br>
>>> # rimuovi e printa numeri da seq finchè ne rimangono solo 3<br>
>>> seq = [10, 20, 30, 40, 50, 60]<br>
>>> while len(seq) > 3:<br>
...     print(seq.pop())<br>
...<br>
60<br>
50<br>
40<br>
>>> seq<br>
[10, 20, 30]<br>
</code><br>
Possiamo notare che:<br>
<br>
    il ciclo while è introdotto dalla keyword while, seguita da una condizione (len(seq) > 3) e dai due punti (:);<br>
    dopo i due punti è presente un blocco di codice indentato (che può anche essere formato da più righe);<br>
    il ciclo while esegue il blocco di codice fintanto che la condizione è vera;<br>
    in questo caso rimuove e stampa gli elementi di seq fintanto che in seq ci sono più di 3 elementi;<br>
    una volta che la sequenza è rimasta con solo 3 elementi, la condizione len(seq) > 3 diventa falsa e il ciclo termina.<br>
<br>
Alcuni altri linguaggi prevedono anche un costrutto chiamato do-while, che esegue almeno un’iterazione prima di verificare la condizione. In Python questo costrutto non esiste, ma ottenere un risultato equivalente è molto semplice:<br>
<code><br>
>>> # chiedi all'utente di inserire numeri finchè indovina<br>
>>> n = 8<br>
>>> while True:<br>
...     guess = int(input('Inserisci un numero da 1 a 10: '))<br>
...     if guess == n:<br>
...         print('Hai indovinato!')<br>
...         break  # numero indovinato, interrompi il ciclo<br>
...     else:<br>
...         print('Ritenta sarai più fortunato')<br>
...<br>
Inserisci un numero da 1 a 10: 3<br>
Ritenta sarai più fortunato<br>
Inserisci un numero da 1 a 10: 5<br>
Ritenta sarai più fortunato<br>
Inserisci un numero da 1 a 10: 8<br>
Hai indovinato!<br>
</code><br>
In questo esempio, il ciclo while viene usato per chiedere di inserire numeri finchè l’utente indovina il numero giusto (8). La condizione usata è semplicemente True, e siccome non può mai diventare falsa, si crea un ciclo infinito (endless loop). Il ciclo viene in realtà interrotto quando l’utente indovina il numero, usando un if e la keyword break.<br>
<br>
<b>break e continue</b><br>
Python prevede 2 costrutti che possono essere usati nei cicli for e while:<br>
<br>
    <b>break</b>: interrompe il ciclo;<br>
    <b>continue</b>: interrompe l’iterazione corrente e procede alla successiva.<br>
<br>
Ad esempio, possiamo usare un ciclo for per cercare un elemento in una lista e interrompere la ricerca appena l’elemento viene trovato<br>

|
titolo£[Assembly]-Introduzione|
linguaggio£Assembly|
lezione£<br>I sistemi di calcolo si basano su un certo numero di astrazioni che forniscono una visione più semplice del funzionamento della macchina, nascondendo dettagli dellimplementazione che possono essere, almeno in prima battuta, ignorati.<br>

Due delle più importanti astrazioni sono:<br>
La memoria, vista come un grosso array di byte.<br>
Linstruction set architecture (ISA), che definisce: <br>
1. lo stato della CPU;<br>
2. il formato delle sue istruzioni;<br>
3. leffetto che le istruzioni hanno sullo stato.<br>
<br>
Per tradurre codice di alto livello (ad esempio in linguaggio C) in codice macchina, i compilatori si basano sulla descrizione astratta della macchina data dalla sua ISA.<br>
<br>
Due delle ISA più diffuse sono: <br>
IA32, che descrive le architetture della famiglia di processori x86 a 32 bit;<br>
x86-64, che descrive le architetture della famiglia di processori x86 a 64 bit.<br>
<br>
Lx86-64 è ottenuto come estensione dellIA32, con cui è retrocompatibile. Le istruzioni IA32 sono infatti presenti anche nellx86-64, ma lx86-64 introduce nuove istruzioni non supportate dalIA32. Programmi scritti in linguaggio macchina per piattaforme IA32 possono essere eseguiti anche su piattaforme x86-64, ma in generale non vale il viceversa. In questa dispensa tratteremo lIA32.<br>
<br>
<br>
I tipi macchina permettono di rappresentare sia numeri interi che numeri in virgola mobile. Si noti che il tipo Extended precision richiede 12 byte in IA32. Tuttavia, di questi solo 10 byte (80 bit) sono effettivamente usati.<br>
<br>
Ogni tipo ha un corrispondente suffisso assembly che, come vedremo, viene usato per denotare il tipo degli operandi di una istruzione.<br>|
titolo£[Assembly]-Registri|<b>
linguaggio£Assembly|
lezione£

<b>Registri</b><br>
<br>
I registri sono delle memorie ad altissima velocità a bordo della CPU. In linguaggio assembly, sono identificati mediante dei nomi simbolici e possono essere usati in un programma come se fossero variabili.<br>
 LIA32 ha 8 registri interi (A, B, C, D, DI, SI, SP, BP) di dimensione 32 bit (4 byte), di cui i primi 6 possono essere usati come se fossero variabili per memorizzare interi e puntatori: I registri SP e BP hanno invece un uso particolare che vedremo in seguito. Nella descrizione, byte0 denota il byte meno significativo del registro e byte3 quello più significativo.<br> 
<br>
Si noti che è possibile accedere a singole parti di un registro utilizzando dei nomi simbolici. Ad esempio, per il registro A:<br>
%eax denota i 4 byte di A (byte3, byte2, byte1, byte0)<br>
%ax denota i due byte meno significativi di A (byte1 e byte0)<br>
%al denota il byte meno significativo di A (byte0)<br>
%ah denota il secondo byte meno significativo di A (byte1)<br>
Fanno eccezione i registri DI e SI, dove non si può accedere a un singolo byte.<br><br>
LIA32 ha anche altri registri:<br>
EIP: registro a 32 bit che contiene lindirizzo della prossima istruzione da eseguire (program counter)<br>
EFLAGS: registro a 32 bit che contiene informazioni sullo stato del processore<br>
altri registri per calcoli in virgola mobile e vettoriali che non trattiamo in questa dispensa
<b>Operandi e modi di indirizzamento della memoria</b><br>
Le istruzioni macchina hanno in genere uno o più operandi che definiscono i dati su cui operano. In generale, si ha un operando sorgente che specifica un valore di ingresso per loperazione e un operando destinazione che identifica dove deve essere immagazzinato il risultato delloperazione.<br>

Gli operandi sorgente possono essere di tre tipi:<br>
Immediato: operando immagazzinato insieme allistruzione stessa;<br>
Registro: operando memorizzato in uno degli 8 registri interi;<br>
Memoria: operando memorizzato in memoria.<br>
<br>
Gli operandi destinazione possono essere invece di soli due tipi:<br>
Registro: il risultato delloperazione viene memorizzato in uno degli 8 registri interi;<br>
Memoria: il risultato delloperazione viene memorizzato in memoria.<br>
<br>
Useremo la seguente notazione:<br>
Se E è il nome di un registro, R[E] denota il contenuto del registro E;<br>
Se x è un indirizzo di memoria, Mb[x] denota delloggetto di b byte allindirizzo x (omettiamo il pedice b quando la dimensione è irrilevante ai fini della descrizione).<br>
<br>
Si hanno le seguenti 11 possibili forme di operandi. Per gli operandi di tipo memoria, vi sono vari modi di indirizzamento che consentono di accedere alla memoria dopo averne calcolato un indirizzo. <br>
Negli indirizzamenti a memoria con indice scalato, il parametro s può assumere solo uno dei valori: 1, 2, 4, 8. Il parametro immediato imm è un valore intero costante a 32 bit, ad esempio -24 (decimale) oppure 0xAF25CB7E (esadecimale).<br>

Nel seguito, usiamo la notazione Sn per denotare un operando sorgente di n byte, e Dn per denotare un operando destinazione di n byte. Omettiamo il pedice quando la dimensione è irrilevante ai fini della descrizione.<br>
<br>
<b>Stessa dimensione sorgente e destinazione: MOV </b><br>
Una delle istruzioni più comuni è la MOV, dove sorgente e destinazione hanno la stessa dimensione.
Istruzioni:<br>
mov S, D  -->  copia byte da sorgente S a destinazione D<br>
movb S1,D1 -->  copia 1 byte<br>
movw S2,D2 -->  copia 2 byte<br>
movl S4,D4 -->  copia 4 byte<br>
<br>
<b>Dimensione destinazione maggiore di quella sorgente: MOVZ, MOVS </b>

Le istruzioni MOVZ, e MOVS servono per spostare dati da un operando sorgente a un operando destinazione di dimensione maggiore. Servono per effettuare le conversioni di tipi interi senza segno (MOVZ) e con segno (MOVS).<br>
MOVZ S,D-->copia byte da sorgente S a destinazione D, riempiendo con zero i byte che D ha in più rispetto a S<br>

MOVZBW S1,D2 -->  copia 1 byte in 2 byte, estendi con zero<br>
MOVZBW S1,D4 -->  copia 1 byte in 4 byte, estendi con zero<br>
MOVZBW S2,D4 -->  copia 2 byte in 4 byte, estendi con zero<br>

MOVS S,D -->  copia byte da sorgente S a destinazione D  riempiendo con il bit del segno (bit più significativo) di S i byte che D ha in più rispetto a S<br>|

titolo£[Assembly]-Istruzioni|
linguaggio£Assembly|
lezione£
<b> Movimento dati da/verso la stack: PUSH, POP </b><br>

Le istruzioni PUSH, e POP servono per spostare dati da un operando sorgente verso la cima della stack (PUSH) e dalla cima della stack verso un operando destinazione (POP):<br>

pushl S4 --> copia loperando di 4 byte S sulla cima della stack <br>
popl D4 --> togli i 4 byte dalla cima della stack e copiali nelloperando D <br>
<br>
<b>Istruzioni aritmetico-logiche</b><br>
<br>
Le seguenti istruzioni IA32 servono per effettuare operazioni su interi a 1, 2 e 4 byte:<br>
<br>
INC D -->  incrementa destinazione <br>
DEC D -->   decrementa destinazione <br>
NEG D -->   inverti segno destinazione <br>
NOT D -->  complementa a 1 destinazione <br>
ADD S,D -->  aggiungi sorgente a destinazione e risultato in destinazione <br>
SUB S,D -->  sottrai sorgente da destinazione e risultato in destinazione <br>
IMUL S,D -->  moltiplica sorgente con destinazione e risultato in destinazione, (la des deve essere un registro )<br>
XOR S,D -->  or esclusivo sorgente con destinazione e risultato in destinazione <br>
OR S,D -->  or sorgente con destinazione e risultato in destinazione <br>
AND S,D -->  and sorgente con destinazione e risultato in destinazione <br>
<br>
<b> Listruzione LEA (load effective address)</b><br>
<br>
Listruzione LEA consente di sfruttare la flessibilità data dai modi di indirizzamento a memoria per calcolare espressioni aritmetiche che coinvolgono somme e prodotti su indirizzi o interi.<br>
leal S, D4 --> Calcola lindirizzo effettivo specificato dalloperando di tipo memoria S e lo scrive in D<br>
<br>
Si noti che leal, diversamente da movl, non effettua un accesso a memoria sulloperando sorgente. Listruzione leal calcola infatti lindirizzo effettivo delloperando sorgente, senza però accedere in memoria a quellindirizzo.<br>
<br>
Listruzione leal viene usata per scrivere programmi più veloci e viene sfruttata tipicamente per due scopi:<br>
1. calcolare lindirizzo effettivo di un oggetto in memoria una sola volta, per poi usarlo più volte;<br>
2. calcolare espressioni aritmetiche su interi o puntatori usando una sola istruzione.<br>
Si noti infatti che, sebbene sia stata pensata per calcolare indirizzi di memoria, la leal può essere usata per calcolare espressioni intere che non rappresentano indirizzi. <br>|

titolo£[Assembly]-Istruzioni di Salto|
linguaggio£Assembly|
lezione£
<b>Istruzioni di salto</b><br>
<br>
Normalmente, il flusso del controllo di un programma procede in modo sequenziale, eseguendo le istruzioni nell’ordine in cui appaiono in memoria. Ogni volta che un’istruzione I viene eseguita, il registro EIP (instruction pointer), che punta alla prossima istruzione da eseguire, viene incrementato automaticamente del numero di byte occupati dall’istruzione I.<br> 
<br>
Vi sono tuttavia istruzioni, chiamate istruzioni di salto, che permettono di alterare il flusso del controllo, modificando il contenuto del registro EIP in modo che l’esecuzione non prosegua con istruzione successiva, ma con un’altra che inizia ad un indirizzo diverso.<br>
<br>
Vi sono tre tipi di istruzioni di salto:<br>
salti incondizionati: il registro EIP viene sovrascritto con l’indirizzo di memoria dell’istruzione a cui si vuole saltare;<br>
salti condizionati: il registro EIP viene sovrascritto con l’indirizzo di memoria dell’istruzione a cui si vuole saltare, ma solo se è verificata una determinata condizione sui dati;<br>
chiamata e ritorno da funzione (che vedremo in seguito).<br>
<br>
<br>
<b>Salti incondizionati: JMP</b><br>
Le istruzioni di salto incondizionato possono essere di tipo diretto o indiretto:<br>
<br>
<br>
jmp etichetta        R[%eip] ← indirizzo associato all’etichetta     salto diretto<br>
jmp *S               R[%eip] ← S                                     salto indiretto<br>
<br>
Esempio.<br>
<br>
Si consideri il seguente frammento di programma x86:<br>
<br><code>
   movl $0, %eax<br>
L: incl %eax
   jmp L<br></code>

<br>
Il programma esegue dapprima l’istruzione movl, poi incl. Quando incontra la jmp ritorna ad eseguire la incl. Infatti l’etichetta L (introdotta con la sintassi L:) denota l’indirizzo dell’istruzione incl. Si ha quindi un ciclo infinit<br>
<br>
Si consideri il seguente frammento di programma x86:<br>
<br><code>
jmp *(%eax)
</code><br>
Il programma salta all’indirizzo effettivo denotato dall’operando (%eax). L’operazione effettuata è quindi: %eip ← M[R[%eax]].<br>
<br>
<b> Salti condizionati e condition code: Jcc, CMP</b><br>
<br>
Le istruzioni di salto condizionato consentono di modificare il registro EIP, e quindi alterare il normale flusso sequenziale del controllo dell’esecuzione, solo se una determinata condizione è soddisfatta. Il test viene effettuato in base al contenuto di un registro particolare chiamato registro dei FLAG, che viene modificato come effetto collaterale dell’esecuzione della maggior parte delle istruzioni aritmetico-logiche. <br>

Un salto condizionato avviene in due passi:<br>
un’operazione aritmetico-logica effettua un’operazione sui dati<br>
in base all’esito dell’operazione, l’istruzione di salto condizionato salta o meno a un’etichetta<br>

Il registro dei FLAG contiene in particolare quattro codici di condizione (condition code) booleani:<br>
-ZF (zero flag): viene posto a 1 se l’ultima operazione aritmetico-logica ha prodotto un valore zero e 0 se ha prodotto un valore diverso da zero;<br>
-SF (sign flag): viene posto a 1 se l’ultima operazione aritmetico-logica ha prodotto un valore negativo e 0 se ha prodotto un valore non negativo;<br>
-CF (carry flag): viene posto a 1 se l’ultima operazione aritmetico-logica ha generato un riporto e 0 altrimenti;<br>
<br>
La forma generale di una instruzione di salto condizionato è la seguente:<br>
<br>
Istruzione                       Effetto                                                            Nota
Jcc etichetta  if (condizione) R[%eip] ← indirizzo associato all’etichetta   salto condizionato se la condizione associata al suffisso cc è 
                                                                            cc è verificata
<br>
<u>Esempio 1.</u><br>
<br>
Si consideri il seguente frammento di programma x86 e la sua corrispondente versione C in cui il registro eax è trattato come se fosse una variabile:<br>
<br>
Assembly x86                                          C<br>
decl %eax                                             eax--;<br>
jz L                                                  if (eax == 0) goto L;<br>
<br>
La prima operazione decrementa il contenuto del registro eax. Se eax diventa zero, allora l’istruzione jz salterà all’etichetta L.<br>
<br>
<u>Esempio 2.</u><br>
<br>
Si consideri il seguente frammento di programma x86 e la sua corrispondente versione C in cui i registri sono trattati come se fossero variabili:<br>
<br>
Assembly                                             C<br>
subl %ebx, %eax                                      temp = eax<br>
je L                                                 eax = eax - ebx<br>
                                                     if (temp == ebx) goto L<br>
<br>
La prima operazione calcola R[%eax]-R[%ebx] e scrive il risultato in R[%eax]. Si noti che il risultato della sottrazione è zero se e solo se i due registri sono uguali. Pertanto, l’istruzione je salterà all’etichetta L se e solo se i due registri sono uguali prima della SUB.<br>
<br>
Osserviamo che per effettuare un salto condizionato rispetto al contenuto di due registri abbiamo dovuto modificarne uno: infatti la SUB modifica l’operando destinazione. Per ovviare a questo problema il set IA32 prevede una istruzione di sottrazione che non modifica l’operando destinazione, pensata specificamente per essere usata nei confronti:<br>
<br>
Istruzione                    Effetto                                                       Nota
CMP S,D                    calcola D-S                      la differenza calcolata viene usata per modificare i condition code e poi va persa<br>
<br>
<b>Suffisso cc                       Significato</b><br>
e                                 D == S<br>
ne                                D != S<br>
g                                 D > S<br>
ge                                D>=S<br>
l                                 D < S<br>
le                                D <= S<br>
a                                 (unsigned)D > (unsigned)S<br>
ae                                (unsigned)D >= (unsigned)S<br>
b                                 (unsigned)D < (unsigned)S<br>
be                                (unsigned)D <= (unsigned)S<br>
<br>
<u>Esempio 3.</u><br>
<br>
Si consideri il seguente frammento di programma x86 e la sua corrispondente versione C in cui i registri sono trattati come se fossero variabili:<br>
<br>
cmpl %ebx, %eax                   if (eax <= ebx) goto L;<br>
jle L<br>
<br>
La prima operazione calcola la differenza R[%eax]-R[%ebx]. La seconda salta se R[%eax]-R[%ebx] <= 0.<br>|

titolo£[Assembly]-Chiamata e Ritorno da Funzione|
linguaggio£Assembly|
lezione£
<b>Chiamata e ritorno da funzione: CALL e RET</b><br>
<br>
Un ulteriore tipo di istruzione di salto è quello relativo alle chiamate e ritorno da funzione:<br>
<br>
<b>Istruzione                                           Effetto                                              Nota</b><br>
                                               R[%esp]←R[%esp]-4                   Chiamata a funzione: mette in stack l’indirizzo<br>
CALL S                                         M[R[%esp]]←R[%eip]                dell’istruzione successiva alla CALL (indirizzo di ritorno)<br>
                                               R[%eip]← S                              e salta all’indirizzo specificato dall’operando S<br>
                                               <br>
  <br>
                                               R[%eip]←M[R[%esp]]                     Ritorno da funzione: toglie dalla 
RET                                            R[%esp]←R[%esp]+4                     stack l’indirizzo di ritorno e lo scrive in EIP<br>
<br>
<br>
<br>
Esempio.<br>
<br>
Si consideri il seguente frammento di programma x86 e la sua corrispondente versione C in cui i registri sono trattati come se fossero variabili:<br>
<br>
Assembly:<br>
   call f<br>
   imull $3, %eax<br>
   …<br>
f: movl $2, %eax<br>
   ret<br>
<br>
C:<br>
f();<br>
eax = eax*3;<br>
…<br>
void f() {<br>
   eax = 2;<br>
}<br>
<br>
<br>
la CALL deposita in stack l’indirizzo dell’istruzione successiva, in modo che la RET possa proseguire da quella istruzione una volta terminata la chiamata della funzione.<br>|

titolo£[Assembly]-Istruzioni di Assegnamento|
linguaggio£Assembly|
lezione£

Istruzioni di assegnamento condizionato: CMOVcc<br>
L’istruzione CMOVcc consente di effettuare degli assegnamenti solo se una determinata condizione è verificata. L’istruzione si basa sulle medesime condizioni della Jcc, salvo che invece di saltare, copia l’operando sorgente in quello destinazione.<br>
<br>
<b>Istruzione                                 Effetto                                                            Nota</b><br>
CMOVcc S,D                          if (condizione) D←S                         se la condizione associata al suffisso cc è verificata, <br>
                                                                                               copia la sorgente nella destinazione<br>
<br>
L’istruzione semplifica alcune operazioni condizionali riducendo il numero di istruzioni richieste. Diversamente dalla MOV, l’operando sorgente di una CMOVcc non può essere un operando immediato, la destinazione deve essere un registro e solo operandi a 16 e 32 bit sono supportati.<br>
<br>
<u>Esempio.</u><br>
<br>
Si consideri il seguente frammento di programma x86 e la sua corrispondente versione C in cui i registri sono trattati come se fossero variabili:<br>
<br>
cmpl %ecx, %eax                                                     if (eax > ecx) ecx = eax;<br>
cmovgl %eax, %ecx<br>
<br>
<br>
La prima istruzione calcola R[%eax]-R[%ecx]. La seconda sovrascrive R[%ecx] con R[%eax] se R[%eax]>R[%ecx].<br>
<br>
<br>
<b>Altre istruzioni di confronto: TEST</b><br>
<br>
Nello stesso spirito della CMP, che corrisponde a una SUB in cui non viene modificato l’operando destinazione, l’istruzione TEST è identica a una AND, tranne che non modifica l’operando destinazione:<br>
<br>
Istruzione            Effetto                                                                  Nota<br>
TEST S,D            calcola S & D                    l’and bit a bit fra gli operandi calcolato viene usato per modificare i condition code e <br>
                                                                                 poi va perso<br>
<br>|
titolo£[Assembly]-Istruzioni condizionali|
linguaggio£Assembly|
lezione£
<b>Traduzione dei costrutti C in assembly IA32</b><br>
In questo paragrafo vediamo come i compilatori moderni come gcc traducono i costrutti del linguaggio C in codice IA32. Si noti come lo stesso programma C potrebbe essere tradotto in assembly in tanti modi diversi. Versioni diverse del compilatore oppure livelli di ottimizzazione diversi portano a codice assembly diverso. Per indicare la traduzione di un frammento di codice x in assembly IA32, useremo la notazione IA32(x).<br>
<b>Istruzioni condizionali</b><br>
Le istruzioni ed espressioni condizionali vengono normalmente basate sulle istruzioni di salto condizionato. In alcuni casi è possibile usare l’istruzione di movimento dati condizionale (CMOV).<br>
<b>Istruzione if</b><br>
Consideriamo lo schema generale di una istruzione if. Se il test effettuato è vero, viene eseguito il blocco e si riprende dall’istruzione successiva, altrimenti si prosegue direttamente con l’istruzione successiva. <br>
L’istruzione if può essere tradotta come segue:<br>
<br>
<br>
<i>C da tradurre:</i><br>
if (test) blocco<br>
<br>
istruzione C equivalente:</i><br>
   if (!test) goto L;<br>
   blocco;<br>
L: istruzione;<br>

<i> Assembly</i><br>
   IA32(test)<br>
   Jcc L<br>
   IA32(blocco)<br>
L: IA32(istruzione)<br>
<br></u><br>
<br>
Consideriamo il seguente frammento di programma C con variabili intere senza segno e assumiamo che la variabile a sia tenuta nel registro eax, b in ebx e c in ecx:<br>
<br>
C:<br>
if (a>b) c=10;<br>
c++;<br>
<br>
<br>
Assembly:<br>
 cmpl %ebx, %eax<br>
   jbe L<br>
   movl $10, %ecx<br>
L: incl %ecx<br>

Notiamo che il test a<=b su variabili senza segno viene realizzato calcolando la differenza R[%eax]-R[%ebx] con la CMP e saltando se il risultato è <=0 (suffisso be=below or equal, confronto senza segno).<br>
<br>
<b> Istruzione if…else</b><br>
Consideriamo lo schema generale di una istruzione if…else. Se il test effettuato è vero, viene eseguito il blocco 1 e si riprende dall’istruzione successiva all’if…else, altrimenti si esegue il blocco 2 e si riprende dall’istruzione successiva all’if…else. <br>
<br>
L’istruzione if..else può essere tradotta come segue:<br>
<br>
<i>C da tradurre:</i><br>
<code>if (test) blocco1<br>


else blocco2<br>
istruzione<br>
</code><br>
<br>
<i> C equivalente; </i><br>
<code>if (!test) goto E;<br>
   blocco1<br>
   goto F;<br>
E: blocco2<br>
F: istruzione;<br>
</code><br>
<br>
<i> Assembly</i><br>
<code>IA32(test)<br>
   Jcc E<br>
   IA32(blocco1)<br>
   jmp F<br>
E: IA32(blocco2)<br>
F: IA32(istruzione)<br>
</code><br>
<br>
Si noti che l’if…else viene realizzato effettuando un salto al blocco 2 che evita di eseguire il blocco 1 se il test non è soddisfatto. Alla fine del blocco 1 c’è un salto incondizionato che evita di eseguire il blocco 2 se il blocco 1 è stato eseguito. Questo realizza la mutua esclusione tra i blocchi eseguiti.<br>
|
titolo£[Assembly]-Cicli|
linguaggio£Assembly|
lezione£
<b>Cicli</b><br>
<b>Istruzione while</b><br>
Consideriamo lo schema generale di una istruzione while. Se il test effettuato è vero, viene eseguito il blocco e si ritorna al test, altrimenti si prosegue con l’istruzione successiva al while. <br>
<br>
L’istruzione while può essere tradotta come segue:<br>
<i> C da tradurre: </i><br>
<code>while (test) blocco<br>
<br>
<br>
istruzione<br>
</code><br>
<i> C equivalente: </i><br>
<code>L: <br>
   if (!test) goto E;<br>
   blocco;<br>
   goto L;<br>
E: istruzione;<br>
</code><br>
<i> Assembly: </i><br>
<code>L: IA32(test)<br>
   Jcc E<br>
   IA32(blocco)<br>
   jmp L<br>
E: IA32(istruzione)<br>
</code><br>
<br>
Si noti che il while è del tutto simile all’if, tranne che dopo l’esecuzione del blocco non si prosegue all’istruzione successiva, ma si torna al test.<br>
<br>
<u> Esempio</u><br>
<i> C da tradurre: </i><br>
<code>a=1;<br>
c=0;<br>
<br>
while (a<=b) { <br>
    c+=a; <br>
    a++;<br> 
}</code><br>
<br>
<i> Assembly: </i><br>
<code>   movl $1, %eax<br>
   movl $0, %ecx<br>
L: cmpl %ebx, %eax<br>
   ja E<br>
   addl %eax, %ecx<br>
   incl %eax<br>
   jmp L<br>
E: <br>
</code><br>
<br>
<b>Istruzione for</b><br>
Consideriamo lo schema generale di una istruzione for. Si esegue dapprima l’inizializzazione e poi si effettua il test. Se il test effettuato è vero, viene eseguito il blocco, si esegue l’aggiornamento, e si ritorna al test, altrimenti si prosegue con l’istruzione successiva al for. <br>
<br>
L’istruzione for può essere tradotta come segue:<br>
<br>
<i> C da tradurre: </i><br>
<code>for (ini;test;agg) <br>
    blocco<br>
istruzione<br>
<br>
</code><br>
<i> C equivalente: </i><br>
<code>   ini;<br>
L: <br>
   if (!test) goto E;<br>
   blocco;<br>
   agg;<br>
   goto L;<br>
E: istruzione<br>
<br>
</code><br>
<i> Assembly: </i><br>
<code>  IA32(ini)<br>
L: IA32(test)<br>
   Jcc E;<br>
   IA32(blocco)<br>
   IA32(agg)<br>
   jmp L<br>
E: IA32(istruzione)<br>
<br>
</code><br>
<br>
|
titolo£[Assembly]-Funzioni|
linguaggio£Assembly|
lezione£
<b>Funzioni</b><br>
Una funzione C è normalmente tradotta in assembly IA32 come una sequenza di istruzioni terminate da una RET e viene invocata mediante l’istruzione CALL. Durante una chiamata a funzione, la funzione che ha effettuato l’invocazione viene detta chiamante (caller) e quella invocata viene detta chiamato (callee).<br>
Le convenzioni relative alla traduzione delle funzioni, del passaggio dei parametri e della restituzione dei valori che vedremo in questo paragrafo non sono specificate dall’ISA IA32, ma sono conformi con la System V Application Binary Interface (ABI), che descrive uno standard diffuso (es. Mac OS X e Linux) usato nella creazione dei file oggetto e nell’orchestrazione dell’esecuzione dei programmi su piattaforme IA32.<br>
Esempio.<br>
Il seguente frammento di programma C mostra come la definizione di una funzione e la chiamata a funzione vengono tradotte in codice IA32:<br>
<i> C da tradurre:</i><br>
<code><br>
void f(){    void g(){    void h(){<br>
   g();         …            … <br>
   h();      }            }<br>
}<br>
</code><br>
<br>
<i> Assembly </i><br>
<code><br>
<br>
f:             g:          h:<br>
   call g         …           … <br>
   call h         ret         ret<br>
   ret<br>
<br>
</code><br>
<b>Restituzione valore</b><br>
Per convenzione, valori scalari come interi e puntatori vengono restituiti al chiamante dal chiamato scrivendoli nel registro eax.<br>
Esempio.<br>
Consideriamo il seguente frammento di programma C<br>
<i> C da tradurre:</i><br>
<code><br>
int f(){<br>
   return 7+g();<br>
}<br>
<br>
<br>
int g(){<br>
   return 10;<br>
}<br>
</code><br>
<br>
<i> Assembly:</i><br>
<code><br>
f:<br>
   call g<br>
   addl $7, %eax<br>
   ret<br>
<br>
g:<br>
   movl $10, %eax<br>
</code><br>
<br>
Si noti che g restituisce a f il valore 10 in eax, e a sua volta f restituisce al proprio chiamante il valore 17 in eax.<br>

<b>Stack frame e registro EBP</b><br>
La stack è uno strumento essenziale per l’orchestrazione delle chiamate a funzione e per fornire spazio di memorizzazione locale alle chiamate. Ogni invocazione a funzione ha associato uno stack frame (o record di attivazione), che contiene spazio per memorizzare variabili locali, parametri passati ad altre funzioni, ecc. <br>
Per consentire a un debugger di elencare in ogni istante le funzioni pendenti che portano dal main alla funzione correntemente eseguita, e quindi comprendere meglio il contesto in cui una funzione agisce, gli stack frame vengono organizzati a formare concettualmente una lista collegata, in cui il registro ebp punta al primo stack frame (quello della funzione correntemente eseguita). Ogni stack frame conterrà un puntatore allo stack frame del proprio chiamante.<br>
<u>il collegamento fra stack frame usando ebp è opzionale</u><br>
<b>Per convenzione, nel momento in cui si effettua un’istruzione CALL, la base della stack puntata dal registro %esp deve essere sempre a un indirizzo multiplo di 16</b><br>
La lista di stack frame viene gestita mediante un codice di prologo all’inizio di una funzione e un codice di epilogo alla fine:<br>
1)Il prologo salva in stack il contenuto di ebp (che punta allo stack frame del chiamante) mediante l’istruzione pushl %ebp. Il registro base pointer ebp viene poi fatto puntare alla posizione corrente in stack contenuta nel registro stack pointer esp mediante l’istruzione movl %esp, %ebp (così facendo, registro ebp viene a puntare allo stack frame corrente). <br><br>
2)L’epilogo ripristina il valore di ebp che si aveva prima dell’attivazione della funzione corrente eseguendo popl %ebp. Il registro ebp verrà quindi a puntare nuovamente allo stack frame del chiamante.<br>
In gcc, è possibile omettere il collegamento fra stack frame compilando con l’opzione -fomit-frame-pointer. In questo modo, non verranno generati prologo ed epilogo: la funzione sarà più veloce e compatta, ma il debugging potrebbe essere più difficoltoso.<br>
<br>
<b>Passaggio dei parametri</b><br>
I parametri di tipi primitivi vengono passati dal chiamante al chiamato sulla stack e vengono disposti in memoria nello stack frame del chiamante nello stesso ordine in cui appaiono nell’intestazione della funzione. Parametri interi di 1 o 2 byte vengono promossi a 4 byte, in modo che ogni parametro passato sia di dimensione multiplo di 4 byte.<br>
<br>
<b>Registri caller-save e callee-save</b><br>
L’esecuzione di una funzione potrebbe sovrascrive i registri in uso al chiamante. Se il chiamante vuole avere la garanzia che il contenuto di un registro non verrà alterato a fronte dell’invocazione di una funzione, è necessario che il suo contenuto venga salvato da qualche parte, generalmente sulla stack. Si hanno due possibilità:
Il registro viene salvato in stack dal chiamante (caller-save) prima dell’invocazione e ripristinato subito dopo.
Il registro viene salvato in stack dal chiamato (callee-save) prima di eseguirne il corpo e ripristinato prima di ritornare al chiamato (il salvataggio avviene nel prologo e il ripristino nell’epilogo).
Per convenzione, alcuni registri vengono salvati dal chiamante, e altri dal chiamato:<br>
<b>Registri caller-save: A, C, D</b><br>
<b>Registri callee-save: B, DI, SI, SP, BP</b><br>
I registri caller-save possono essere liberamente usati da una funzione senza dover essere salvati nel prologo e ripristinati nell’epilogo, ma devono essere salvati/ripristinati a fronte di una chiamata a funzione se serve mantenerne il contenuto dopo la chiamata. I registri callee-save, se usati da una funzione, devono essere salvati nel prologo e ripristinati nell’epilogo della funzione; si ha la garanzia che il loro contenuto sia preservato a fronte dell’invocazione di una funzione.<br>

<b>Array e aritmetica dei puntatori<b><br>
L’accesso alle celle di array con elementi di dimensione fino a 4 byte avviene normalmente sfruttando gli indirizzamenti a memoria della forma: 
(base, indice, scala)<br>
dove base è l’indirizzo del primo byte dell’array, indice è l’indice della cella dell’array che si vuole accedere, e scala=sizeof(elemento) è il numero di byte di ciascun elemento dell’array. Si noti che l’indirizzo effettivo base+indice*scala calcolato dall’operando (base, indice, scala) realizza l’<b>aritmetica dei puntatori</b>, scalando l’indice in base alla dimensione degli elementi dell’array.<br>
Se l’indice i dell’elemento che si vuole accedere è noto a tempo di compilazione, è possibile usare la forma:<br>
dove base è l’indirizzo del primo byte dell’array e disp=i*sizeof(elemento) è lo spiazzamento in byte rispetto alla base dell’array per arrivare all’i-esimo elemento dell’array.<br>
<u>Esempio 1.</u><br>
Si consideri la scrittura della cella c-esima dell’array a di int, assumendo che la variabile a sia tenuta in eax e la variabile c in ecx:<br>
<br>
<br>
<i>C da tradurre</i><br>
<code><br>
a[c]=10;<br>
</code><br>
<i>C equivalente</i><br>
<code>*(a+c)=10;</code><br>
<i>Traduzione IA32</i><br>
<code>movl $10, (%eax,%ecx,4)</code><br>
<br>
Si noti che la scala è 4 poiché l’array è di int e sizeof(int)==4.<br>
<br>|
titolo£[Assembly]-Memoria|
linguaggio£Assembly|
lezione£
<b> Processi</b><br>
Quando un programma viene eseguito, esso dà luogo a un processo. Un processo è semplicemente un programma in esecuzione. <br>
<br>
Uno stesso programma può essere istanziato in più processi che possono coesistere nel sistema. Ogni processo è identificato univocamente dal un identificatore di processo chiamato PID (Process ID). Il PID è un numero progressivo che viene incrementato di uno ogni volta che viene creato un nuovo processo.<br>
<br>
Un processo è caratterizzato da principalmente da:<br>
Un’immagine di memoria che contiene il codice del programma e i dati da esso manipolati (variabili, blocchi allocati dinamicamente, ecc.)
Lo stato della CPU (registri interni, ecc.)<br>
Un insieme di risorse in uso (file aperti, ecc.)<br>
Un insieme di metadati che tengono traccia vari aspetti legati al processo stesso e all’esecuzione del programma (identificatore del processo, utente proprietario del processo, per quanto tempo il processo è stato in esecuzione, ecc.)<br>
<br>
Un processo può essere attivato in vari modi:<br>
su richiesta esplicita dell’utente che richiede l’esecuzione di un programma: questo può avvenire sotto forma di comandi impartiti da riga di comando (si veda l’Appendice C), oppure via interfaccia grafica facendo clic sull’icona associata a un programma eseguibile.<br>
su richiesta di altri processi<br>
in risposta ad eventi come lo scadere di un timer usato per attività programmate nel tempo (es. aggiornamento periodico della posta elettronica).<br>
<br>
<b>Come viene gestita la memoria?</b><br>
<br>
La memoria è vista generalmente da un processo come uno spazio di indirizzi contigui contenente codice, variabili, blocchi allocati dinamicamente, stringhe letterali, ecc. Il problema di gestire uno spazio di indirizzi di memoria tenendo traccia di quali zone sono libere e quali invece sono in uso ai processi è chiamato allocazione della memoria, ed è uno dei problemi più vecchi e fondamentali dell'informatica.<br>
<b>Allocazione dinamica della memoria</b><br>
<br>
Un allocatore di memoria è una struttura di dati per la gestione della memoria. Un allocatore supporta generalmente tre primitive che possono essere usate dai programmi per richiedere blocchi di memoria da utilizzare e rilasciarli quando non servono più:<br>
<br>
<br>
p=alloca(n): restituisce l'indirizzo iniziale di un blocco di almeno n byte contigui che possono essere usati per memorizzare dati e programmi;<br>
p=ridimensiona(p,n): ridimensiona il blocco p alla nuova dimensione n e restituisce il nuovo indirizzo del blocco (che potrebbe essere cambiato);<br>
dealloca(p): rilascia il blocco p.<br>
Esempio. Quando un programma ha bisogno di spazio di memoria di appoggio per memorizzare i suoi dati, chiama malloc() (alloca). <br>Se necessario, il programma può chiedere di ridimensionare un blocco con realloc() (ridimensiona). Quando quello spazio non serve più, chiama free() (dealloca). <br>
<br>
Un classico errore di programmazione consiste nel non deallocare un blocco quando non è più in uso. Questo errore provova memory leak, cioè l'accumularsi di blocchi considerati come in uso dall'allocatore - e quindi non utilizzabili per altri scopi, ma non effettivamente utilizzati dai programmi. Un memory leak è un bug molo serio che può portare all'esaurimento progressivo della memoria disponibile.<br>
<br>
<b>Frammentazione interna ed esterna</b><br>

La frammentazione della memoria è un fenomeno per cui esiste spazio libero, ma non è utilizzabile per soddisfare le richieste dei programmi. Si hanno due tipi principali di frammentazione della memoria:<br>
Frammentazione interna: quando vi è spazio inutilizzato all'interno di un blocco precedentemente allocato. Ad esempio, il padding inserito dal compilatore per garantire allineamento è una fonte di frammentazione interna. Come altro motivo di frammentazione interna, gli allocatori alle volte riservano più memoria di quella richiesta. Questo avviene ad esempio se si richiede di allocare un blocco di dimensione inferiore a una certa soglia minima (es. 16 byte), dato che l'allocatore restituisce blocchi di dimensione non inferiore alla soglia.<br>
Frammentazione esterna: si manifesta se una richiesta di allocazione non può essere soddisfatta con lo spazio libero disponibile non perché non sia sufficiente, ma perché non è contiguo. La frammentazione esterna può aversi solo nel caso in cui viene richiesta l'allocazione di blocchi di dimensioni diverse. Se infatti i blocchi allocati sono tutti della stessa dimensione, quando vengono rilasciati lasciano spazio libero contiguo sempre utile per essere riutilizzato per soddisfare richieste future di allocazione.<br>
<br>
<b>Memoria fisica e memoria virtuale</b><br>
<br>
Nei sistemi di calcolo più semplici, come alcuni sistemi embedded (es. modem/router, macchine fotografiche digitali, hardware di controllo degli elettrodomestici, ecc.), i processi indirizzano direttamente la memoria fisica. Ogni puntatore di un programma contiene un indirizzo di memoria fisica e tutti i processi condividono lo stesso spazio di indirizzi. Questo semplice schema soffre di vari problemi:<br>
<br>
Mancanza di protezione. Poiché tutti i processi "vedono" tutta la memoria fisica, un processo potrebbe erroneamente o maliziosamente accedere alla parte di memoria in uso a un altro processo, compromettendone il funzionamento.<br>
Frammentazione esterna. Poiché lo spazio di memoria fisica va suddiviso fra processi che vengono continuamente creati ed eliminati, e ciascun processo ha bisogno di uno spazio contiguo di memoria, potrebbe crearsi frammentazione esterna con ampio spazio disponibile, ma sminuzzato in tante piccole zone libere insufficienti a soddisfare le necessità di memoria dei processi.<br>
<br>
Per risolvere questi problemi, nei sistemi più complessi viene utilizzata una tecnica più raffinata chiamata memoria virtuale, in cui ogni processo ha un suo spazio virtuale di indirizzi (anche chiamato spazio logico di indirizzi) distinto da quello fisico.<br>
|
titolo£[SQL]-Introduzione1|
linguaggio£SQL|
lezione£Uno dei moduli principali di un’applicazione moderna è, generalmente, quello che riguarda la gestione dei dati, che può essere basato sull’utilizzo di svariate tecnologie. Si può pensare, per piccoli progetti, di memorizzare i dati in file di testo, più o meno strutturati; ma per i software professionali e di grandi dimensioni, è quasi sempre impossibile prescindere dall’utilizzo di un database.<br>
<br>
Il <b>database</b> è una struttura software piuttosto complessa, in grado di ottimizzare l’accesso e la modifica di grandi quantità di dati archiviati su un generico dispositivo di archiviazione. Negli anni, lo sviluppo dei database ha visto una crescita notevole, e si è affermata quasi ovunque la classe dei <b>database relazionali</b>. Per interagire con tale classe di database vi è, oggi, un linguaggio considerato in tutto e per tutto uno standard, e denominato <b>SQL</b> (acronimo che sta per <b>S</b>tructured <b>Q</b>uery <b>L</b>anguage).<br>
<br>
Questa guida è dedicata proprio ad approfondire gli aspetti fondamentali di SQL, spiegandone la sintassi di base e, prima ancora, le origini ed i concetti che vi stanno alla base. Non ci sono particolari requisiti per la comprensione di questa guida, destinata a chi si avvicina per la prima volta al mondo di SQL e, più in generale, a quello dei database.<br>
La grammatica sintattica utilizzata nelle varie lezioni per spiegare la sintassi dei comandi SQL e’ molto semplice:<br>
&ensp;-Il testo in maiuscolo deve comparire cosi’ com’e’. Il linguaggio SQL non e’ case-sensitive, quindi poi negli esempi compariranno sia lettere maiuscole che minuscole in modo da aumentarne la leggibilita’.<br>
&ensp;-Il testo in minuscolo indica elementi che devono essere ulteriormente specificati. Ad esempio se compare vincoli_di_colonna non significa che in quella posizione bisogna scrivere esattamente quella sequenza di caratteri, ma che vi troveranno posto i vincoli posti sulla colonna, specificati con la loro particolare sintassi, che e’ stata o verra’ spiegata in altro luogo.<br>
&ensp;-Le parentesi quadrate ([]) indicano elementi che sono opzionali e che quindi non devono necessariamente comparire.<br>
&ensp;-I tre punti (…) indicano elementi che possono essere ripetuti. Ad esempio:<br>
<code><br>
    [ , [ vincolo_di_tabella ] … ]</code><br>
indica che l’elemento “, [vincolo_di_tabella]” puo’ essere ripetuto quante volte e’ necessario.<br>
&ensp;-Elementi separati dal carattere “or” ed eventualmente raggruppati dalle parentesi graffe ({}) indicano elementi che sono in alternativa. Ad esempio:<br>
<code>{ elemento1 or elemento2 }</code>
indica che in quella posizione andra’ scritto o elemento1 o elemento2.<br>
&ensp;-Il testo scritto fra apici singoli (‘) o doppi (“) va scritto esattamente come indicato (apici, maiuscole e minuscole comprese).<br>
&ensp;-Gli altri caratteri (ad esempio, le virgole (,) o i doppi apici (“)) devono comparire cosi’ come sono.<br>
Il World Wide Web e’ forse una delle maggiori fonti di informazione a cui oggi possiamo attingere: avendo a disposizione un collegamento a Internet ed un browser Web, un software ormai comune su qualsiasi computer, abbiamo la possibilita’ di consultare un patrimonio di centinaia di milioni di pagine riguardanti praticamente ogni argomento di interesse.<br>
<br>
Spesso queste pagine non sono documenti statici, ma vengono creati dinamicamente quando noi li richiediamo e le informazioni che contengono vengono estratte da un database. Se il database e’ un database <b>relazionale</b> (vedremo in seguito cosa questo significa), probabilmente il linguaggio utilizzato per recuperare le informazioni che ci vengono mostrate e’ SQL (Structured Query Language).<br>
<br>
Prima di occuparci di cos’e’ e come si usa SQL cerchiamo di capire cosa si intende con la parola database, che spesso in italiano viene tradotta come “base di dati”.<br>
Un database e’ una collezione di dati che viene gestita e organizzata da un software specifico, il DBMS (DataBase Management System, Sistema di Gestione di DataBase).<br> Un DBMS e’ sostanzialmente uno strato software che si frappone fra l’utente ed i dati veri e propri. Grazie a questo strato intermedio l’utente e le applicazioni non accedono ai dati cosi’ come sono memorizzati effettivamente, cioe’ alla loro rappresentazione fisica, ma ne vedono solamente una rappresentazione logica. Cio’ permette un elevato grado di indipendenza fra le applicazioni e la memorizzazione fisica dei dati. L’amministratore del database, se ne sente la necessita’, puo’ decidere di memorizzare i dati in maniera differente o anche di cambiare il DBMS senza che le applicazioni, e quindi gli utenti, ne risentano. La cosa importante e’ che non venga cambiata la rappresentazione logica di quei dati, che e’ la sola cosa che i loro utilizzatori conoscono. Questa rappresentazione logica viene chiamata ‘Schema del database’ ed e’ la forma di rappresentazione dei dati piu’ a basso livello a cui un utente del database puo’ accedere.<br>
Nel corso degli anni sono stati adottati numerosi modelli per i dati, a fronte dei quali esistono quindi vari tipi di database. I tipi piu’ comuni sono:<br>
<br>
&ensp; -<b>Database gerarchici</b>: i dati vengono organizzati in insiemi legati fra loro da relazioni di “possesso”, in cui un insieme di dati puo’ possedere altri insiemi di dati, ma un insieme puo’ appartenere solo ad un altro insieme. La struttura risultante e’ un albero di insiemi di dati.<br>
<br>
&ensp; -<b>Database reticolari</b>: il modello reticolare e’ molto simile a quello gerarchico, ed infatti nasce come estensione di quest’ultimo. Anche in questo modello insiemi di dati sono legati da relazioni di possesso, ma ogni insieme di dati puo’ appartenere a uno o piu’ insiemi. La struttura risultante e’ una rete di insiemi di dati.<br>
<br>
&ensp; -<b>Database relazionali</b>: i database appartenenti a questa categoria si basano sul modello relazionale la cui struttura principale e’ la relazione, cioe’ una tabella bidimensionale composta da righe e colonne. Ciascuna riga, che in terminologia relazionale viene chiamata tupla, rappresenta un’entita’ che noi vogliamo memorizzare nel database. Le caratteristiche di ciascuna entita’ sono definite invece dalle colonne delle relazioni, che vengono chiamate attributi. Entita’ con caratteristiche comuni, cioe’ descritti dallo stesso insieme di attributi, faranno parte della stessa relazione.<br>
<br>
&ensp; -<b>Database ad oggetti</b> (object-oriented): lo schema di un database ad oggetti e’ rappresentato da un insieme di classi, che definiscono le caratteristiche ed il comportamento degli oggetti che popoleranno il database. La principale differenza con i modelli esaminati finora e’ la non passivita’ dei dati. Infatti con un database tradizionale (intendendo con questo termine qualunque database non ad oggetti) le operazioni che devono essere effettuate sui dati vengono demandate alle applicazioni che li utilizzano. Con un database object-oriented, al contrario, gli oggetti memorizzati nel database contengono sia i dati che le operazioni possibili su tali dati. In un certo senso potremmo pensare agli oggetti come a dati a cui e’ stata fatta una iniezione di intelligenza, che gli permette di sapere come comportarsi, senza doversi appoggiare ad applicazioni esterne.<br>
<br>
I primi due tipi di database, quelli gerarchici e reticolari, quasi appartengono ormai alla storia dell’informatica.<br>
La maggior parte dei database attualmente utilizzati appartiene alla categoria dei database relazionali. I motivi di questo successo (anche commerciale) vanno ricercati nella rigorosita’ matematica e nella potenzialita’ espressiva del modello relazionale su cui si basano, nella sua semplicita’ di utilizzo e, ultima ma non meno importante, nella disponibilita’ di un linguaggio di interrogazione standard, l’SQL, che, almeno potenzialmente, permette di sviluppare applicazioni independenti dal particolare DBMS relazionale utilizzato.<br>
I database ad oggetti sono la nuova frontiera nella ricerca sui database, infatti le loro caratteristiche di estendibilita’, derivanti dalla possibilita’ di definire nuovi tipi di dati e comportamenti, li rendono particolarmente appetibili per tutte quelle applicazioni che richiedono dati complessi, come ad esempio immagini, suoni o coordinate. Purtroppo la mancanza di un modello per gli oggetti universalmente accettato e la non disponibilita’ di un linguaggio di interrogazione standard fanno si’ che ogni produttore implementi la propria visione specifica, di solito assolutamente incompatibile con tutte le altre. Di recente sono apparsi sul mercato alcuni database, definiti object-relational, che cercano di introdurre nel modello relazionale le caratteristiche di estendibilita’ proprie dei database object-oriented.<br>
<br>
Indipendentemente dal tipo di database, le funzionalita’ principali che ci si deve aspettare da un DBMS sono quelle di:<br>
<br>
&ensp; -   consentire l’accesso ai dati attraverso uno schema concettuale, invece che attraverso uno schema fisico;<br>
&ensp; -   permettere la condivisione e l’integrazione dei dati fra applicazioni differenti;<br>
&ensp; -   controllare l’accesso concorrente ai dati;<br>
&ensp; -   assicurare la sicurezza e l’integrita’ dei dati.<br>
<br>
Grazie a queste caratteristiche le applicazioni che vengono sviluppate possono contare su una sorgente dati sicura, affidabile e generalmente scalabile. Tali proprieta’ sono auspicabili per applicazioni che usano la rete Internet come infrastruttura e che hanno quindi evidenti problemi di sicurezza e scalabilita’.<br>
|
titolo£[SQL]-Il Modello Relazionale|
linguaggio£SQL|
lezione£
I database relazionali sono il tipo di database attualmente piu’ diffuso. I motivi di questo successo sono fondamentalmente due:<br>
<br>
<b>1.</b> forniscono sistemi semplici ed efficienti per rappresentare e manipolare i dati<br>
<b>2.</b> si basano su un modello, quello relazionale, con solide basi teoriche<br>
l modello e’ diventato negli anni ’80 quello piu’ utilizzato per la produzione di DBMS.<br>
La struttura fondamentale del modello relazionale e’ appunto la “relazione”, cioe’ una tabella bidimensionale costituita da righe (tuple) e colonne (attributi). Le relazioni rappresentano le entita’ che si ritiene essere interessanti nel database. Ogni istanza dell’entita’ trovera’ posto in una tupla della relazione, mentre gli attributi della relazione rappresenteranno le proprieta’ dell’entita’. Ad esempio, se nel database si dovranno rappresentare delle persone, si potra’ definire una relazione chiamata “Persone”, i cui attributi descrivono le caratteristiche delle persone . Ciascuna tupla della relazione “Persone” rappresentera’ una particolare persona.<br><br>
<table>
    <tr><td>Nome</td><td>Cognome</td><td>età</td><td>sesso</td></tr>
    <tr><td>Mario</td><td>Rossi</td><td>26</td><td>M</td></tr>
    <tr><td>Andrea</td><td>Cavallo</td><td>23</td><td>M</td></tr>
    <tr><td>Giorgia</td><td>Fumelli</td><td>23</td><td>F</td></tr>
</table><br><br>
In realta’, volendo essere rigorosi, una relazione e’ solo la definizione della struttura della tabella, cioe’ il suo nome e l’elenco degli attributi che la compongono. Quando essa viene popolata con delle tuple, si parla di “istanza di relazione”. Percio’ la precedente Tabella rappresenta un’istanza della relazione persona. Una rappresentazione della definizione di tale relazione potrebbe essere la seguente:<br>
<br>
Persone (nome, cognome, età, sesso)<br>
<br>
Nel seguito si indicheranno entrambe (relazione ed istanza di relazione) con il termine “relazione”, a meno che non sia chiaro dal contesto a quale accezione ci si riferisce.<br>
Le tuple in una relazione sono un insieme nel senso matematico del termine, cioe’ una collezione non ordinata di elementi differenti. Per distinguere una tupla da un’altra si ricorre al concetto di “chiave primaria”, cioe’ ad un insieme di attributi che permettono di identificare univocamente una tupla in una relazione. Naturalmente in una relazione possono esserci piu’ combinazioni di attributi che permettono di identificare univocamente una tupla (“chiavi candidate”), ma fra queste ne verra’ scelta una sola da utilizzare come <b>chiave primaria</b>. <u>Gli attributi della chiave primaria non possono assumere il valore null (che significa un valore non determinato), in quanto non permetterebbero piu’ di identificare una particolare tupla in una relazione.</u> Questa proprieta’ delle relazioni e delle loro chiavi primarie va sotto il nome di integrita’ delle entita’ (entity integrity).<br>
<br>
Spesso per ottenere una chiave primaria “economica”, cioe’ composta da pochi attributi facilmente manipolabili, si introducono uno o piu’ attributi fittizi, che conterranno dei codici identificativi univoci per ogni tupla della relazione.<br>
Ogni attributo di una relazione e’ caratterizzato da un nome e da un dominio. Il dominio indica quali valori possono essere assunti da una colonna della relazione. Spesso un dominio viene definito attraverso la dichiarazione di un tipo per l’attributo (ad esempio dicendo che e’ una stringa di dieci caratteri), ma e’ anche possibile definire domini piu’ complessi e precisi. Ad esempio per l’attributo “sesso” della nostra relazione “Persone” possiamo definire un dominio per cui gli unici valori validi sono ‘M’ e ‘F’; oppure per l’attributo “eta” potremmo definire un dominio per cui vengono considerate valide solo le età maggiori di 24, se nel nostro database non e’ previsto che ci siano persone con età minore di quella. Il DBMS si occupera’ di controllare che negli attributi delle relazioni vengano inseriti solo i valori permessi dai loro domini. Caratteristica fondamentale dei domini di un database relazionale e’ che siano “atomici”, cioe’ che i valori contenuti nelle colonne non possano essere separati in valori di domini piu’ semplici. Piu’ formalmente si dice che non e’ possibile avere attributi multivalore (multivalued). Ad esempio, se una caratteristica delle persone nel nostro database fosse anche quella di avere uno o piu’ figli, non sarebbe possibile scrivere la relazione Persone nel seguente modo:<br>
<br>
Persone (nome, cognome, età, sesso, figli)<br>
<br>
Infatti l’attributo figli e’ un attributo non-atomico, sia perche’ una persona puo’ avere piu’ di un figlio, sia perche’ ogni figlio avra’ varie caratteristiche che lo descrivono. Per rappresentare queste entita’ in un database relazionale bisogna definire due relazioni:<br>
<br>
Persone(*numero_persona, nome, cognome, età, sesso)<br>
Figli(*numero_persona, *nome_cognome, eta, sesso)<br>
<br>
Nelle precedenti relazioni gli asterischi (*) indicano gli attributi che compongono le loro chiavi primarie. Si noti l’introduzione nella relazione Persone dell’attributo numero_persona, attraverso il quale si assegna a ciascuna persona un identificativo numerico univoco che viene utilizzato come chiave primaria. Queste relazioni contengono solo attributi atomici. Se una persona ha piu’ di un figlio, essi saranno rappresentati in tuple differenti della relazione Figli. Le varie caratteristiche dei figli sono rappresentate dagli attributi della relazione Figli. Il legame fra le due relazioni e’ costituito dagli attributi numero_persona che compaiono in entrambe le relazioni e che permettono di assegnare ciascuna tupla della relazione figli ad una particolare tupla della relazione Persone. Piu’ formalmente si dice che l’attributo numero_persona della relazione Figli e’ una chiave esterna (foreign key) verso la relazione Persone. Una chiave esterna e’ una combinazione di attributi di una relazione che sono chiave primaria per un’altra relazione. Una caratteristica fondamentale dei valori presenti in una chiave esterna e’ che, a meno che non siano null, devono corrispondere a valori esistenti nella chiave primaria della relazione a cui si riferiscono. Nel nostro esempio cio’ significa che non puo’ esistere nella relazione Figli una tupla con un valore dell’attributo numero_persona, senza che anche nella relazione Persone esista una tupla con lo stesso valore per la sua chiave primaria. Questa proprieta’ va sotto il nome di integrita’ referenziale (referential integrity)<br>
<br>
Uno dei grandi vantaggi del modello relazionale e’ che esso definisce anche un algebra, chiamata appunto “algebra relazionale”. Tutte le manipolazioni possibili sulle relazioni sono ottenibili grazie ala combinazione di cinque soli operatori: REStrICT, PROJECT, TIMES, UNION e MINUS. Per comodita’ sono stati anche definiti tre operatori addizionali che comunque possono essere ottenuti applicando i soli cinque operatori fondamentali: JOIN, INTERSECT e DIVIDE. Gli operatori relazionali ricevono come argomento una relazione o un insieme di relazioni e restituiscono una singola relazione come risultato.<br>
Vediamo brevemente questi otto operatori:<br>
<br>
<b>REStrICT</b>: restituisce una relazione contenente un sottoinsieme delle tuple della relazione a cui viene applicato. Gli attributi rimangono gli stessi.<br>
<br>
<b>PROJECT</b>: restituisce una relazione con un sottoinsieme degli attributi della relazione a cui viene applicato. Le tuple della relazione risultato vengono composte dalle tuple della relazione originale in modo che continuino ad essere un insieme in senso matematico.<br>
<br>
<b>TIME</b>: viene applicato a due relazioni ed effettua il prodotto cartesiano delle tuple. Ogni tupla della prima relazione viene concatenata con ogni tupla della seconda.<br>
<br>
<b>JOIN</b>: vengono concatenate le tuple di due relazioni in base al valore di un insieme dei loro attibuti.<br>
<br>
<b>UNION</b>: applicando questo operatore a due relazioni compatibili, se ne ottiene una contenente le tuple di entrambe le relazioni. Due relazioni sono compatibili se hanno lo stesso numero di attributi e gli attributi corrispondenti nelle due relazioni hanno lo stesso dominio.<br>
<br>
<b>MINUS</b>: applicato a due relazioni compatibili, ne restituisce una terza contenente le tuple che si trovano solo nella prima relazione.<br>
<br>
<b>INTERSECT</b>: applicato a due relazioni compatibili, restituisce una relazione contenente le tuple che esistono in entrambe le relazioni.<br>
<br>
<b>DIVIDE</b>: applicato a due relazioni che abbiano degli attributi comuni, ne restituisce una terza contenente tutte le tuple della prima relazione che possono essere fatte corrispondere a tutti i valori della seconda relazione.<br>
|
titolo£[SQL]-Come interagire con un DBMS|
linguaggio£SQL|
lezione£
Come si e’ detto, l’interazione con un database relazionale avviene normalmente utilizzando istruzioni SQL. L’invio delle istruzioni al DBMS puo’ avvenire in due modi:<br>
<br>
&ensp; invocazione interattiva<br>
&ensp; invocazione tramite un programma applicativo<br>
<br>
Nel primo caso viene utilizzato un programma il cui scopo e’ quello di ricevere in input le istruzioni SQL, trasmetterle al DBMS e visualizzare i risultati all’utente. Normalmente tutti i DBMS mettono a disposizione un programma, di solito di tipo testuale, con tali funzionalita’.
Nel caso di PostgreSQL, il DBMS che utilizzero’ per implementare il database di esempio, il programma si chiama “psql”. La sintassi da utilizzare per invocarlo in modalita’ interattiva e’ la seguente:<br>
<br>
<code>psql [ dbname [ user ] ]</code><br>
<br>
“dbname” e’ il nome del database a cui si vuole accedere, mentre “user” e’ il nome dell’utente con cui si vuole accedere al database. Ad esempio, il comando:<br>
<br>
<code>psql mydb benfante</code><br>
<br>
attiva il programma psql, accedendo al database mydb come utente benfante. Se tutto e’ andato bene, in particolare se il database esiste e l’utente ha i permessi necessari per accedervi, psql mostra un prompt simile al seguente:<br>
<br>
<code>mydb=></code><br>
<br>
A questo punto si possono digitare i comandi SQL (terminandoli con un “;” o con il meta-comando “g” (go) per farli eseguire) e leggere sullo schermo i risultati che producono.<br>
<br>
Normalmente i programmi come psql possono essere utilizzati anche in maniera non-interattiva. Ad esempio, invocando psql col seguente comando:<br>
<br>
<code>psql -f istruzioni.sql mydb benfante</code><br>
<br>
il programma esegue le istruzioni SQL contenute nel file istruzioni.sql e termina immediatamente dopo. In questo modo e’ possibile automatizzare operazioni che devono essere ripetute di frequente o, comunque, che sono composte da lunghe sequenze di comandi SQL, senza doverle digitare manualmente ogni volta.<br>
<br>
Nel caso dell’invocazione delle istruzioni SQL tramite un programma applicativo, esse sono eseguite nel corso dell’esecuzione di tale programma ed i risultati vengono utilizzati dal programma per produrre il suo output. In questa situazione l’utente non sottopone direttamente i comandi SQL e potrebbe anche non essere a conoscenza che il programma che sta utilizzando accede ad un database relazionale: l’unica cosa che vede e’ l’interfaccia che l’applicazione gli mette a disposizione. Abbiamo sostanzialmente due sistemi per scrivere applicazioni di questo tipo:<br>

&ensp; - utilizzare una libreria che gestisca la comunicazione con il DBMS, trasmetta le istruzioni SQL e ci permetta di manipolare i risultati prodotti. Librerie di questo tipo sono ad esempio JDBC e ODBC. Spesso i produttori dei DBMS forniscono delle librerie proprietarie, che sono specifiche per il loro prodotto. Ad esempio, nel caso di PostgreSQL la libreria per il linguaggio C si chiama “libpq”. Spesso si cerca di non utilizzare librerie proprietarie perche’ le applicazioni risultano molto specifiche (funzionano solo con il database per cui la libreria e’ stata costruita). Invece utilizzando librerie “standard” come JDBC o ODBC le applicazioni funzioneranno con qualunque DBMS che esponga l’interfaccia richiesta dalla libreria (a meno di non utilizzare funzionalita’ specifiche del DBMS).<br>
&ensp; - utilizzare l’Embedded SQL (ESQL). In questo caso il codice SQL viene inglobato nel codice di un linguaggio ospite e vengono utilizzati i normali meccanismi del linguaggio per il passaggio dei parametri e l’utilizzo dei risultati. Normalmente il codice cosi’ prodotto viene prima convertito da un pre-processore e in seguito compilato dal compilatore del linguaggio ospite. Un ulteriore vantaggio nell’utilizzare l’ESQL risiede nel fatto che esiste uno standard ANSI che descrive come esso dovrebbe funzionare. In questo modo e’ possibile che un programma scritto per un determinato DBMS possa essere ricompilato e funzionare anche per un altro. PostgreSQL mette a disposizione un pre-processore ESQL per il linguaggio C (ecpg).<br>
<br>
Nelle successive lezioni utilizzeremo psql per inviare le istruzioni SQL che implementeranno, popoleranno e interrogheranno il database d’esempio. Nell’ultima lezione verra’ invece presentata un’applet Java che utilizzera’ la libreria JDBC per consultare il database bibliografico.<br>
<b> Creare un database</b> <br>
Un database in un sistema relazionale e’ composto da un’insieme di tabelle, che corrispondono alle relazioni del modello relazionale. Nella terminologia usata nell’SQL non si fa accenno alle relazioni, cosi’ come non viene usato il termine attributo, ma viene usata la parola colonna, e non si parla di tupla, ma di riga. Nel seguito verranno usate indifferentemente le due terminologie, quindi tabella varra’ per relazione, colonna per attributo, riga per tupla, e viceversa.<br>
In pratica la creazione del database consiste nella creazione delle tabelle che lo compongono. In realta’ prima di poter procedere alla creazione delle tabelle normalmente occorre creare in effetti il database, il che di solito significa definire uno spazio dei nomi separato per ogni insieme di tabelle. In questo modo per un DBMS e’ possibile gestire piu’ database indipendenti contemporaneamente, senza che ci siano dei conflitti con i nomi che vengono utilizzati in ciascuno di essi. Il sistema previsto dallo standard per creare degli spazi dei nomi separati consiste nell’utilizzo dell’istruzione SQL “CREATE SCHEMA”. Di solito tale sistema non viene utilizzato (o almeno non con gli scopi ed il significato previsti dallo standard), ma ogni DBMS prevede una procedura proprietaria per creare un database. Normalmente viene esteso il linguaggio SQL introducendo un’istruzione non prevista nello standard: “CREATE DATABASE”.<br>
La sintassi utilizzata da PostgreSQL, ma anche dai piu’ diffusi DBMS, e’ la seguente<br>:<br>
<br>
<code>CREATE DATABASE nome_database</code><br>
<br>
Una volta creato il database e’ possibile creare le tabelle che lo compogono. L’istruzione SQL preposta a questo scopo e’:<br>
<code>
CREATE table nome_tabella (<br>
nome_colonna tipo_colonna [ clausola_default ] [ vincoli_di_colonna ]<br>
[ , nome_colonna tipo_colonna [ clausola_default ] [ vincoli_di_colonna ] … ]<br>
[ , [ vincolo_di tabella] … ] )<br>
</code><br>
<b>nome_colonna</b>: e’ il nome della colonna che compone la tabella. Sarebbe meglio non esagerare con la lunghezza degli identificatori di colonna, dal momento che l’SQL Entry Level prevede nomi non piu’ lunghi di 18 caratteri. Si consulti comunque la documentazione dello specifico database. I nomi devono iniziare con un carattere alfabetico.<br>
<br>
<b>tipo_colonna</b>: e’ l’indicazione del tipo di dato che la colonna potra’ contenere. I principali tipi previsti dallo standard SQL sono:<br>
<br>
&ensp; - <b>CHARACTER</b>(n)<br>
    Una stringa a lunghezza fissa di esattamente n caratteri. CHARACTER puo’ essere abbreviato con CHAR<br>
&ensp; - <b>CHARACTER VARYING</b>(n)<br>
    Una stringa a lunghezza variabile di al massimo n caratteri. CHARACTER VARYING puo’ essere abbreviato con VARCHAR o CHAR VARYING.<br>
&ensp; - <b>INTEGER</b><br>
    Un numero intero con segno. Puo’ essere abbreviato con INT. La precisione, cioe’ la grandezza del numero intero che puo’ essere memorizzato in una colonna di questo tipo, dipende dall’implementazione del particolare DBMS.<br>
&ensp; - <b>SMALLINT</b><br>
    Un numero intero con segno con precisione non superiore a INTEGER.<br>
&ensp; - <b>FLOAT</b>(p)<br>
    Un numero a virgola mobile, con precisione p. Il valore massimo di p dipende dall’implementazione del DBMS. E’ possibile usare FLOAT senza indicazione della precisione, utilizzando quindi la precisione di default, anch’essa dipendente dall’implementazione. REAL e DOUBLE 
&ensp; - <b>PRECISION</b> <br>sono dei sinonimi per un FLOAT con una particolare precisione. Anche in questo caso le precisioni dipendono l’implementazione, 
	con il vincolo che la precisione del primo non sia superiore a quella del secondo.<br>
&ensp; - <b>DECIMAL</b>(p,q)<br>
    Un numero a virgola fissa di almeno p cifre e segno, con q cifre dopo la virgola. DEC e’ un’abbreviazione per DECIMAL. DECIMAL(p) e’ un’abbreviazione per DECIMAL(p,0). Il valore massimo di p dipende dall’implementazione.<br>
&ensp; - <b>INTERVAL</b><br>
    Un periodo di tempo (anni, mesi, giorni, ore, minuti, secondi e frazioni di secondo).<br>
&ensp; - <b>DATE, TIME e TIMESTAMP</b><br>
    Un preciso istante temporale. DATE permette di indicare l’anno, il mese e il giorno. Con TIME si possono specificare l’ora, i minuti e i secondi. TIMESTAMP e’ la combinazione dei due precedenti. I secondi sono un numero con la virgola, permettendo cosi’ di specificare anche frazioni di secondo.<br>
<br>
<b>clausola_default</b>: indica il valore di default che assumera’ la colonna se non gliene viene assegnato uno esplicitamente nel momento della creazione della riga. La sintassi da utilizzare e’ la seguente:<br>
<br>
<code>DEFAULT { valore or NULL }</code><br>
<br>
dove, valore e’ un valore valido per il tipo con cui la colonna e’ stata definita.<br>
<br>
<b>vincoli_di_colonna</b>: sono vincoli di integrita’ che vengono applicati al singolo attributo. Sono:<br>
<br>
    <b>NOT NULL</b>, che indica che la colonna non puo’ assumere il valore NULL.<br>
    <b>PRIMARY KEY</b>, che indica che la colonna e’ la chiave primaria della tabella.<br>
    una definizione di riferimento, con cui si indica che la colonna e’ una chiave esterna verso la tabella e i campi indicati nella definizione. La sintasi e’ la seguente:<br>
<code>
    REFERENCES nome_tabella [ ( colonna1 [ , colonna2 … ] ) ]<br>
    [ ON DELETE { CASCADE or SET DEFAULT or SET NULL } ]<br>
    [ ON UPDATE { CASCADE or SET DEFAULT or SET NULL } ]<br>
</code><br>
    Le clausole ON DELETE e ON UPDATE indicano quale azione deve essere compiuta nel caso in cui una tupla nella tabella referenziata venga eliminata o aggiornata. Infatti in tali casi nella colonna referenziante (che e’ quella che si sta definendo) potrebbero esserci dei valori inconsistenti. Le azioni possono essere:<br>
        <b>CASCADE</b>: eliminare la tupla contenente la colonna referenziante (nel caso di ON DELETE) o aggiornare anche la colonna referenziante (nel caso di ON UPDATE).<br>
        <b>SET DEFAULT</b>: assegnare alla colonna referenziante il suo valore di default.<br>
        <b>SET NULL</b>: assegnare alla colonna referenziante il valore NULL.<br>
    un controllo di valore, con il quale si permette o meno l’assegnazione di un valore alla colonna, in base al risultato di un espressione. La sintassi da usare e’:<br>
<br>
    <b>CHECK (espressione_condizionale)</b><br>
    dove espressione_condizionale e’ un’espressione che restituisce vero o falso.<br>
    Ad esempio, se stiamo definendo la colonna COLONNA1, definendo il seguente controllo:<br>
<br>
    CHECK ( COLONNA1 < 1000 )<br>
    in tale colonna potranno essere inseriti solo valori inferiori a 1000.<br>
<br>
<b>vincolo_di_tabell</b>a: sono vincoli di integrita’ che possono riferirsi a piu’ colonne della tabella. Sono:<br>
<br>
   la definizione della chiave primaria:<br>
<br>
<code>    PRIMARY KEY ( colonna1 [ , colonna2 … ] )</code><br>
<br>
    Si noti che in questo caso, a differenza della definizione della chiave primaria come vincolo di colonna, essa puo’ essere formata da piu’ di un attributo.<br>
    le definizioni delle chiavi esterne:<br>
<br>
<code>    FOREIGN KEY ( colonna1 [ , colonna2 … ] ) definizione_di_riferimento</code><br>
<br>
    La <b>definizione_di_riferimento</b> ha la stessa sintassi e significato di quella che puo’ comparire come vincolo di colonna.<br>
    un controllo di valore, con la stessa sintassi e significato di quello che puo’ essere usato come vincolo di colonna.<br>
Supponendo di voler creare un database incentrato su una biblioteca allora avremo delle entry così formate:
Per chiarire meglio l’utilizzo dell’istruzione CREATE table, esaminiamo alcuni comandi che implementano il database bibliografico di esempio.<br>
<br><code>
CREATE table Publication (<br>
ID INTEGER PRIMARY KEY,<br>
type CHAR(18) NOT NULL<br>
);<br></code>
<br>
La precedente istruzione crea la tabella Publication, formata dalle due colonne ID di tipo INTEGER, e type di tipo CHAR(18). ID e’ la chiave primaria della relazione. Sull’attributo type e’ posto un vincolo di non nullita’.<br>
<br><code>
CREATE table Book (<br>
ID INTEGER PRIMARY KEY REFERENCES Publication(ID),<br>
title VARCHAR(160) NOT NULL,<br>
publisher INTEGER NOT NULL REFERENCES Publisher(ID),<br>
volume VARCHAR(16),<br>
series VARCHAR(160),<br>
edition VARCHAR(16),<br>
pub_month CHAR(3),<br>
pub_year INTEGER NOT NULL,<br>
note VARCHAR(255)<br>
);<br></code>

Crea la relazione Book, formata da nove attributi. La chiave primaria e’ l’attributo ID, che e’ anche una chiave esterna verso la relazione Publication. Sugli attributi title, publisher e pub_year sono posti dei vincoli di non nullita’. Inoltre l’attributo publisher e’ una chiave esterna verso la tabella Publisher.<br>
<br><code>
CREATE table Author (<br>
publicationID INTEGER REFERENCES Publication(ID),<br>
personID INTEGER REFERENCES Person(ID),<br>
PRIMARY KEY (publicationID, personID)<br>
);<br></code>
<br>
Crea la relazione Author, composta da due attributi: publicationID e personID. La chiave primaria in questo caso e’ formata dalla combinazione dei due attributi, come indicato dal vincolo di tabella PRIMARY KEY. PublicationID e’ una chiave esterna verso la relazione Publication, mentre personID lo e’ verso la relazione Person.<br>
|
titolo£[SQL]-Popolazione del database|
linguaggio£SQL|
lezione£
Col termine “popolazione del database” si intende l’attività di inserimento dei dati al suo interno. In un database relazionale cio’ corrisponde alla creazione delle righe che compongono le tabelle che costituiscono il database.<br>
L’ordine delle operazioni non è puramente casuale, infatti l’inserimento delle righe deve essere fatto in modo da rispettare i vincoli imposti sulle tabelle. Ad esempio, dato che non potrà esistere una chiave esterna senza che sia stata prima inserita la riga a cui essa si riferisce, prima di poter inserire una riga nella tabella InProceedings dovrà essere stata inserita la corrispondente riga nella tabella Proceedings.<br>
<br>
Se accade che un vincolo viene violato, il DBMS impedisce l’operazione di inserimento facendola fallire. Si veda la lezione precedente (Creare il database) per la descrizione dei vincoli che possono essere imposti su una tabella e sulle sue colonne.<br>
<b>INSERT, inserire una riga in una tabella</b><br>
<br>
L’istruzione SQL che effettua l’inserimento di una nuova riga in una tabella è INSERT. La sintassi con cui essa viene usata piu’ comunemente è:<br>
<code>INSERT INTO nome_tabella [ ( elenco_campi ) ]<br>
VALUES ( elenco_valori )<br></code>

&ensp;<u>nome_tabella</u><br>
    è il nome della tabella in cui deve essere inserita la nuova riga;<br>
&ensp;<u>pelenco_campi</u><br>
    è l’elenco dei nomi dei campi a cui deve essere assegnato un valore, separati fra loro da una virgola. I campi non compresi nell’elenco assumeranno il loro valore di default o NULL se non hanno un valore di default. È un errore non inserire nell’elenco un campo che non abbia un valore di default e non possa assumere il valore NULL. Se l’elenco non viene specificato dovranno essere specificati i valori di tutti i campi della tabella.<br>
&ensp;<u>elenco_valori</u> <br>è l’elenco dei valori che saranno assegnati ai campi della tabella, nell’ordine e numero specificati dall’elenco_campi o in quello della definizione della tabella (se elenco_campi non viene specificato). I valori possono essere un’espressione scalare del tipo appropriato per il campo o le keyword DEFAULT o NULL, se il campo prevede un valore di default o ammette il valore NULL.<br>
<br>
Il precedente esempio di inserimento viene quindi eseguito tramite le seguenti istruzioni SQL:<br>
<br>
<code>
INSERT INTO Person VALUES ( 1, 'Agosti', 'Maristella' );<br>
INSERT INTO Person VALUES ( 2, 'Benfante', 'Lucio' );<br>
INSERT INTO Person VALUES ( 3, 'Melucci', 'Massimo' );<br>
INSERT INTO Person VALUES ( 4, 'Spaccapietra', 'S.' );<br>
INSERT INTO Person VALUES ( 5, 'Maryansky', 'F.' );<br>
 <br>
INSERT INTO Institution ( ID, name, city, country )<br>
    VALUES ( 1, '7th IFIP 2.6 Working Conference on Database Semantics (DS-7)',<br>
           'Leysin', 'Switzerland' );<br>
 <br>
INSERT INTO Publication VALUES ( 1, 'Proceedings' );<br>
INSERT INTO Publication VALUES ( 2, 'InProceedings' );<br>
 <br>
INSERT INTO Proceedings ( ID, title, organization, pub_month, pub_year )<br>
    VALUES ( 1, 'Searching for Semantics: Data Mining, Reverse Engineering',<br>
           1, 'Oct', 1997 );<br>
 <br>
INSERT INTO InProceedings ( ID, proceedingsID, title, pages )<br>
    VALUES ( 2, 1,<br>
           'OFAHIR: "On-the-Fly" Automatic Authoring of Hypertexts for Information Retrieval',<br>
           '129-154' );<br>
 <br>
INSERT INTO Author VALUES ( 2, 1 );<br>
INSERT INTO Author VALUES ( 2, 2 );<br>
INSERT INTO Author VALUES ( 2, 3 );<br>
 <br>
INSERT INTO Editor VALUES ( 1, 4 );<br>
INSERT INTO Editor VALUES ( 1, 5 );<br>
</code><br>
Un’altra forma abbastanza utilizzata dell’istruzione INSERT segue la seguente sintassi:<br>
<code>INSERT INTO nome_tabella [ ( elenco_campi ) ]<br>
    istruzione_select<br>
</code>
L’unica differenza con la precedente sintassi consiste nella sostituzione della clausola VALUES con un istruzione SELECT. L’istruzione SELECT sarà esaminata in dettaglio nella successiva lezione (Interrogare il database). Per il momento ci basti sapere che SELECT permette di estrarre dalle tabelle del database dei dati che vengono organizzati in una nuova relazione.<br>
<br>
La precedente istruzione INSERT permette quindi di inserire nella tabella e nei campi specificati dati provenienti da altre tabelle. Ovviamente, affinché l’istruzione venga eseguita con successo, i dati prodotti dall’istruzione SELECT dovranno essere compatibili con i vincoli ed i domini dei campi della tabella in cui si sta effettuando l’inserimento.<br>
|
titolo£[SQL]-la SELECT|
linguaggio£SQL|
lezione£
Nella lezione precedente abbiamo esaminato i costrutti che SQL mette a disposizione per inserire i dati in un database relazionale. In questa e nelle prossime lezioni ci concentreremo sulle istruzioni che ci permettono di estrarre i dati che ci interessano. L’istruzione SQL preposta a tale scopo è SELECT. L’interrogazione è la funzionalità più usata di un database e le clausole di cui dispone l’istruzione SELECT sono numerose e a volte possono dar luogo a combinazioni piuttosto complicate.<br>
<br>
La sintassi completa è la seguente:<br>
<code><br>
SELECT [DISTINCT ] lista_elementi_selezione<br>
FROM lista_riferimenti_tabella<br>
[ WHERE espressione_condizionale ]<br>
[ GROUP BY lista_colonne ]<br>
[ HAVING espressione_condizionale ]<br>
[ ORDER BY lista_colonne ]<br>
</code><br>
Come si vede, le uniche clausole obbligatorie sono SELECT e FROM. Quest’ultima, detta clausola di selezione, stabilisce da quale tabella (o da quali) estrarre i dati, mentre la prima è detta clausola di proiezione e stabilisce quali colonne devono essere riportate nel risultato finale.
<br>
La clausola WHERE definisce invece un filtro sulle righe che verranno analizzate, mentre ORDER BY indica l’ordinamento da applicare al risultato finale. Se WHERE non viene specificata, non viene applicato alcun filtro sulle righe, che quindi vengono esaminate tutte. Se invece non viene specificato alcun ordinamento, le righe vengono restituite senza un ordine definito, generalmente così come vengono trovate in tabella. Vedremo filtro e ordinamento in dettaglio nella prossima lezione.<br>
<br>
Nelle successive lezioni analizzeremo, invece, le clausole GROUP BY e HAVING, entrambe riguardanti le aggregazioni.<br>
<br>
Per quanto riguarda selezione e la proiezione, di cui ci occupiamo in questa lezione, vediamo subito un esempio:<br>
<br>
<code>SELECT Person.surname  FROM Person</code><br>
<br>
Questa query estrae dalla tabella Person tutti gli elementi, restituendo solamente la colonna surname. Nel nostro caso, il risultato è una tabella di 20 righe con i cognomi dei nostri autori. Si possono indicare più colonne separandole con una virgola:<br>
<br>
<code>SELECT Person.surname, Person.given_names FROM Person</code><br>
<br>
La sintassi completa prevede di specificare la colonna con la tabella di appartenenza; quest’ultima, inoltre, si può omettere se non ci sono ambiguità:<br>
<br>
<code>SELECT surname, given_names FROM Person</code><br>
<br>
Si può utilizzare l’asterisco (*) per indicare che si vogliono analizzare tutte le colonne di una tabella. Ad esempio:<br>
<br>
<code>SELECT Person.* FROM Person</code><br>
<br>
che, se non ci sono ambiguità, equivale alla forma più comunemente utilizzata:<br>
<br>
<code>SELECT * FROM Person</code><br>
<br>
È possibile anche specificare dei nomi alternativi (alias) per le colonne restituite come risultato, usando la parola chiave AS:<br>
<br>
<code>SELECT surname, given_names AS name FROM Person</code><br>
<br>
Il risultato produrrà due colonne, la prima denominata surname, e la seconda name (in virtù dell’alias definito).<br>
<br>
L’uso degli alias è particolarmente comodo quando si usano le espressioni: infatti, è possibile utilizzare espressioni SQL nella clausola di proiezione per effettuare calcoli o elaborazioni sui valori presenti nei campi. Ad esempio, la seguente interrogazione restituisce il cognome e l’iniziale del nome di ogni persona:<br>
<br>
<code>SELECT surname, SUBSTRING(given_names, 1, 1) as iniziale FROM Person</code><br>
<br>
<b>DISTINCT, eliminare i duplicati</b><br>
<br>
La prima query che abbiamo visto restituirebbe righe duplicate nel caso in cui nella tabella fossero presenti persone con lo stesso cognome. Per evitare ciò occorre specificare l’opzione DISTINCT:<br>
<br>
<code>SELECT DISTINCT surname FROM Person</code><br>
<br>
Questa opzione fa sì che nel risultato non ci siano righe uguali tra loro, ed è utile soprattutto quando si lavora con i join. Un join (congiunzione) è una funzione che stabilisce come combinare righe di due tabelle diverse per ottenere una tabella unica. Si distinguono generalmente tre tipi di join, che vediamo di seguito.<br>
<br>
<b>Inner JOIN</b><br>
<br>
Questa operazione, che in SQL è implementata dalla clausola INNER JOIN o semplicemente JOIN, combina solo le righe delle due tabelle che soddisfano un certo predicato di confronto, come in un’operazione di intersezione.<br>
<br>
Si possono effettuare confronti tra date o numeri; ad esempio per avere tutti i libri usciti dopo la data di pubblicazione di ogni articolo:<br>
<code>SELECT Book.title, Article.title<br>
  FROM Book <br>
  JOIN Article on Article.pub_year > Book.pub_year</code><br>
<br>
<b>Outer JOIN</b><br>
<br>
La query precedente restituirà solo i libri e le persone per cui esiste un collegamento. Quindi non restituirà né le persone che non hanno scritto libri né i libri senza autore. A seconda se vogliamo anche questi avremo rispettivamente un LEFT OUTER o un RIGHT OUTER JOIN. Ad esempio:<br>
<code>SELECT surname, given_names, title<br>
  FROM Person<br>
  LEFT JOIN Author on person.ID = Author.personID<br>
  LEFT JOIN Book on Book.ID = Author.publicationID <br>
</code><br>
Come si vede la parola chiave OUTER è opzionale. In questo caso, per le persone che non hanno pubblicato un libro, la colonna title avrà valore NULL.<br>
<br>
<b>Cross JOIN</b><br>
<br>
Rappresenta l’operazione sistemistica del prodotto cartesiano. Significa che per ogni riga della prima tabella vengono considerate tante righe quante ne ha la seconda combinandole. Quindi alla fine, date due tabelle rispettivamente di dimensioni N ed M, otterremo un risultato di NxM righe. Si usa questo tipo di join quando si vogliono tutte le combinazioni possibili. In SQL, per fare un cross join basta separare i nomi della tabelle con una virgola:<br>
<br>
<code>SELECT Person.surname, Publisher.name<br>
FROM Person, Publisher</code><br>
<br>
I cross join vengono usati anche quando si vogliono fare join molto particolari, non ottenibili con le altre clausole di join, specificando le condizioni nella clausola WHERE.<br>
<br>
<b>Unioni</b><br>
<br>
L’operazione sistemistica di unione si può fare in SQL utilizzando la parola chiave UNION.<br>
<br>
Ad esempio, per effettuare qualcosa di simile ad un FULL JOINcon MySQL si può scrivere:<br>
<code><br>
  SELECT surname, given_names, title  FROM Person<br>
  LEFT JOIN Author on person.ID = Author.personID<br>
  LEFT JOIN Book on Book.ID = Author.publicationID <br>
UNION<br>
SELECT surname, given_names, title  FROM Person<br>
  RIGHT JOIN Author on person.ID = Author.personID<br>
  RIGHT JOIN Book on Book.ID = Author.publicationID<br>
</code><br>
Nell’uso di UNION bisogna fare in modo che le colonne delle varie SELECT da concatenare abbiano lo stesso numero e siano dello stesso tipo altrimenti si avrà un errore.<br>
|
titolo£[SQL]-Ricerca, Filtraggio e Ordinamento|
linguaggio£SQL|
lezione£

Continuiamo con l’istruzione SELECT e stavolta vediamo le clausole WHERE e ORDER BY.<br>
<b>Filtraggio</b><br>
<br>
Già nella lezione precedente, quando abbiamo parlato di inner join, abbiamo visto un particolare tipo di filtraggio, l’intersezione tra insiemi. Ora vediamo invece come, con la clausola WHERE, possiamo filtrare le nostre righe in modo molto preciso sulla base dei valori che assumono i campi.<br>
In generale, la sintassi di questa clausola è un espressione che può essere o vera o falsa per una certa riga del nostro insieme di dati. L’espressione più semplice ovviamente è l’eguaglianza:<br>
<code>SELECT * <br>
FROM Person<br>
WHERE surname = 'Knuth'<br>
</code><br>
In questo caso verranno restituite le persone aventi un certo cognome. Usando l’operatore AND possiamo combinare due espressioni per richiedere di restituire le righe che soddisfano entrambe le condizioni:<br>
<code>SELECT * FROM Person<br>
WHERE surname = 'Knuth' AND given_names = 'Donald'<br>
</code><br>
In questo caso, nel nostro database di esempio, non avremo alcun risultato perché l’operatore di uguaglianza (=) viene soddisfatto solo se i valori sono esattamente uguali, mentre ‘Donald E.‘ è diverso da ‘Donald‘. Con l’operatore <b>LIKE</b>, utilizzabile solamente con i dati di tipo testuale come VARCHAR, possiamo invece cercare i valori che corrispondono ad un certo pattern. Si possono utilizzare due caratteri jolly:<br>
<br>
    -il carattere % verrà soddisfatto da qualsiasi sequenza di caratteri trovata;<br>
    -il carattere _ verrà soddisfatto da qualsiasi carattere (singolo) trovato.<br>
<br>
Stavolta, quindi, questa interrogazione restituirà esattamente il record di Donald E. Knuth:<br>
<code>SELECT * FROM Person<br>
WHERE surname = 'Knuth' AND given_names LIKE 'Donald%'<br>
</code><br>
Se non viene specificato alcun carattere jolly, LIKE si comporta esattamente come un’uguaglianza semplice.<br>
<br>
Si noti che MySQL supporta anche la parola chiave REGEXP, che effettua un confronto tramite espressioni regolar, molto più potenti della ricerca tramite LIKE. Oracle supporta la funzione REGEXP_LIKE. Ad esempio, con la seguente interrogazione MySQL si ottengono i libri che nel titolo contengono prima il testo “Object” poi qualsiasi carattere, quindi il testo “Oriented” e infine un testo che può essere o “Databases” o “Concepts”:<br>
<code>SELECT * FROM Book<br> 
WHERE title REGEXP 'Object.*Oriented.*(Databases or Concepts)'<br>
</code><br>
<br>
Un operatore logico (stavolta unario) importante è il NOT, utilizzato per negare una condizione:<br>
<code>SELECT * FROM Book  WHERE NOT(volume = 1)</code><br>
<br>
Contrariamente a quanto si possa pensare, questa query non restituirà né i volumi diversi dal primo, ma neanche i libri aventi il campo volume impostato a NULL. Questo perché in SQL il valore NULL è speciale nel senso che le espressioni che contengono valori nulli vengono valutate come NULL, quindi richiedono i seguenti operatori speciali:<br>
<br>
    IS NULL<br>
    IS NOT NULL<br>
<br>
Possiamo quindi riscrivere la query dell’esempio così:<br>
<code>SELECT * FROM Book  WHERE volume IS NULL OR NOT(volume = 1) </code><br>
<br>
Oppure possiamo utilizzare la funzione COALESCE che abbiamo visto nella lezione precedente:<br>
<code>SELECT * FROM Book  WHERE NOT(COALESCE(volume, 0) = 1)</code><br>
<br>
Naturalmente, si può testare anche la disuguaglianza, con gli appositi operatori:<br>
<br>
    disuguaglianza semplice: <>
    ;<br>
    minore < e minore o uguale: <=
    ;<br>
    maggiore > e maggiore o uguale: >=
    . <br>
<br>
Nel caso dei valori testuali, come CHAR e VARCHAR, l’ordinamento è quello alfabetico in base alla codifica scelta per il database.<br>
<br>
L’operatore <b>BETWEEN</b> è comodo per cercare valori in un intervallo, ad esempio di date, ma può essere usato anche con gli altri tipi. L’intervallo si intende chiuso (con gli estremi); quindi con la seguente interrogazione avremo anche i libri pubblicati nel 1980 e nel 1993:<br>
<code>SELECT title, pub_year<br>
FROM Book<br>
WHERE pub_year BETWEEN 1980 AND 1993</code><br>
<br>
<b>Ordinamento</b><br>
<br>
Per ordinare i risultati di una query si usa la clausola ORDER BY, seguita dalle espressioni da valutare per effettuare l’ordinamento. Ad esempio:<br>
<code>SELECT title, series, pub_year FROM Book<br>
ORDER BY title</code><br>
<br>
Questa query restituisce i libri pubblicati in ordine di titolo;<br>
|
titolo£[SQL]-GROUP BY e funzioni di aggregazione|
linguaggio£SQL|
lezione£
 Con la parola chiave DISTINCT, nella lezione precedente, abbiamo visto la forma più semplice di aggregazione: quella che distingue le righe uguali riportandole quindi una sola volta. L’esempio ivi riportato è, infatti, riscrivibile utilizzando la clausola GROUP BY; in altre parole, le seguenti due istruzioni sono equivalenti:<br>
<code>SELECT DISTINCT surname FROM Person</code><br>
<code>SELECT surname FROM Person GROUP BY surname</code><br>
<br>
Se le eseguiamo nel nostro database di esempio, otteniamo dunque gli stessi risultati. La clausola GROUP BY serve a specificare quali sono i campi sui cui effettuare i raggruppamenti: il motore di query, per ogni riga esaminerà tali campi e la classificherà nel gruppo corrispondente. Si possono specificare calcoli da effettuare per ogni gruppo. Ad esempio la query seguente restituisce, per ogni gruppo (surname), il numero di occorrenze trovate, cioè quante persone hanno quel cognome: <br>
<br>
<code>SELECT surname, COUNT(*)<br>
FROM Person <br>
GROUP BY surname<br>
</code><br>
In questo caso il motore raggruppa le righe in base al cognome, e per ogni gruppo effettua il conteggio di quanti elementi sono presenti nel gruppo.<br>
<br>
Da quanto detto, possiamo desumere una naturale limitazione di SQL: se viene specificata una clausola GROUP BY, allora nella clausola SELECT deve esserci:<br>
<br>
   - o un campo specificato nella clausola GROUP BY;<br>
   - oppure una funzione di aggregazione.<br>
<br>
Questo perché quando il motore aggrega le righe deve sapere come comportarsi per ogni campo da restituire. <br>
<br>
<b> Funzioni di Aggregazione</b><br>
 Le funzioni di aggregazione sono particolari funzioni che operano su più righe. In generale, non tutti i database supportano le stesse funzioni, per cui è bene riferirsi alle guide ufficiali. Ad esempio MySql fornisce la funzione GROUP_CONCAT, che non è invece supportata su Oracle.<br>
<br>
Le funzioni più comuni sono:<br>
<br>
    -<b>COUNT</b> per effettuare conteggi nel gruppo;<br>
    -<b>SUM</b> per le somme;<br>
    -<b>MAX</b> e <b>MIN</b>;<br>
    -<b>AVG</b> per calcolare la media.<br>
<br>
<b>La funzione COUNT</b><br>
<br>
Questa funzione può essere invocata in tre modi. Il più semplice COUNT(*) l’abbiamo già visto: effettua il conteggio di tutte le righe presenti nel gruppo, indipendentemente dai valori assunti. Può essere usato anche senza GROUP BY, per calcolare le righe totali presenti in una tabella:<br>
<br>
<code>SELECT COUNT(*) FROM Person </code><br>
<br>
Se tra le parentesi specifichiamo un’espressione, verranno contate solo le righe che hanno quell’espressione non nulla. Ad esempio la seguente query raggruppa i libri per anno di pubblicazione, contando quanti sono e quanti sono stati suddivisi per volume.<br>
<br>
<code>SELECT pub_year, COUNT(*), COUNT(volume)<br>
FROM Book<br>
GROUP BY pub_year<br>
</code><br>
<br>
Se prima dell’espressione indichiamo la parola chiave DISTINCT verranno conteggiate solo le espressioni non nulle e distinte. In questo caso, in cui abbiamo due tabelle in join, avremo come risultato il numero di redattori per ogni libro. Avremo vedremo uno 0 nel caso in cui il libro non ha specificato nessun redattore nel database.<br>
<br>
<code><br>
SELECT Book.title, COUNT(DISTINCT personID)<br>
FROM Book<br>
LEFT JOIN Editor ON book.ID = Editor.publicationID<br>
GROUP BY Book.id, Book.title</code><br>
<br>
<b>La funzione SUM</b><br>
<br>
Questa funzione somma i valori dei campi trovati nel gruppo. I valori nulli vengono ignorati, contrariamente a quanto farebbe una somma semplice.<br>
<code>SELECT Person.surname, SUM(Book.pages)<br>
FROM Book<br>
JOIN Editor ON book.ID = Editor.publicationID<br>
JOIN Person ON Editor.personID = Person.ID<br>
GROUP BY Person.ID, Person.surname<br>
</code><br>
Questa interrogazione restituisce il numero di pagine totale editate da ogni redattore.<br>
<br>
<b>Le funzioni MIN, MAX e AVG</b><br>

Con queste funzioni si possono ottenere i valori massimo e minimo di una colonna, in base al criterio di ordinamento predefinito (ad esempio per il testo verrà usato un ordinamento alfabetico). I valori nulli vengono ignorati.<br>
<br>
Naturalmente più funzioni possono essere usate nella stessa query. La seguente restituisce, per ogni anno di pubblicazione, il primo titolo in ordine alfabetico, il numero di libri pubblicati, la media del numero di pagine e il numero di pagine del libro più grande:<br>
<code>SELECT Book.pub_year, MIN(title), COUNT(*), AVG(pages), MAX(pages)<br>
FROM Book<br>
GROUP BY pub_year</code><br>
<br>
|
titolo£[SQL]-Modificare i dati|
linguaggio£SQL|
lezione£
Dopo aver visto le modalità per inserire dati nel database e per interrogarlo, passiamo in rassegna le istruzioni per modificarne i dati.<br>
Il comando UPDATE<br>
<br>
Il comando <b>UPDATE</b> serve a modificare dati già inseriti nelle tabelle del database. La sua sintassi è la seguente:<br>
<code>UPDATE nome_tabella<br>
SET nomeCampo1 = <valore1> [,nomeCampoX = <valoreX>]*<br>
[ WHERE predicato ]</code><br>
<br>
Il significato del comando è quello di modificare i campi indicati nella clausola SET delle righe della tabella nome_tabella che soddisfano il predicato indicato nella clausola WHERE. Su quest’ultima non ci dilunghiamo perché per essa valgono le stesse considerazioni fatte per il comando SELECT. Diciamo soltanto che se viene omessa, l’aggiornamento avverrà su tutte le righe della tabella. Di conseguenza bisogna porre particolare attenzione al momento del lancio di questo comando.<br>
<br>
L’utilizzo tipo è la modifica di un singolo record, utilizzando l’id:<br>
<code>UPDATE Person SET given_names = 'Stefano' WHERE ID = 4</code><br>
<br>
Possiamo fare modifiche massive, ad esempio mettendo a 1 il valore del campo volume di tutti i record dove tale campo assume il valore nullo:
<code>UPDATE Book SET volume = 1, note='1 solo volume'  WHERE volume IS NULL</code><br>
|
titolo£[SQL]-Eliminare i dati|
linguaggio£SQL|
lezione£
L’istruzione DELETE permette di eliminare i record di una tabella che soddisfano un certo predicato:<br>
<code>DELETE FROM nome_tabella<br>
[ WHERE predicato ]<br>
</code><br>
Anche in questo caso non ci dilunghiamo sulla clausola WHERE, per la quale vale la considerazione fatta sopra: se viene omessa, l’eliminazione avverrà su tutte le righe della tabella. Quindi occorre prestare particolare attenzione con la specificazione della clausola, anche per verificare che si specifichino solo i record che si vogliono eliminare.<br>
<br>
Se sussistono delle chiavi esterne sui record che vengono specificati, e se nei vincoli non sono state specificate azioni in caso di cancellazione con la clausola ON DELETE (come visto nella lezione sulla creazione del database), allora l’annullamento fallirà. Ad esempio questa query fallirà a causa del riferimento del record nella tabella Book:<br>
<code>DELETE  FROM Publisher WHERE ID = 1</code><br>
<br>
Se invece, ad esempio, fosse stata specificata la clausola ON DELETE CASCADE nella definizione della tabella Book, anche i libri che avessero riferimento a questo editore sarebbero stati cancellati nella stessa transazione.<br>
|
titolo£[SQL]-Transazioni|
linguaggio£SQL|
lezione£
Le singole istruzioni INSERT, UPDATE e DELETE sono atomiche nel senso che o hanno successo totale (su tutte le righe coinvolte) o falliscono totalmente senza alcun effetto sul database.<br>
<br>
È possibile combinare più istruzioni in una singola transazione atomica. Ad esempio, in Oracle o in MySQL:<br>
<code><br>
START TRANSACTION;<br>
   DELETE FROM Book WHERE Publisher = 1;<br>
   DELETE FROM Publisher WHERE ID = 1<br>
COMMIT;<br>
</code><br>
Con questo script viene eliminato l’editore con ID pari a 1, ma prima vengono eliminati i libri pubblicati da esso. Racchiudendo il blocco tra <b>START TRANSACTION</b> e <b>COMMIT TRANSACTION</b>, si fa in modo di rendere tutto il blocco atomico: o avvengono con successo entrambe le istruzioni oppure in caso di errore tutto resta invariato. Con l’istruzione ROLLBACK, invece, si forza il fallimento della transazione, lasciando il database allo stato consistente.<br>
<br>
<b>Livello di isolamento delle transazioni</b><br>

A proposito delle transazioni, soprattutto se esse sono lunghe, è importante sapere quale livello di isolamento stiamo usando. Il livello di isolamento stabilisce come transazioni contemporanee si comportano rispetto ai dati. Ogni RDBMS ha un livello di isolamento di default e generalmente si può stabilire un livello differente per sessione o per transazione. Lo standard ANSI/ISO stabilisce quattro livelli di isolamento, generalmente implementati da tutti i RDBMS:<br>
<br>
    -<b>Serializable</b>. È il massimo livello di isolamento: ogni transazione, dall’inizio alla fine, non vede le modifiche fatte ai dati acceduti. Il vantaggio è che la transazione può lavorare sul database assumendo di essere la sola transazione in corso sul database. Un modo di realizzare questo livello è l’approccio ottimistico: ogni transazione lavora in isolamento, poi, se accadono problemi di concorrenza, la transazione che tenta di agire su un dato modificato da altre transazioni fallirà con un errore e con conseguente rollback. Lo svantaggio è che ci possono essere molte scritture fallite se ci sono tante transazioni che interessano gli stessi dati.<br>
    -<b>Repeatable Read</b>. Con questo livello si fa in modo che i dati letti durante la transazione in corso non possono essere modificati da altre transazioni per tutta la durata della transazione in corso. I vari RDBMS gestiscono questo livello utilizzando i lock in lettura sulle righe lette durante la transazione. L’unico problema che può succedere con questo livello consiste nel verificarsi delle cosiddette letture fantasma: se rieseguo la stessa query durante la transazione, potrei trovare righe in più di quelle che ho letto in precedenza, ma mai in meno o modificate. Lo svantaggio di questo livello è una penalizzazione delle prestazioni se ci sono molte transazioni concorrenti che agiscono sulle stesse tabelle. Questo è il livello di default per MySQL.<br>
    -<b>Read Committed</b>. Utilizzando questo livello, invece, si evitano i lock in lettura sulle tabelle che sono molto onerosi dal punto di vista prestazionale. Lo svantaggio è che, oltre al fenomeno delle letture fantasma, si verifica anche quello delle letture non ripetibili: in pratica, rieseguendo due volte la stessa SELECT nel corso di una transazione, potrei ottenere dati diversi se altre transazioni sono terminate nel tempo intercorso tra le due letture. Questo è il livello di default per Oracle e per Microsoft Sql Server.<br>
    -<b>Read Uncommitted</b>. Questo è il livello più basso, in pratica nessun isolamento. Con questo livello si possono avere letture sporche: nella transazione corrente si possono leggere dati che qualche altra transazione sta scrivendo in quel momento senza aver ancora fatto COMMIT, quindi può capitare di leggere chiavi violate, dati inconsistenti, eccetera.<br>
<br>
Ovviamente non esiste il livello migliore di isolamento, generalmente il livello di default è valido nella maggior parte dei contesti. Gli RDBMS supportano gli altri livelli per gestire casi particolari di utilizzo in concorrenza.<br>
|
titolo£[HTML]-Introduzione|
linguaggio£HTML|
lezione£ La sigla <b>HTML</b> è l'acronimo di HiperText Markup Language e
tradotto letteralmente indica un "linguaggio a marcatori per
l'ipertesto". In pratica è un linguaggio di scripting che contiene
anche la formattazione del testo, ossia i codici che indicano come e
dove deve essere scritta una parte di testo. L'HTML è un linguaggio
sviluppato su piattaforme incrociate, e quindi funziona (e viene
letto) su qualunque piattaforma, su qualunque tipo di computer e
con qualunque sistema operativo.<br>
L'HTML è più che sufficiente a realizzare un sito web, senza l'ausilio
di altri linguaggi di scripting o di programmazione e altre tecniche
di implementazione, come javascript, Java, CSS, PHP, ASP o il più
recente DHTML, l'HTML dinamico; certamente mediante questi
ulteriori strumenti si potrà ottenere una migliore disposizione degli
oggetti all'interno della pagina e soprattutto una maggiore
interattività tra la pagina e gli utenti, ma gli strumenti che l'HTML
ci mette a disposizione costituiscono una discreta attrezzatura per
realizzare anche un sito web coi fiocchi.<br>
Un ipertesto è un documento che ha la possibilità di una lettura
non lineare, ossia è possibile saltare arbitrariamente da un
argomento all'altro selezionando alcuni collegamenti disposti
all'interno delle pagine, e ha la possibilità di visualizzare immagini,
suoni o animazioni, elementi multimediali insomma.
Questa possibilità ha favorito lo sviluppo del WWW (World Wide
Web) ossia Internet a livello mondiale.<br>
Per creare una pagina html è sufficiente avere un qualsiasi editor di testo
come "Blocco note" o Notepad senza dover necessariamente ricorrere all'utilizzo
di più complessi editor come EditPlus o UltraEdit.<br>
Il secondo strumento fondamentale è un browser web (come Google Chrome, Mozilla Firefox,
Internet Explorer ecc) che ci consentirà di visualizzare la nostra pagina html e
il posizionamento degli elementi all'interno di essa.<br>|


titolo£[HTML]-Tag fondamentali|
linguaggio£HTML|
lezione£ I <b>TAG</b> sono i comandi che definiscono la struttura di una pagina
HTML e che permettono una corretta visualizzazione da parte del
browser; si riferiscono al titolo della pagina, al colore e alle
impostazioni dei caratteri e dello sfondo, all'impostazione del testo,
delle immagini e dei collegamenti ipertestuali e in pratica
permettono di visualizzare e gestire tutto quello che si vuole far
vedere o tenere nascosto nella pagina.<br>
I tag sono racchiusi tra parentesi angolari ( <b> < </b> e <b> > </b> ) e possono
essere digitati indifferentemente sia in minuscolo che in maiuscolo;
la maggior parte dei tag ha anche un tag correlato che ne indica il
termine e si scrive anteponendo al nome del tag il simbolo slash
"/"; i due tag formano una coppia e si chiamano tag di apertura e
chiusura. Ad esempio, i tag che indicano l'inizio e la fine di un
paragrafo si indicano con <code>< P ></code> e <code>< /P ></code>.<br>
I tag fondamentali sono quelli che servono a far capire al browser
che quello è un documento HTML, e che deve essere trattato nel
modo appropriato. Un documento HTML è tutto ciò che è contenuto
nei due tag <code>< HTML ></code> e <code></ HTML ></code>. Questi due tag sono
generalmente il primo e l'ultimo di ogni documento HTML, e le
prime versioni dei browser ignoravano qualunque cosa fosse
all'esterno di questi tag, gli attuali browser, invece, sono molto più
elastici, e provano ad interpretare qualunque documento come un
documento HTML, per cui se si scrive qualcosa (del testo o anche
dei comandi) all'esterno di questi tag, questo viene comunque
riportato sullo schermo. Gli attuali browser sono così robusti che
una pagina HTML viene visualizzata "correttamente" anche se i tag
< HTML > e < /HTML > mancano del tutto.
Un documento HTML si compone di due parti: una <b>intestazione</b> e
un <b>corpo</b>, in inglese rispettivamente <b>header</b> e <b>body</b>.<br> 
L'header è un contenitore di informazioni, e racchiude tutte le specifiche, i
parametri e le funzioni che non sono utili direttamente all'utente
finale, ossia il lettore, ma che vengono utilizzate dai browser, dai
motori di ricerca e da tutti quei programmi in grado di leggere un
file HTML, per poter meglio gestire il documento. Il body è la parte che 
effettivamente contiene tutte le cose che vengono visualizzate o che servono 
ad impostare la visualizzazione degli oggetti.<br>
L'<b>intestazione</b> di un documento HTML è quella parte di codice
compresa tra i due tag <code>< HEAD ></code> e <code>< /HEAD ></code>, e che quindi
contiene quei tag utili ai browser, ai server web e ai motori di
ricerca.
Questa sezione contiene il titolo della pagina, e che è
generalmente il primo tag dell'intestazione. Una pagina potrebbe
avere per esempio per titolo "Corso di HTML - I TAG fondamentali"
e ciò sarebbe visibile nella barra del titolo della finestra del
browser (la riga azzurra in alto). I tag che specificano il titolo della
pagina sono <code>< TITLE ></code> e <code>< /TITLE ></code>. Nella sezione di header sono
contenuti anche i META-TAG, che portano informazioni aggiuntive
per il server web, e per i motori di ricerca che così possono
classificare il documento senza caricarlo completamente in
memoria. L'header è inoltre utilizzato per definire particolari
funzioni di script che verranno utilizzate all'interno del documento
per dare un tocco di interattività alla pagina HTML.<br>
Il <b>corpo</b> del documento contiene l'insieme del testo che deve
venire visualizzato e i tag che fanno in modo da dare a quel testo
una forma ben precisa, aggiungendo anche grafica, suono ed
elementi multimediali; il tag utilizzato per la sezione del corpo del documento 
è <code>< BODY ></code> e <code>< /BODY ></code>.<br><br>
Esempio della struttura di un documento HTML:<br><br>
<code>< html ><br>
< head ><br>
< title > Titolo del documento< /title ><br>
...<br>
< /head ><br>
< body ><br>
...<br>
< /body ><br>
< /html ><br>|



titolo£[HTML]-I Meta Tag|
linguaggio£HTML|
lezione£ I <b>meta-tag</b> sono pseudo-comandi che non hanno un'azione diretta
nei confronti della pagina, ma hanno il fine di migliorare i rapporti
con i programmi con cui la pagina si relaziona, come il browser, il
server web o i motori di ricerca.<br>
I meta-tag sono identificati dal tag <code>< META ... ></code> e non hanno il tag
correlato < /... >; sono infatti dei veicoli di informazioni, e le
informazioni sono portate da ciascun comando < META ... >; al
posto dei puntini vanno inseriti gli attributi dei meta-tag, che
possono essere <b>HTTP-EQUIV</b>, <b>NAME</b> e <b>CONTENT</b>. Non
entreremo molto nel dettaglio, ma ci limiteremo ad
introdurne alcuni e a spiegarne il significato.<br>
<code>< META HTTP-EQUIV="Content-Type" CONTENT="text/html;
charset=windows-1252" ></code> 
indica che il contenuto del documento è di tipo html e usa quel
particolare set di caratteri.<br>
<code>< META HTTP-EQUIV="Set-Cookie"
CONTENT="ID=EiG4HtfyyUIyf; path=/" ></code> 
specifica al server web in quale cartella disporre un eventuale
cookie, quei file che vengono posti sul computer del visitatore e
che servono a monitorare la navigazione e a memorizzare
elementi.<br>
<code>< META HTTP-EQUIV="Content-Language" CONTENT="It" ></code>
indica che la pagina è in italiano (utile ai motori di ricerca).<br>
<code>< META HTTP-EQUIV="Refresh" CONTENT="25;
URL="http://www.thecoder.it" ></code> 
è un comando molto utile per dare un certo dinamismo che
permette di caricare automaticamente una ulteriore pagina dopo
che questa pagina è stata caricata. Il numero 25 indica i secondi
che devono passare prima di caricare la nuova pagina.
URL="http://..." specifica la nuova pagina da caricare. Utile per
reindirizzare automaticamente il visitatore da una pagina ad
un'altra.<br>
<code>< META NAME="Generator" CONTENT="FrontPage" ></code> 
indica il programma utilizzato per creare il documento.<br>
<code>< META NAME="Description" CONTENT="Questo sito fornisce
di corsi di linguaggi di programmazione" ></code>
fornisce una descrizione del documento (utile ai motori di ricerca).<br>
<code>< META NAME="Keywords" CONTENT="guida di html, html,
imparare l'html ..." ></code> 
contiene un elenco di parole chiave utili ai motori di ricerca e ad
eventuali utenti per cercare il documento su internet.<br>
<code>< META NAME="Author" CONTENT="Mario Rossi" ></code>
specifica l'autore del documento.<br>
<code>< META NAME="Reply-To" CONTENT= mariorossi@gmail.com ></code> 
indica la email dell'autore, alla quale si vuole essere contattati per
chiarimenti.<br>
Naturalmente esistono moltissimi altri parametri da attribuire ai
meta-tag, di più o meno vaga utilità.<br>|



titolo£[HTML]-Impostazione della pagina|
linguaggio£HTML|
lezione£ Il tag che definisce la pagina, o meglio il corpo del documento
HTML è <code>< BODY ... ></code> e <code>< /BODY ></code>, dove al posto dei puntini ci
possono essere dei parametri opzionali e che permettono di
impostare la pagina; sarà di quei parametri, detti <b>attributi</b>, che si
occuperà questa lezione.<br>
Gli attributi presenti nella definizione del corpo della pagina sono
quelli che definiscono la distanza del testo dai bordi della finestra,
il colore e le proprietà dello sfondo della pagina, il tipo di testo
utilizzato e il colore dei collegamenti ipertestuali; possono essere
presenti dei comandi che servano ad attivare funzioni di script
definite nell'intestazione del documento. Vediamo in dettaglio tutti
questi parametri.<br>
<code>< BODY BGCOLOR="#BBBBBB" ></code> imposta lo il colore di fondo
della pagina, a tinta unita, in questo caso grigio chiaro; il simbolo
<b>#</b> indica che il colore è espresso in esadecimale come
combinazione dei tre colori rosso, verde e blu, 2 numeri per colore.
Avremmo anche potuto usare la dicitura <code> BGCOLOR=lightgray </code>
ma ogni browser ha le proprie impostazioni e specificando il colore
direttamente col proprio valore numerico si ottiene il colore esatto
per ciascun visualizzatore. Volendo usare uno sfondo blu si
imposta <code> BGCOLOR="#0000FF" </code>.<br>
<code>< BODY BACKGROUND="immagini/sfondo1.jpg" ></code> imposta lo
sfondo della pagina come una serie di immagini "sfondo1.jpg"
messe una affianco all'altra. Come vediamo dalla sintassi del
comando, l'immagine di sfondo è un file, residente eventualmente
in un'altra cartella; essendo un file, che viene trasferito in rete
insieme alla pagina, sarebbe bene scegliere un file piuttosto
leggero, in modo che venga trasferito prima: una pagina caricata
velocemente è apprezzata di più.<br>
<code>< BODY BACKGROUND="immagini/sfondo1.jpg"
BGPROPERTIES="fixed" ></code> 
imposta lo sfondo della pagina come una immagine particolare e lo
fissa alla finestra e non lo fa scorrere insieme al testo su e giù per
la pagina; con questo parametro sarà solo il testo a scorrere
all'interno della finestra, sopra allo sfondo.<br>
<code>< BODY TEXT="#000080" ></code> specifica il colore predefinito del
testo all'interno della pagina (in questo esempio, blu scuro); se
nella pagina sarà presente del testo privo di formattazione, ad
esso sarà dato il colore definito.<br>
<code>< BODY LINK="#0000FF" ></code> specifica il colore predefinito dei
collegamenti ipertestuali (vedremo in seguito cosa sono);
generalmente sono di colore azzurro ("#0000FF") oppure
personalizzati dall'utente mediante le impostazioni del browser.<br>
<code>< BODY VLINK="#FF00FF" ></code> specifica il colore predefinito dei
collegamenti ipertestuali già visitati; generalmente sono di colore
viola ("#FF00FF") oppure personalizzati dall'utente mediante le
impostazioni del browser.<br>
<code>< BODY ALINK="#FF0000" ></code> specifica il colore predefinito dei
collegamenti ipertestuali appena cliccati ma la cui pagina non è
ancora stata caricata; generalmente sono di colore rosso
("#FF0000") oppure personalizzati dall'utente mediante le
impostazioni del browser.<br>
<code>< BODY ONLOAD=getimages(); ></code> specifica (in questo caso) una
funzione da implementare quando viene caricata la pagina. Di
funzioni ne esistono tante quanto è vasta la fantasia umana e
vengono chiamate mediante script o applicazioni CSS o javascript che vedremo in altri corsi.<br>|



titolo£[HTML]-Impostazione del testo|
linguaggio£HTML|
lezione£ Il contenuto di un sito web è essenziale per una sua buona
riuscita. Altrettanto essenziale è il modo in cui questo contenuto
viene esposto e mostrato.
Un testo lungo e articolato, sebbene interessante, perde interesse
se mostrato senza una degna struttura e impaginazione; l'uso del
colore, di tabulazioni, di indentazioni, etc..., rende più leggibile
anche il testo più complicato. È per questo che prima di definire
quali caratteri usare, di che dimensione e colore descriviamo come
impaginare e posizionare il testo all'interno di una pagina Web.
L'HTML dispone di TAG che consentono di costruire un layout
(visualizzazione) abbastanza preciso del testo, permettendoci di
disporlo come lo si vuole, utilizzando titoli, paragrafi, separatori e
interlinee.<br>
Il tag <code>< Hn ></code> definisce un titolo. Il simbolo n viene sostituito da un
numero da 1 a 6 che indica la dimensione del titolo; <code>< H1 ></code> è il più
grande e <code>< H6 ></code> il più piccolo. Il tag <code>< Hn ></code> ha l'attributo ALIGN,
opzionale, che permette di dare l'allineamento al titolo; i valori
possibili sono "left", "center", "right" e "justify", ma
quest'ultimo ha poco senso, parlando di un titolo. L'attributo
predefinito è l'allineamento a sinistra, "left", e può omettersi; la
sintassi corretta, per un titolo di grandezza 2 allineato al centro, è
<code>< H2 ALIGN="center" ></code>.<br>
Il tag <code>< DIV ></code> è utilizzato per raggruppare vari elementi isolati
(testo, immagini e così via) in una singola unità, alla quale si vuole
applicare la stessa formattazione (di solito l'allineamento); esso
riconosce l'attributo ALIGN, con gli stessi valori del tag <code>< Hn ></code>;
riconosce anche l'attributo ID="nome" utile nei fogli di stile CSS,
insieme al tag <code>< STYLE ></code> che vedremo più avanti, per identificare
loggetto allinterno della pagina.<br>
Il tag <code>< P > ... < P ></code>indica un paragrafo (inizio e fine); ad un
paragrafo viene sempre anteposta una interlinea di una riga e
mezza e ad esso segue un'altra interlinea di una riga e mezza. Due
paragrafi successivi appaiono separati da una sottile striscia vuota.
Esattamente come per i tag precedenti riconosce l'attributo
ALIGN, con gli stessi valori, il valore predefinito è ALIGN="left"
e può omettersi. Il tag <code>< P ></code> può essere usato anche da solo
(senza il tag di chiusura <code>< /P ></code>), purché si inizi il paragrafo
successivo con un altro <code>< P ></code> altrimenti il browser suppone di stare
ancora nel paragrafo corrente.<br>
Il tag (o meglio il comando di markup) <code>< BR ></code> equivale
esattamente a un ritorno a capo. Non contiene attributi degni di
nota e non ha tag di chiusura. Esso manda a capo il testo
interponendo una interlinea singola.<br>
Il tag <code>< DIR ></code> inserisce una tabulazione. Le tabulazioni in HTML
hanno un valore fisso (in genere una 80-ina di pixel a seconda del
browser) e non possono essere modificate. Le tabulazioni possono
essere inserite una dentro l'altra per ottenere una tabulazione
doppia, tripla, etc...<br>
Il tag <code>< BLOCKQUOTE ></code> è identico al tag <code>< DIR ></code> e inserisce una
tabulazione, dello stesso valore. Le tabulazioni possono essere
inserite una dentro l'altra per ottenere una tabulazione doppia,
tripla, etc...<br>
Il tag <code>< HR ></code> inserisce una riga orizzontale (di solito con una
ombreggiatura) di separazione tra due paragrafi consecutivi; non
c'è il tag di chiusura e riconosce 4 attributi: ALIGN che definisce
l'allineamento della riga con gli stessi valori dei tag precedenti (il
valore predefinito è ALIGN="center"); WIDTH indica la
lunghezza in pixel della linea, se questo numero è seguito dal
simbolo % allora si tratta di una percentuale della larghezza della
colonna; SIZE indica lo spessore in pixel della linea; NOSHADE
(senza parametri) elimina l'ombreggiatura.<br>|



titolo£[HTML]-Formattazione del testo|
linguaggio£HTML|
lezione£ Per scrivere in <b>grassetto</b> si usa il tag contenitore <code>< B ></code> (oppure si
può anche usare <code>< STRONG ></code>, è lo stesso); la lettera B è
l'iniziale della parola bold, grassetto appunto.
Per scrivere in <i>corsivo</i> si usa il tag contenitore <code>< I ></code> (oppure si può
anche usare <code>< EM ></code>); è l'iniziale della parola italic. Tag equivalenti,
anche se nati con un significato logico diverso, sono <code>< CITE ></code>
oppure <code>< ADDRESS ></code>.<br>
Per scrivere in <u>sottolineato</u> si usa il tag contenitore <code>< U ></code> e <code>< /U ></code>;
tutto il testo compreso tra i due tag verrà visualizzato come
sottolineato. Alcuni editor di pagine web sono soliti utilizzare il tag
<code>< U ></code> per evidenziare la sottolineatura nei collegamenti
ipertestuali; tale sottolineatura è in genere già predisposta, ma
può essere tolta con un piccolo artifizio in CSS.<br> 
Nella lezione precedente, abbiamo
visto come l'HTML ignora i tradizionali separatori, lo spazio e il
ritorno a capo; un modo per restituire a questi separatori la loro
solita funzione è mediante il tag <code>< PRE ></code>. Il testo viene scritto in
carattere Courier, dimensione 10, e rappresentato con la stessa
formattazione utilizzata durante la scrittura del codice HTML,
compresi spazi, tabulazioni e ritorni a capo. A questo testo
preformattato è possibile anche dare una formattazione diversa,
utilizzando in combinazione anche gli altri comandi illustrati in
questo capitolo.<br>
Il tipo di carattere predefinito per il testo preformattato è il
Courier, ma può dunque essere cambiato. Esistono altri modi per
ottenere il carattere Courier, mediante i tag <code>< TT ></code>, <code>< CODE ></code>,
<code>< KBD ></code> e <code>< SAMP ></code>. Questi tag sono tut ti equivalenti e con
l'avvento delle tabelle il loro uso è diventato raro.
È possibile aumentare o diminuire la dimensione dei caratteri da
visualizzare; i tag <code>< BIG ></code> e l'altro <code>< SMALL ></code> rispettivamente
consentono di <big>aumentare</big> e <small>diminuire</small> di un punto le dimensioni del
carattere.<br>
Infine il comando più completo e più pratico, ed in effetti quello
che si utilizza di più per dare una formattazione al testo, il tag
<code>< FONT ></code>. Scritto così non ha alcun effetto sul testo, ma questo
tag accetta diversi attributi. L'attributo <code>FACE="..."</code> indica il tipo di
carattere da utilizzare, se il computer su cui si sta guardando la
pagina web non ha installati i tipi di carattere in questione prova
ad utilizzarne uno simile o quelli che ha come predefiniti (in genere
il "Times New Roman"). La dimensione del carattere può essere
specificata con l'attributo <code>SIZE="n"</code>, in cui n rappresenta un
valore assoluto (da 1 a 7) oppure un valore relativo (da -2 a +4)
in relazione alla dimensione corrente del carattere. <code>SIZE="1"</code>
indica il carattere più piccolo. Infine l'attributo <code>COLOR="..."</code>
determina il colore del carattere; al posto dei puntini va il nome o
il numero del colore (espresso come striga esadecimale nelle
combinazioni di rosso, verde e azzurro). Ad esempio il colore rosa
pallido può essere indicato sia con <code>COLOR="RosyBrown"</code> che
con <code>COLOR="#BC8F8F"</code>. <br>|



titolo£[HTML]-Inserimento di immagini|
linguaggio£HTML|
lezione£ Il tag necessario per l'inserimento di una immagine è <code>< IMG ></code> che
non ha tag di chiusura, una volta inserita l'immagine non ha senso
dire al browser dove l'immagine finisce.<br>
Il tag <code>< IMG ></code> scritto da solo non ha però alcun effetto sulla
pagina; esso riconosce alcuni attributi, di cui uno è obbligatorio:
occorre specificare qual'è l'immagine da inserire. L'attributo
SRC="..." indica il percorso dellimmagine da caricare; può essere
assoluto, e quindi essere del tipo
<code>SRC="http://www.sito.it/cartella/immagine.gif"</code>
oppure, se limmagine si trova ospitata sullo stesso sito, può
essere relativo, del tipo SRC="cartella/immagine.gif";
l'importante è specificare il percorso corretto.
Una precisazione importante riguardo ai nomi delle immagini e in
generale di qualunque file. I server di tipo Unix/Linux fanno
distinzione tra nomi MAIUSCOLI e minuscoli, è bene fare attenzione sul tipo di 
carattere che si usa, e nel dubbio preferire
l'uso del carattere minuscolo.<br>
Quindi ci sono gli attributi opzionali, ma che servono se si vuole
dare una impostazione diversa all'immagine introdotta. Se si carica
la pagina web su un browser in cui lo scaricamento delle immagini
è stato disattivato (per ragioni di velocità dei collegamenti, ma la
pagina sembrerà più spoglia) è possibile non privare gli utenti di
tutte le informazioni; l'attributo <code>ALT="..."</code> permette di inserire un
testo alternativo al posto dell'immagine. Questo testo viene
visualizzato quando si passa sopra l'immagine con il mouse,
quando l'immagine manca oppure quando si utilizza un browser
testuale.<br>
Gli attributi <code>WIDTH="x"</code> e <code>HEIGHT="y"</code> determinano le
dimensioni della immagine, in larghezza e in altezza. I numeri x e
y possono essere sia numeri assoluti ed in tal caso indicano il
numero di pixel che misura l'immagine, oppure una percentuale
della dimensione della finestra. Se questi attributi sono assenti
l'immagine viene mostrata alla sua grandezza naturale. Se è
presente uno solo dei due attributi, l'altro si adegua in
proporzione.<br>
Su alcuni browser è implementato anche l'attributo STYLE="..."
che racchiude questi due attributi in uno solo; la sua sintassi è:
STYLE="height:x; width:y".
L'attributo <code>BORDER="x" indica lo spessore in pixel della cornice
che si vuole mettere attorno all'immagine; il colore del bordo è
nero; se è assente, l'immagine viene visualizzata senza bordo
aggiuntivo.<br>
L'attributo <code>ALIGN="..."</code> è qui più complesso che negli altri tag in
cui compariva. Può avere i seguenti valori: "left", "right",
"bottom", "top" e "middle" (oppure "absmiddle"); ce ne sono
altri, ma hanno lo stesso significato di questi ultimi tre. I valori
"left" e "right" indicano che l'immagine è messa alla sinistra o
alla destra di ciò che segue, se c'è un testo, e, se l'immagine fosse
piuttosto grande, questo verrebbe disposto su più righe accanto
all'immagine. I valori "bottom", "top" e "middle" specificano
che l'immagine viene visualizzata nella riga in cui è posizionata e il
testo è allineato in una sola riga (anche se l'immagine è grande) al
bordo inferiore o superiore o al centro dell'immagine. Se questo
attributo è assente, il valore predefinito è "bottom".<br>
Infine gli attributi <code>HSPACE="x"</code> e <code>VSPACE="y"</code> indicano quanti
pixel di spazio vuoto lasciare attorno alla immagine,
rispettivamente a sinistra/destra e sopra/sotto, come una cornice
vuota.<br>|



titolo£[HTML]-Collegamenti ipertestuali|
linguaggio£HTML|
lezione£ Abbiamo visto come inserire testo e immagini all'interno di un
documento web e più avanti vedremo come dar loro una diversa
impostazione grafica, come sistemarli meglio mediante le tabelle e
gli elenchi.<br>
Adesso finalmente esaminiamo la vera essenza del web, ciò che ne
costituisce la struttura portante e che ha determinato il grande
successo di Internet: il collegamento ipertestuale. È chiamato
anche link e la sua funzione è di rimandare ad un'altra sezione
della pagina stessa, oppure ad un'altra pagina presente sullo
stesso sito o su un sito esterno. Esso permette inoltre di scaricare
o eseguire programmi, immagini, file audio e video, presenti sul
sito o su altri server, e tante altre cose.
L'uso del collegamento ipertestuale consente inoltre una lettura
non sequenziale del documento, secondo la volontà del visitatore,
che può saltare facilmente da un documento all'altro o da una
sezione all'altra.<br>
Il tag utilizzato per introdurre un collegamento ipertestuale è
<code>< A ></code>, che però scritto così non ha alcun effetto e necessita di
alcuni attributi. Gli attributi possibili sono 6 e servono a definire la
destinazione del collegamento, e il modo in cui questo
collegamento viene espletato. Gli attributi sono: <b>HREF, NAME,
TITLE, TARGET, REL e REV</b>.<br>
L'attributo che permette di creare un collegamento ipertestuale
verso un'altra sezione o un altro documento è HREF, che definisce
appunto il collegamento ipertestuale (Hipertext REFerence), ma
vediamo prima un altro attributo, in modo che poi potremo
spiegare l'attributo <b>HREF</b> con maggior completezza.<br>
L'attributo <code>NAME="..."</code> permette di inserire un segnalibro
all'interno di una pagina, in modo da potercisi riferire tramite un
collegamento situato in un'altra sezione della pagina o in un'altra
pagina. È come mettere una bandieruola all'interno della pagina ed
utilizzarla come riferimento per la navigazione. Usare un
segnalibro all'interno di un collegamento ipertestuale vuol dire
recarsi non all'inizio del documento da ad un punto preciso della
pagina, esattamente lì dove è posizionato il segnalibro.
La sintassi corretta del tag in questo caso è: <code>< A
NAME="nome" >[testo opzionale]< /A ></code>.<br>
Siccome questo tag serve esclusivamente per porre un segnalibro
all'interno del documento il testo può anche non essere scritto. Il
testo "nome" invece è obbligatorio e deve essere univoco 
all'interno del documento altrimenti il computer dovrebbe scegliere
tra due elementi uguali. I segnalibri vengono molto utilizzati per
creare glossari, FAQ (Frequently Asked Questions) ed elenchi in
genere.<br>
Veniamo adesso all'attributo che costituisce il collegamento
ipertestuale vero e proprio, e che permette di collegare un
documento ad un'altro.<br>
L'attributo di cui stiamo parlando è HREF e la sua sintassi corretta
è <code>< A HREF="indirizzo">[Testo HTML]< /A ></code>.<br>
La dicitura "testo html" specifica un testo o anche un qualsiasi
contenuto di tipo HTML che indica l'ipertesto all'interno della
pagina; può essere un testo, una immagine o un qualunque altro
elemento HTML. Nel caso sia un testo questo viene evidenziato con
una sottolineatura e in colore azzurro (ma ciò si può anche
modificare) mentre nel caso sia una immagine questa viene in
genere evidenziata con un bordo colorato (che si può anche
togliere).<br>
La dicitura "indirizzo" indica l'indirizzo assoluto o relativo di un
qualsiasi documento o file.<br>
Si parla di indirizzo assoluto se esso è nella forma
<b>"http://www.thecoder.it/corsi/HTML"</b>, perché
viene specificato l'indirizzo del server web su cui è posto il
documento.<br>
L'indirizzo è invece relativo se si considera a partire dalla posizione
attuale del documento, ad esempio <b>"../sport/schede.html"</b>. Se
il documento sta nella cartella corrente (quella in cui sta la pagina
che stiamo visualizzando) allora si può scrivere solo il nome del
file, ad esempio "pagina.html".<br>
Infine ci si può riferire ad un particolare punto di una pagina web,
e non solo all'inizio del documento. Ciò si può fare mediante i
segnalibri introdotti appena sopra. Il nome del segnalibro si indica
alla fine dell'indirizzo, preceduto dal simbolo <b>#</b>, ad esempio, se
avessimo messo un segnalibro alla fine di questa pagina e lo
avessimo chiamato "fondo" si può fare un collegamento ad esso
scrivendo <b>"#fondo"</b> come indirizzo.<br>
Mediante i segnalibri vale la stessa distinzione tra indirizzi relativi e
assoluti; ad esempio le tre scritte qui sotto sono equivalenti:
<code>< A HREF="http://www.thecoder.it/guide/html-
10.html#fondo"> Clicca< /A ></code> (indirizzo assoluto)
<code>< A HREF="html-10.html#fondo">Clicca< /A ></code> (indirizzo
relativo)
<code>< A HREF="#fondo">Clicca< /A ></code> (indirizzo relativo)
e producono lo stesso effetto di indirizzare lutente alla fine della
pagina corrente, se questa si chiama html-10.html.
Naturalmente in fondo alla pagina avremo messo il segnalibro: <code>< A
NAME="fondo">< /A ></code>.|





titolo£[HTML]-Tabelle|
linguaggio£HTML|
lezione£ Le prime versioni di HTML non prevedevano un layout elaborato,
ne tantomeno la nozione di tabella. Ora che questo vuoto è stato
colmato ci si può domandare come se ne sia potuto fare a meno.
Le tabelle sono in assoluto lo strumento di formattazione più
usato; esse infatti, non vengono utilizzate solo per visualizzare dati
di fogli elettronici e database, ma anche per implementare testo su
colonne multiple, o posizionare oggetti in punti particolari della
pagina.<br>
Una tabella è definita dal tag contenitore <code>< TABLE > ... < /TABLE ></code>
all'interno del quale si imposta la tabella riga per riga e poi cella
per cella.<br>
All'interno della tabella una riga si specifica mediante il tag <code>< TR >
... < /TR ></code> (Table Row); tutto quello che è compreso tra questi tag
appartiene alla stessa riga della tabella.<br>
All'interno di una riga vengono poi specificate le celle della tabella,
mediante il tag contenitore <code>< TD > ... < /TD ></code> (Table Data).
Notiamo come all'interno di questi tag abbiamo volutamente
lasciato dei puntini .... Questo per indicare che al loro posto va
inserito qualcosa; ed infatti non avrebbe senso definire un
elemento contenitore quale una tabella o una cella e poi non
metterci nulla dentro, tranne in pochi casi, quando si vuole dare
una certa impostazione grafica alla tabella o ad un gruppo di
tabelle.<br>
Vediamo subito l'esempio di una tabella semplice, ma prima
definiamo un attributo del tag <TABLE>, l'attributo
BORDER="n" che serve a dare un bordo alla tabella e alle sue
celle; se è assente significa che la tabella non ha bordo e saranno
visibili solo i contenuti delle celle, ma non la struttura. Il numero n
sta ad indicare lo spessore del bordo in punti.
La sintassi corretta è <TABLE BORDER="1">.<br>
I tag  <TABLE >, < TR > e < TD > riconoscono molti attributi, ma li
vedremo immediatamente sotto, in modo da non
mettere troppa carne al fuoco su un argomento che può portare
una certa difficoltà all'inizio; ciò è dovuto non tanto ad una certa
difficoltà intrinseca alla nozione di tabella, quanto alla complessità
e alla grande quantità di elementi che ne contraddistinguono le
proprietà.<br>
Il tag <code>< TABLE ></code> riconosce gli attributi ALIGN, WIDHT, HEIGHT,
BORDER, CELLSPACING e CELLPADDING.<br>
L'attributo BORDER lo abbiamo già visto. L'attributo ALIGN serve
per allineare la tabella con il bordo sinistro o destro della finestra
oppure mettere la tabella al centro della pagina; i valori che può
assumere sono infatti "left", "right" e "center". Gli attributi
WIDTH e HEIGHT servono per impostare le dimensioni della
tabella, in punti o in percentuale della intera finestra. Porre
WIDTH="100%" vuol dire far occupare alla tabella tutto lo
spazio a sua disposizione in senso orizzontale. L'attributo
CELLSPACING="n" consente di specificare la distanza tra i bordi
di due celle adiacenti o tra una cella ed il bordo esterno;
l'impostazione di default assegna a tale attributo il valore 2.
L'attributo CELLPADDING="n" consente di impostare la distanza
tra il testo ed il bordo della cella circostante; se non impostato
assume il valore 1.<br>
Il tag <code>< TR ></code> è il più semplice e riconosce gli attributi ALIGN e
VALIGN. Il primo serve, all'interno di tutte le celle della riga, per
allineare il testo a sinistra, destra o al centro ("left", "right" e
"center"); il valore predefinito è "left" e questo attributo può
essere annullato reimpostando l'allineamento cella per cella.
L'attributo VALIGN serve per allineare il testo in senso verticale,
se c'è lo spazio; i valori possibili sono "top", "middle" e
"bottom" e allineano il testo in alto, al centro e in basso dentro
ciascuna cella della riga; naturalmente anche questo attributo può
essere annullato reimpostando l'allineamento cella per cella.
Il tag <code>< TD ></code> riconosce gli attributi ALIGN, VALIGN, WIDTH,
HEIGHT, ROWSPAN, COLSPAN, BGCOLOR e NOWRAP; i primi
due hanno lo stesso significato che in <code>< TR ></code> e servono per
allineare il contenuto della cella in senso orizzontale e verticale;
WIDTH e HEIGHT impostano le dimensioni della cella,
rispettivamente la larghezza e l'altezza, entrambi assumono valori
espressi sia in numero di punti che in percentuali dello spazio a
loro disposizione. ROWSPAN="x" e COLSPAN="y" permettono
di unire due o più celle, e specificano di quanto la cella deve essere
espansa; indicare COLSPAN="3" vuol dire che la cella in
questione deve occupare lo spazio di 3 colonne; descriveremo
questi due attributi nel prossimo capitolo, LAVORARE CON LE
CELLE. L'attributo BGCOLOR, come si può ben immaginare
permette di impostare il colore di fondo della cella, espresso in
notazione esadecimale <b>"#RRGGBB"</b> o mediante il nome del
colore. Infine, molto interessante, è l'attributo NOWRAP che forza
il contenuto della cella a rimanere visualizzato sulla stessa riga,
senza ritorno a capo; volendo andare a capo si utilizzano i tag
<code>< BR ></code> e <code>< P ></code>.<br>
Vediamo ora alcuni miglioramenti che possiamo apportare alla
nostra tabella.<br>
Il tag <code>< CAPTION ></code>, posto all'interno della dichiarazione della
tabella, permette di inserire una intestazione o una didascalia alla
tabella. Esso accetta l'attributo ALIGN con i valori "top" e
"bottom", con il quale è possibile mettere il titolo sopra o sotto
alla tabella.<br>
Infine nel visualizzare le colonne è possibile dar loro una
intestazione, mediante il tag <code>< TH ></code> (Table Heading) al posto dei
tag <code><TD></code>. Possiamo aumentare le dimensioni
della tabella mediante gli attributi WIDTH e HEIGHT posti dentro
il tag <code><TABLE></code>; questi attributi ammettono come valore una
percentuale della finestra a loro disposizione oppure il numero di
punti che si vuole come dimensione per la tabella.<br>|


titolo£[HTML]-Form|
linguaggio£HTML|
lezione£ Il WEB è utilizzato soprattutto per visualizzare informazioni, ma
attraverso di esso è possibile anche raccogliere informazioni e dati.
I moduli sono elementi che permettono un buon grado di
interazione con l'utente e si rivelano particolarmente utili per la
raccolta di informazioni.<br>
Un <b>form</b> normalmente è composto da vari tipi di controlli che
consentono di inserire testo, selezionare delle opzioni ed effettuare
altre operazioni disposte dal WebMaster. Alla fine l'utente
conferma le sue scelte effettuando l'invio dei dati immessi,
premendo l'apposito bottone a cui normalmente si da come
etichetta Submit o Invia. In seguito a questa operazione viene
eseguito un programma residente sul server e a questo vengono
passati i dati inseriti; il programma elabora i dati immessi ed
effettua alcune operazioni per le quali è stato realizzato (ad
esempio la visualizzazione di una pagina, l'invio di una E-Mail o
altro).<br>
I programmi sono scritti solitamente in Perl o in C, ed utilizzano
l'interfaccia CGI (Common Gateway Interface) per ricevere i dati
dalla pagina web.<br>
I metodi per passare i dati allo script sono sostanzialmente due:
tramite una richiesta POST o tramite una richiesta GET; se non
diversamente specificato è utilizzata la seconda possibilità.
Tramite il metodo GET i dati vengono passati allo script tramite
l'URL della richiesta e risultano visualizzati nella barra degli
indirizzi; in tale evenienza i parametri sono assegnati alla variabile
speciale di ambiente dello script QUERY_STRING. Questa deve
essere analizzata dallo script e solitamente non può contenere più
di 255 caratteri.<br>
La variabile QUERY_STRING è separata dall'URL dello script
(contenuto nella variabile SCRIPT_NAME) da un segno di punto
interrogativo '?', mentre i parametri in essa contenuti sono indicati
nella forma nome=valore e separati dal segno di ampersen '&'.
Il metodo POST è invece molto più versatile perché non pone limiti
alla dimensione dei dati passati allo script, in quanto questi
vengono infatti inviati attraverso un canale di comunicazione
separato (lo standard output). Questo metodo si sta diffondendo
sempre di più ed è attualmente quello più utilizzato. Con tale
metodo per segnalare la fine dell'input per lo script viene utilizzata
la variabile CONTENT_LENGTH che indica la dimensione in byte del
flusso di dati. Altra informazione passata tramite lo stream di
output è una descrizione del tipo di dati, questa viene copiata nella
variabile di ambiente CONTENT_TYPE.<br>
Il tag che permette l'introduzione di un modulo è <FORM>, e tra
esso ed il suo tag di chiusura può essere inserito qualunque
contenuto HTML valido, tranne altri tag FORM. Esso riconosce due
attributi: ACTION="url" e METHOD="get or post". L'attributo
ACTION è un po' come l'attributo SRC per le immagini; specifica
l'indirizzo del programma che dovrà ricevere i dati immessi nel
modulo. METHOD specifica invece il modo in cui questi parametri
vanno spediti al programma cgi, mediante l'url oppure mediante lo
standard output.<br>
La sintassi corretta del tag è la seguente:<br>
<code>< FORM
ACTION="www.server.com/directory/programma.cgi"
METHOD="post">
.... (modulo)
< /FORM ></code><br><br>
I moduli vengono costruiti specificando i campi che devono
contenere, ad esempio degli spazi in cui scrivere, dei pulsanti da
cliccare, dei bottoni da selezionare etc... opportunamente disposti
sullo schermo per dare una visualizzazione compatta e gradevole.
Questo verrà realizzato mediante appositi tag, che sono:
< INPUT >, < SELECT > e < TEXTAREA >.<br>|


titolo£[CSS]-Introduzione|
linguaggio£CSS|
lezione£ Fino a poco tempo fa la maggior parte delle pagine web erano un misto di contenuti e
presentazione con l'aspetto grafico costituito su tabelle; tutto ciò poteva e può comportare
difficoltà quali: problemi di modifica di un layout, problemi di ritrovare parti di
codice affogate in tabelle e sottotabelle, pesantezza delle stesse a causa dello stesso
motivo.<br>
I css permettono di ovviare a tale inconveniente: con essi si può costruire il contenuto e
successivamente applicarvi lo stile richiesto semplicemente variando la pagina dello stile.<br>
Esistono 4 metodi per utilizzare i css:<br>
1. richiamarli direttamente nelle pagine come stile dell’elemento usando l’attributo
style<br>
2. utilizzare l’elemento < style > nell’head dei nostri documenti XHTML<br>
3. richiamando una pagina di stili esterna attraverso l’elemento < link ><br>
4. utilizzando la direttiva @ import in < style >.<br>
Tutti e 4 i metodi permettono di fare la stessa cosa anche se con alcune differenze. Il
vantaggio di utilizzare fogli di stili esterni è comunque notevole: nel caso in cui volessimo
cambiare look ad un documento ci basterà modificare il foglio di stile.
Molto simile è il comportamento della direttiva @ import che in più esclude alcuni vecchi
browser che non hanno implementato i css in modo corretto.<br>
Analizziamo ora i 4 metodi nel dettaglio: <br><br>
<b>1. Richiamare i css nelle pagine utilizzando l’attributo style.</b><br>
Supponiamo di voler colorare di rosso un paragrafo. Con questo metodo basta dichiarlo
direttamente nell’elemento <b>< p ></b>:<br>
<code>< p style=’color:red’>Hello World!< /p ></code><br>
ed il gioco è fatto.<br><br>
<b>2. Utilizzare l’elemento < style > nell’head dei nostri documenti XHTML.</b>
Con questo metodo è sufficente inserire le proprietà direttamente nell’ head:<br>
<code><html><br>
<head><br>
<style type=’text/css’ media=’all’><br>
p {color:red; }<br>
</style><br>
</head><br>
<body><br>
<p>Hello World!</p><br>
</body><br>
</html></code><br>
Style può avere due attributi:<br>
<b>type</b> obbligatorio, che ha la funzione di specificare il tipo; in pratica sarà però sempre e
solo text/css e <b>media</b> che serve a specificare a quale piattaforma applicare un foglio di stile.<br><br>
<b>3. richiamare una pagina di stili esterna attraverso l’elemento < link >.</b><br>
<code>< link rel=’stylesheet’ type=’text/css’ href=’css.css’ media=’all’ ></code><br>
Questo metodo prevede 4 possibili attributi:<br>
type e media con la stessa funzione appena vista, href che serve a specificare i percorso
del foglio di stile (obbligatorio) e rel che specifica la relazione tra il foglio di stile ed il
documento html. Può assumere due valori: <b>stylesheet</b> e <b>alternate stylesheet</b>.<br><br>
<b>4. utilizzare la direttiva @import in < style ></b><br>
Questo metodo, probabilmente il più usato, prevede di indicare il percorso del foglio di testo entro
parentesi tonde nell’elemento style nella forma<br>
<code>< style ><br>
@import url(http://miosito.ext/css.css);<br>
< /style ></code><br>|




titolo£[CSS]-Regole dei CSS|
linguaggio£CSS|
lezione£ Siamo arrivati al punto di dover applicare delle regole alle nostre pagine. Come si fa a dire
attraverso i css che il nostro paragrafo deve contenere testo di colore rosso? <br>Come
facciamo a dire di applicare uno sfondo giallo ed un margine nullo a tutti i titoli h1?<br>
Come diciamo al css che tutti i titoli h1 ed h2 devono avere padding nullo?<br>
<code>p { color: red; }</code> nel primo caso,
<code>h1 { background-color: yellow; margin: 0; }</code> nel secondo e
<code> h1, h2 { padding: 0; }</code> nell’ultimo. Tutto qua!<br>
Vediamo nel dettaglio la prima regola:<br>
<code>p { color : red; }</code> p => <b>selettore</b>, color => <b>proprietà</b>, red => <b>valore</b> <br>
Come avrete notato la regola è divisa in due parti: la prima è il selettore, cioè la parte che
indica a quale sezione del documento applicare la regola (o le regole) indicata dal blocco
delle dichiarazioni racchiuso tra parentesi graffe.<br>
Il blocco delle dichiarazioni è un insieme di dichiarazioni formato da una proprietà e da un
valore da assegnare alla stessa, divisi tra loro da due punti e terminato da un punto e
virgola. Regole successive possono evidentemente applicate come nel caso del titolo h1 del
secondo esempio.<br>
E’ possibile associare le stesse regole a più selettori come indicato nel terzo esempio ed
applicare regole diverse a seconda della disposizione degli elementi nella pagina,
argomento che potrete approfondire nella lezione I selettori.<br>
Un caso particolare di regola è riferita a tutte quelle proprietà, quali ad esempio margin,
padding, border, che potrebbero avere valori diversi nei quattro lati.<br>
E’ possibile quindi associare valori variabili ai bordi destro, sinistro, superiore ed inferiore
con questa sintassi:<br><br>
<code>p {<br>
margin-top: 0;<br>
margin-right: 2px;<br>
margin-bottom: 3px;<br>
margin-left: 5px;<br>
}</code><br><br>
La cosa interessante è che in tali situazioni è possibile applicare una regola comune e
"risparmiare" codice con la sintassi abbreviata in tal modo:<br><br>
<code>p {<br>
margin: 0 2px 3px 5px;<br>
}</code><br><br>
con i valori per, rispettivamente, il lato alto, destro, basso e sinistro (in senso orario
partendo dall’alto per capirci )<br>
E’ possibile associare una regola solo per i lati alto e basso ed una per destro e sinistro:<br> <br>
<code>p {<br>
margin: 5px 0;<br>
}</code><br><br>
con il primo valore riferito ai lati orizzontali ed il secondo per quelli verticali.<br>
Se si indicano infine solo tre valori,<br><br>
<code>p {<br>
margin: 3px 10px 2px;<br>
}</code><br>
essi saranno riferiti rispettivamente al lato superiore, al lato destro e sinistro ed al
lato inferiore; in pratica è equivalente a scrivere:<code> p { margin: 3px 10px 2px 10px; }<code>.<br>|





titolo£[CSS]-Le Classi e gli ID|
linguaggio£CSS|
lezione£ <b>Classi</b> ed <b>ID</b> sono due attributi del codice xHTML, importantissimi per i fogli di stile.
Permettono infatti di associare un’insieme di regole ad un solo selettore ( ID ) o ad un
gruppo ( class ).<br>
Immaginiamo di voler assegnare a tutti i commenti di un blog il colore grigio ed una
grandezza di 10px . Senza l’esistenza di questi due particolari selettori non riusciremmo a
farlo con i css, dovremmo usare il tag font.<br>
Con i CSS ci basta assegnare una classe ai commenti, chiamandola ad esempio "commenti"
e dichiare tali proprietà nel css in questo semplice modo:<br>
xHTML: [….]<br>
<code>< p class="commenti">Primo commento< /p ></code><br>
<code>< p class="commenti">Secondo commento< /p ></code><br>
e così via<br>
CSS:<br>
<code> .commenti {color:gray: font-size:10px;}</code><br>
Notate il puntino (.) prima del nome della classe: serve ad esplicitare che le regole inserite
saranno riferite a tutti gli elementi con quella classe esplicita.<br>
E’ importante far notare che la classe così definita si applicherà a qualsiasi
elemento della pagina con attributo class="commenti".<br>
Scrivendo quindi questo codice xHTML<br>
<code>< p class="commenti">Commento< /p > Bla bla < div class="commenti" >Blocco di testo< /div ></code><br>
Anche il contenuto del div sarà stampato con le stesse proprietà stabilite per i commenti.<br>
Questo può esser voluto o meno: in tal caso basterebbe assegnare nel css:<br>
<code>p.commenti {proprietà:valori}</code> <br>
affinché le regole della classe commenti vengano applicate solo ai paragrafi (< p >).<br>
Una sorta di classe particolare è l’ID, che si differenzia di base dalla classe per il fatto che è
applicabile SOLO ad un elemento. In pratica può essere applicato
UNIVOCAMENTE ad un solo elemento. <br>
Per definirlo nell’xHTML<br>
<code>< p id="id-numero1" >Testo < /p ></code><br>
e nel css<br>
<code> #id-numero1 { proprietà:valore; }</code><br>
Stesse norme per le classi, con la differenza di dover anteporre in questo caso il cancelletto
( <b>#</b> ) al posto del punto.<br>|




titolo£[CSS]-I Selettori|
linguaggio£CSS|
lezione£ <b>Selettore Universale *</b><br>
Permette di associare a tutti gli elementi della pagina delle regole.
Es:<br>
<code>* {color:black; margin:0; }</code><br>
Associa a qualsiasi elemento della pagina il colore nero e margine nullo.
<br><b>Selettore di Elementi</b><br>
E’ il più diffuso. Permette di associare regole ad uno o più elementi:<br>
<code>h1 { font-style: Georgia, serif; }<br>
h2 { font-style: Georgia, serif; }<br>
h3 { font-style: Georgia, serif; }<br>
h4 { font-style: Georgia, serif; }<br>
h5 { font-style: Georgia, serif; }<br>
h6 { font-style: Georgia, serif; }</code><br>
C’è la possibilità di associare l’insieme di regole a più elementi separandoli con una virgola:<br>
<code>h1, h2, h3, h4, h5, h6 { font-style: Georgia, serif; }</code><br>
scrittura equivalente alla precedente.<br>
<br><b>Selettori Discendenti</b><br>
Questa opzione ci permette di associare regole a particolari elementi se e solo se contenuti
in altri elementi definiti:<br>
<code>div strong { color: red; }</code><br>
Associa il colore rosso solo agli elementi strong contenuti in div.<br>
<code>< body ><br>
< strong >Questo non sarà rosso in quanto non contenuto in un un div< /strong ><br>
< div >Il testo successivo, < strong >questo in particolare< /strong > sarà mostrato in
rosso< /div ><br>
< div >Anche < p >< strong >questo testo< /strong >< /p > sarà mostrato in rosso; non è
importante che i due elementi siano adiacenti o figli.< /div ><br>
< /body ></code><br>
<br><b>Selettore Figlio</b><br>
Potrebbe essere una buona soluzione a molti problemi, purtroppo non è supportato, così
come il selettore adiacente, da Internet Explorer. Secondo le specifiche permette di
associare regole ad elementi solo se contenuti da un altro indicato nel selettore e da nessun
altro.<br>
<code>div > strong { color: red; }</code><br>
Es:<br>
<code>< body ><br>
< div >Il testo successivo, < strong >questo in particolare< /strong > sarà mostrato in
rosso< /div ><br>
< div > Anche < p >< strong >questo testo< /strong >< /p > NON sarà mostrato in rosso in quanto
tra div e strong c’è un altro elemento, mentre < strong >questo testo< /strong > vicecersa lo
sarà.< /div ><br>
< /body ></code><br>
<br><b>Pseudo-classe :first-child</b><br>
Molto simile al selettore figlio, solo che tale regola vale SOLO per il primo figlio,
indipendentemente dalla distanza cui è posto dall’altro.<br>
Es:<br>
<code>div > strong:first-child { color: red; }</code><br>
<br><b>Pseudo-classi dei links</b><br>
E’ probabilmente una delle feature più interessanti dei Css: permette di associare ai links
(ed anche agli altri elementi, tranne :link e :visited, in teoria; in pratica visto il non
supporto di IE solo all’elemento A) regole diverse a seconda se il link non è stato visitato
( :link ), già seguito ( :visited ), attivo ( :active ), al passaggio del mouse ( :hover ) e
se selezionato ( :focus ).
Es:<br>
<code> a:link { color: blue; }<br>
a:visited { color: purple; }<br>
a:active { color: black; }<br>
a:hover { color: red; }<br>
a:focus { color: green; }</code><br>
<br><b>Selettori Adiacenti</b><br>
Ha la stessa limitazione dei selettori figli: non è supportato da Internet Explorer. Secondo
le specifiche permette di associare regole ad elemento solo se contenuto subito dopo
l’altro indicato.<br>
<code> div + strong { color: red; }</code><br>
Es:<br>
<code>< div ><br>
< strong >Questo testo sarà mostrato in rosso</strong> mentre<br>
< /div ><br>
< div ><br>
il prossimo < strong >testo< /strong >< /p > no, in quanto non immediatamente vicino
all’elemento div
< /div ></code><br>
<br><b>Selettori di Attributi</b><br>
Selettore davvero interessante per i possibili sviluppi verso l’XML ma purtroppo di poca
utilità visto che pochissimi browser attualmente non lo supportano. Permette di associare
regole diverse all’elemento se dotato di attributi o valori degli stessi.<br>
<code>H1[title] { color: red; }<br>
H1[title="pippo"] { color: green; }</code><br>
La prima regola associa il colore rosso a tutti gli elementi h1 dotati di title, mentre la
seconda regola varrà solo per gli elementi h1 il cui titolo è esattamente pippo. Potrebbe
essere molto utile per assegnare valori diversi agli elementi input di un form, per variare lo
stile del pulsante submit rispetto ad un campo testo ad esempio; purtroppo ad oggi è
conveniente per la stessa operazione assegnare delle classi diverse ai tag.<br>
<br><b>Selettori di Classi</b><br>
Permette di assegnare regole a qualunque elemento a cui abbiamo assegnato una classe:<br>
<code>*.nomeclasse { color: red;}</code> o, in forma equivalente<br>
<code>.nomeclasse { color: red;}</code><br>
E’ possibile ovviamente assegnare regole solo ad uno o più elementi con classe nomeclasse,
usando la sintassi:<br>
<code> strong.nomeclasse {color: purple; }</code><br>
<br><b>Selettori di ID</b><br>
Selettore molto simile al precedente con l’ovvia differenza che le regole saranno assegnate
solo ad un particolare ID:<br>
<code>#nomeclasse {color: purple; }</code><br>
<b>Pseudo-classi :first-line e :first:letter</b><br>
Opzione molto interessante che limita le regole rispettivamente alla prima linea del testo
nel primo caso ed alla prima lettera nel secondo per effetti simili a quelli tipografici. Es:<br>
<code>p:first-line { text-transform: uppercase; }
p:first-letter { font-size: 300%; color:red; }</code>
trasforma la prima riga dei paragrafi ( p ) in maiuscolo e rende la prima lettera degli stessi 3
volte più grande e di colore rosso.<br>|





titolo£[CSS]-Proprietà dei caratteri|
linguaggio£CSS|
lezione£ In questa lezione vedremo come cambiare la forma estetica dei caratteri tipografici
utilizzati nelle vostre pagine web.<br><br>
<b>font:</b><br><br>
font: < size > [ / < line-height > ] / < family > / [ < style > / < variant > / <weight> ] 
es: <br>
<code>font: 12px / 18px bolder italic arial;</code><br>
Con font è possibile indicare in forma compatta tutte le proprietà dei caratteri con le stesse
regole che trovate successivamente.<br><br>
<b>font-family:</b><br><br>
font-family: <nome carattere> / <font generico>;
Es: <br>
<code>font-family: Verdana, Arial, sans-serif;</code><br>
Utilizzando font-family riusciremo a dare un aspetto ai caratteri utilizzati nella pagina. I
browser mostreranno il primo carattere, da sinistra, tra quelli utilizzati dal sistema
operativo in uso. Nell’esempio precedente stamperà i caratteri in verdana, se non
installato, arial altrimenti utilizzerà il font di default per il gruppo sans-serif. Ricordate
quindi di provare tutti i caratteri aggiungendone uno la volta a sinistra per controllare
l’aspetto estetico avendo cura di indicare una famiglia generica alla fine. I caratteri
possono esser raggruppati in due grandi categorie: grazie o serif, che hanno la
caratteristica di avere dei "riccioli" di abbellimento e bastoni o sans-serif. In realtà è
possibile indicare anche altre 3 famiglie di font: monospace (a spaziatura fissa), cursive e
fantasy, famiglie che mi sento di sconsigliarvi ampiamente, tranne alcune eccezioni
particolari.<br>
Se il font ha un nome composto da due o più termini, ad es. Times new roman, occorre
metterlo tra ".
Es: <br>
<code>font-family: "Times new Roman", serif;</code><br><br>
<b>font-size:</b><br><br>
font-size: <dimensione> / xx-small / x-small / small / medium / large / x-large / xx-large /
larger / smaller <br>
dove dimensione può essere una lunghezza, oppure una percentuale.
Larger e smaller son parametri relativi e servono ovviamente ad aumentare o diminuire la
dimensione dei font rispetto all’elemento contetitore. <br><br>
<b>font-style:</b><br><br>
font-style: normal / italic / oblique;
Es: font-style: italic;
Serve a dare lo stile ai caratteri:. Sostituisce il tag html <i>. Oblique e cursive attualmente
nella maggior parte dei browser son equivalenti.
font-variant:
font-variant: normal / small-caps;
Tale soluzione serve a dare l’effetto "maiuscoletto" al testo: le lettere maiuscole restano
tali, quelle minuscole son riprodotte in maiuscolo ma in un corpo più piccolo.
<b>font-weight:</b><br><br>
font-weight: normal / bold / bolder/ lighter / 100 / 200 / 300 / 400 / 500 / 600 / 700 / 800
/ 900;
Es: <br><code>font-weight: 700;</code><br>
Con tale proprietà facciamo stampare i caratteri con peso diverso. In effetti i browser
attuali distinguono tra il peso standard e il bold. Pertanto la scelta si riduce a scegliere tra
normal e bold, tenendo in mente che bolder e lighter, attributi relativi possono aumentare
o diminuire il peso del carattere rispetto all’elemento contenitore. Sostituisce il tag html
< b >. Att: font-weight:bold ed il tag < strong > non sono equivalenti anche se possa
sembrare così; font-weight agisce sull’aspetto del font, < strong > sul contenuto semantico
del testo racchiuso.<br>|





titolo£[CSS]-Proprietà dei colori|
linguaggio£CSS|
lezione£ I Colori possono esser definiti nei css attraverso una parola chiave, attraverso la codifica
RGB in due metodi: con un codice esadecimale oppure indicando la percentuale di Rosso,
verde (Green) e Blue che compongono il colore.<br>
La sintassi da utilizzare è:<br>
• color: <b>key</b><br>
• color: <b> # rrggbb</b><br>
• color: <b> # rgb (forma ridotta)</b><br>
• color: <b>rgb (r, g, b,)</b><br>
• color: <b>rgb (r%,g%,b%)</b><br><br>
Esempi:<br>
<code>{ color: red;}<br>
{ color:#FF0000;}<br>
{ color:#F00;}<br>
{ color: rgb(255,0,0); }<br>
{ color: rgb(100%,0,0);}</code><br><br>
Tutti i codici riportati indicano il colore rosso.<br>
Praticamente i colori vengono indicati in una scala da 0 a 255, in cui 0 indica nessuna
presenza e 255 presenza completa del primario. Tali numeri possono esser indicati in
percentuale, in forma decimale o esadecimale ( FF=255 ). Attenzione ad aggiungere il <b>#</b>
quando si usa la sintassi esadecimale: anche se IE mostra il colore se si scrive <code>{ color:F00; }</code>
ciò non vuol dire che sia corretto.<br>
La forma ridotta infine è un modo di scrivere un codice hex alleggerendo il peso quando i
codici si ripetono: # FC9 è la forma contratta di # FFCC99.<br>
<b>Colore e background</b><br><br>
Il colore è applicato alle due proprietà: color e background, che definiscono il colore del
testo e lo sfondo.<br>
color:<br>
color: < valore >;<br>
Dove il valore può esser assegnato utilizzando uno dei metodi sopra illustrati.<br>
<b>background:</b><br><br>
background: < color > / < url > / < repeat > / < position > / < scroll ><br>
Es:<br> <code>background: #F00 url(' immaginedisfondo ') fixed no-repeat center left fixed;</code><br>
< color > può assumere un valore come su indicato, può essere transparent per indicare uno
sfondo trasparente o none per non dare nessuno sfondo.<br>
< url > è il percorso dell’immagine di sfondo, da usare nella forma url (< valore >), dove
valore può esser inserito tra ', ", o senza, e può esser un percorso assoluto o relativo alla
posizione del css.<br>
< repeat > può esser uno dei seguenti valori: repeat, opzione di default che fa ripetere
l’immagine in orizzontale e verticale, no-repeat: nessuna ripetizione; repeat-x, repeaty:
permettono la ripetizione lungo l’asse orizzontale ( x ) o verticale ( y ).<br>
< position > indica la posizione dell’immagine di sfondo. può assumere valori numerici,
percentuali o uno dei seguenti: top, center, bottom per il posizionamento verticale, left,
center, right per quello orizzontale.<br>
< scroll > può assumere i valori scroll (opz. di default) e fixed per indicare se l’immagine
debba seguire o no lo scrolling della pagina.<br>
Le stesse proprietà possono esser indicate singolarmente con:<br>
• <b> background-color: < color ></b>;<br>
• <b> background-image: < url ></b>;<br>
• <b> background-position: < position ></b>;<br>
• <b> background-repeat: < repeat ></b>;<br>
• <b> background-attachment: < scroll ></b>;<br>|





titolo£[CSS]-Proprietà dei testi|
linguaggio£CSS|
lezione£ Il vantaggio dell’uso dei CSS viene reso evidente dalle proprietà dei testi, proprietà che
permettono il controllo tipografico accurato, semplice per tutti ma allo stesso tempo
potente. Con i css infatti è possibile controllare qualunque aspetto tipografico permettendo
una resa avanzata dei testi usando le seguenti proprietà:<br><br>
<b>text-align:</b><br><br>
text-align: left / center / right / justify<br>
Esempi:<br>
<code>{ text-align:justify; }</code>
Permette di allineare il testo rispettivamente a sinistra, centrato, a destra e giustificato.<br>
<b>text-decoration:</b><br><br>
text-decoration: none / underline / overline / line-through / blink<br>
Esempi:<br>
<code>a { text-decoration:underline; }<br>
a:visited { text-decoration:line-through; }<br>
a:hover { text-decoration:none; }</code><br>
per stampare il testo: senza nessuna decorazione, sottolineato, sopralineato, barrato e
lampeggiante. L’uso di blink è da evitare poiché potrebbe creare problemi fisici ad alcuni e
perché, obiettivamente, è fastidioso non poco.<br>
<b>text-transform:</b><br><br>
text-transform: none / uppercase / lowercase / capitalize<br>
permette di trasformare il testo in: tutto maiuscolo (uppercase), tutto minuscolo
(lowercase), ogni prima lettera in maiuscolo (capitalize) o lasciare il testo formattato come
da xHTML.<br>
<b>line-height:</b><br><br>
line-height: normal / <valore> / <valore percentuale><br>
Esempi:<br>
<code>{ line-height: 20px; }<br>
{ line-height: 200%; }</code><br>
per impostare l’interlinea del testo.<br>
<b>word-spacing:</b><br><br>
word-spacing: normal / <lunghezza><br>
permette di aumentare o diminuire lo spazio tra le parole. Di default ha valore 0.<br>
Impostando un valore positivo tale lunghezza si aggiunge alla distanza solita,
impostandone uno negativo si dimuisce. Attenzione:<br>
<code>{ word-spacing:10px; }</code>
imposta una distanza tra le parole di 10px PIU’ il valore standard, non 10px in assoluto.
<b>letter-spacing:</b><br><br>
letter-spacing: normal / <lunghezza><br>
Come sopra. Di default ha valore 0 che sta ad indicare lo spazio tra le lettere standard.
Anche in questo caso la lunghezza indicata va a sottrarsi o ad aggiungersi al valore di
default.<br>|





titolo£[CSS]-Proprietà dei bordi|
linguaggio£CSS|
lezione£I bordi possono esser definiti da tre proprietà:<br>
• <b>border-width:</b> < dimensione >;<br>
• <b>border-color:</b> < colore >;<br>
• <b>border-style:</b> < stile >;<br>
che vengono applicati a tutti i bordi del box.<br>
<Dimensione> può essere una lunghezza come definitita in questo articolo oppure i
valori<br>
• <b>thin</b> ( sottile )<br>
• <b>medium</b> ( medio )<br>
• <b>thick</b> ( spesso )<br><br>
< Stile > può essere:<br>
• <b>none</b> ( nessuno )<br>
• <b>solid</b> ( continuo )<br>
• <b>double</b> ( doppio )<br>
• <b>dashed</b> ( tratteggiato )<br>
•<b> dotted</b> ( punteggiato )<br>
• <b>inset</b> ( incassato )<br>
• <b>outset</b> ( in rilievo )<br>
• <b>groove</b> ( scanalato [in basso] )<br>
• <b>ridge</b> ( scanalato [in alto] )<br><br>
< Colore > infine può definito come indicato in questo articolo.<br>
Esiste anche una forma compatta:<br>
border: < dimensione > < colore > < style >.<br>
Utilizzando tali proprietà assegnamo le caratteristiche a tutti e 4 i lati:<br>
Es: <br>border: 4px red solid;<br>
crea un bordo uniforme di 4 pixel di colore rosso. Se volessimo assegnare lo stesso bordo
solo a quello inferiore potremmo usare la notazione:<br>
border-bottom: 4px red solid;<br>
E’ possibile inolte assegnare proprietà diverse nel seguente modo:<br>
border-width: 1px 2px 3px 4px;<br>
che son riferiti, rispettivamente al bordo superiore, destro, inferiore e sinistro.<br>|







titolo£[CSS]-Tabelle|
linguaggio£CSS|
lezione£ I css permettono design tableless, cioè senza tabelle, che ritornano finalmente ad assumere
il valore per le quali son state progettate: mostrare dati tabellari, statistici. Anche per le
tabelle esistono specifiche proprietà CSS:<br><br>
<b>table-layout:</b><br><br>
table-layout: auto / fixed<br>
che permette alle tabelle, alle righe o alle colonne delle stesse, di adattarsi al contenuto o di
restare fisse in base, in altezza o larghezza a ciò che si è indicato.<br><br>
<b>empty-cells:</b><br><br>
empty-cells: show / hide<br>
per scegliere se mostrare o meno le celle vuote.<br><br>
<b>border-collapse:</b><br><br>
border-collapse: collapse / separate<br>
indica se far collassare i bordi in un unico bordo o separarli in più livelli.<br><br>
<b>border-spacing:</b><br><br>
border-spacing: < lunghezza > < lunghezza ><br>
da usare ovviamente con border-collapse:separate per indicare lo spazio tra i bordi. Si
possono specificare due valori: 1 per la spaziatura destra e sinistra ed il secondo per quella
in alto e basso; se si indica un solo valore vale per tutti e 4 i bordi.<br><br>
<b>caption-side:</b><br><br>
caption-size: top / right / bottom / left<br>
per indicare in che lato mostrare il valore di caption della tabella.<br>|





titolo£[CSS]-Dimensionamento e misure|
linguaggio£CSS|
lezione£ Le misure e le dimensioni nei css, utilizzate in molti ambiti tra i quali e non solo: bordi,
altezza e larghezza dei blocchi, grandezza dei caratteri, margini, padding, possono essere
espresse in forma relativa oppure assoluta nella forma: numero seguito da due lettere che
indicano l’unità di misura. Attenzione agli errori frequenti che possono creare problemi di
visualizzazione, in particolare: tra i numeri e la misura non possono esserci spazi. Se la
misura è zero non deve esser seguito da unità di misure.<br>
Es.:<br> 
<b>corrette:</b> 12px; 1.45em; 0;<br>
<b>errate:</b> 12 px, 1. 45em, 0px;<br><br>
<b>Dimensioni assolute:</b><br>
• <b>cm:</b> centimetri;<br>
• <b>mm:</b> millimetri;<br>
• <b>in:</b> inches, pollici, dove un pollice = 25,4 mm<br>
• <b>pt:</b> punti, cioè la 72a parte di un inch, circa 0.35mm; in pratica 3pt ~ 1mm<br>
• <b>pc:</b> picas, un sesto di inch, circa 4,2 mm<br>
Tali dimensioni son ottime se usate nella stampa e nei dispositivi a dimensione fissa, son
sconsigliabili viceversa a video dato che essi son per loro natura diversi uno dall’altro.
Dimensioni assolute comportano a schermo visioni diverse delle proprie pagine da
computer a computer. Tenete sempre in mente che il web non è la tipografia classica e che
è praticamente impossibile creare siti che siano perfettamente simili su qualsiasi
computer.<br><br>
<b>Dimensioni relative:</b>
• <b>em:</b> dimensione di una lettera m del carattere utilizzato<br>
• <b>px:</b> pixel<br>
• <b>%: </b>percentuale<br>
La dimensione dei pixel dipende dalla risoluzione dei dispositivi utilizzati. Un pixel è la più
piccola particella "unica" dello stesso. A video son i vari elementini luminosi che messi
assieme formano un’immagine. Un em è la dimensione di una lettera m del set di caratteri
utilizzato. Se impostiamo una misura in em essa è riferita alla dimensione dei font del
livello contenitore. Praticamente:<br>
<code>body { font-size:20px; }<br>
div#div1 { font-size:1.5em; }<br>
div#div2 { font-size:0.8em; }<br>
< body ><br>
< div id="div1" >Bla bla< div id="div2" >Bla bla< /div >< /div ><br>
< /body ></code><br>
Il body avrà dimensioni 20px. Div1 avrà dimensione di una volta e mezza quella di
body, cioè 30px; Div2 0.8 volte quella del suo contenitore quindi 30*0.8=24px. Le
dimensioni percentuali seguono lo stesso ragionamento su indicato. Le misure relative son
quelle più utilizzate nelle pagine. Il mio consiglio è quello di impostare una dimensione per
il body in pixel ed usare em per tutte le altre sezioni. Le misure in pixel dovrebbero esser
usate solo per le dimensioni dei bordi dei blocchi.<br>|


titolo£[Javascript]-Hello World|
linguaggio£Javascript|
lezione£ Eccoci al nostro primo programma JavaScript: queste poche righe di codice identificano
una pagina HTML su cui viene stampato Hello, world!. Create il seguente file e apritelo con il
vostro browser:<br><br>
<code>< html ><br>
< head ><br>
< title >La mia prima applicazione JavaScript</title><br>
< /head ><br>
< body ><br>
< script ><br>
document.write ( "Hello, world!" );<br>
< /script ><br>
< /body ><br>
< /html ></code><br>
Analizziamo l'unica riga di codice JavaScript presente nella pagina:<br>
<code>document.write ("Hello, world!");</code>
Quando il browser analizza la pagina, nel momento in cui incontra le istruzioni, se non indicato
diversamente (come vedremo più avanti), le esegue secondo l'ordine nel quale sono indicate, ovvero
in sequenza (questa operazione è chiamata parsing).<br>
Le istruzioni sono sempre separate da un punto e virgola ( ; ), e a JavaScript non interessano quindi i
ritorni a capo.<br>
In particolare, la riga di codice analizzata stampa sul documento il testo Hello, world tramite
l'istruzione il metodo write dell'oggetto document. Per ora ci basti sapere che un metodo è un
sottoprogramma associato esclusivamente ad un oggetto, che può richiedere uno o più parametri per
funzionare al meglio. Il metodo write dell'oggetto document stampa nella pagina il testo
indicato tra virgolette all'interno delle parentesi.<br>
Cerchiamo di capire meglio come avviene il parsing di uno script JavaScript. Essendo infatti il
browser piuttosto veloce a interpretare il codice, non è possibile ai nostri occhi notare l'esecuzione
dello script, e sulla pagina compare subito il testo Hello, world!. Modifichiamo quindi il nostro
codice come segue:<br><br>
<code>...<br>
< script ><br>
alert ( "Questo è un messaggio" );<br>
document.write ( "Hello, world!" );<br>
alert ( "Questo è un altro messaggio" );<br>
< /script ><br>
...</code><br>
Il metodo <b>alert</b> mostra una finestrella contenente il testo indicato tra parentesi e un pulsante
"OK". Quando viene eseguito, il parsing della pagina si ferma fino a quando l'utente non clicca sul
bottone OK; possiamo quindi vedere capire meglio come lavora il browser: l'esecuzione dello script
si fermerà infatti due volte in corrispondenza delle due istruzioni alert. Quando viene mostrato il
primo messaggio la pagina in secondo piano apparirà vuota, perché non vi è ancora stato impostato
il contenuto; quando viene mostrato il secondo messaggio comparirà anche il testo Hello, world! in
quanto sarà stata già eseguita il metodo write.<br>|






titolo£[Javascript]-Tipi di dato|
linguaggio£Javascript|
lezione£ I dati in JavaScript possono essere di varie tipologie e a seconda della tipologia si potrà lavorare in
modo diverso con essi. Il JavaScript è un linguaggio chiamato a tipizzazione debole, in quanto ogni
volta che si fa riferimento ad un dato non è necessario specifiare il tipo, che viene attribuito
automaticamente dal parser in base al contesto.<br><br>
<b>Numeri</b><br>
I dati numerici possono essere positivi e negativi e si distinguono in integer (numeri interi) e float
(numeri a virgola mobile).<br>
Per convertire un valore qualsiasi in un valore numerico, JavaScript mette a disposizione due
funzioni: parseInt e parseFloat. Per ora ci basti sapere che una funzione è un
sottoprogramma (come un metodo) che non è associato ad alcun oggetto ma restituisce comunque
un valore in base ad eventuali parametri accettati in ingresso. Per convertire i dati, ad esempio una
stringa, queste funzioni analizzano carattere per carattere la stringa fornita come input prendendo in
considerazione solo i numeri e, nel caso di parseFloat, anche il separatore decimale .. Ad esempio:<br>
<code>parseFloat("34acb") //restituisce 34.
parseInt("3eac34") //restituisce 3</code><br><br>
<b>Not a Number</b><br>
Può tuttavia succedere che il valore passato alle funzioni di parsing dei numeri non possa essere
elaborato come numero. In questo caso la funzione restituisce un valore particolare, NaN, che è
l'acronimo per Not a Number, non un numero. È possibile testare se un valore è NaN usando la
funzione <b>isNaN</b><br><br>
<b>Stringhe</b><br>
In informatica una stringa è una sequenza di uno o più caratteri alfanumerici. In JavaScript le
stringhe si indicano inserendole all'interno di virgolette doppie ( " ) o apici ( ' ) Bisogna però fare
attenzione a chiudere una stringa con lo stesso apice con la quale è stata aperta; sono ad esempio
stringhe valide:<br>
<code>"Hello, world ! 1234"<br>
"Peter O'Toole"</code><br>
ma non lo è ad esempio<br>
<code>'Peter O'Toole'</code><br>
in quanto il parser analizzerebbe la stringa e, arrivato a O' penserebbe che la stringa si chiuda,
senza sapere cosa sia Toole'.<br>
È possibile anche indicare che caratteri come " e ' non indicano la fine del testo ma un carattere
qualsiasi facendole precedere dal carattere di commutazione \. Ad esempio sono stringhe valide:<br>
<code> 'Peter O\'Toole' </code><br>
<code>"Questo libro è depositato su \"it.wikibooks\""</code><br>
In realtà ogni carattere è commutabile in una sequenza esadecimale usando la notazione \xNN dove
NN è un numero esadecimale che identifica un carattere nel set Latin-1.<br><br>
<b>Dati booleani</b><br>
Il tipo di dato booleano può assumere i soli valori true (vero) e false (falso). Il tipo di dato
booleano è fondamentale per la selezione binaria e per il decision-making.<br>
Quando è atteso un tipo di dato booleano il parser si comporta in maniere differenti:<br>
• se viene fornito un numero, questo viene converitito in false se è 0, in true se è 1<br>
• se viene fornito una stringa, questa viene converitito in false se è vuota (""), in true
negli altri casi<br>|







titolo£[Javascript]-Variabili|
linguaggio£Javascript|
lezione£ Una variabile in JavaScript identifica una cella di memoria nella quale vengono salvati durante
l'esecuzione dello script i dati.<br>
Quando si lavora con le variabili, è necessario per prima cosa indicare al parser il suo nome
utilizzando l'istruzione var:<br><br>
<code>var nome_variabile;</code><br>
dichiara una variabile nome_variabile. Essendo JavaScript un linguaggio a tipizzazione
debole, non è necessario indicare il tipo di dato della variabile, a meno che non si stia lavorando con
oggetti (si vedrà più avanti). In questo caso la variabile appena dichiarata non avrà valore, non è
stata cioè ancora inizializzata; è possibile però inizializzare la variabile direttamente insieme alla
dichiarazione:<br><br>
<code>var nome_variabile = espressione;</code><br>
dichiara una variabile con il valore di espressione. Per espressione si intende una sequenza di
di operatori, variabili e/o dati che restituisca a sua volta una valore.<br>
Quando si scelgono dei nomi per le variabili, si faccia attenzione ad alcune regole:<br><br>
• JavaScript è case-sensitive (sensibile alle maiuscole): var1 e Var1 sono due variabili
differenti<br>
• in JavaScript esistono, come in ogni linguaggio formale, delle parole riservate, che
identificano cioè particolari comandi per il parser. Non bisogna quindi usare parole riservate
come nomi di variabili.<br>
• una variabile non può contenere caratteri particolari (? : ; , . ecc...), tranne l'underscore, e
non può iniziare con un numero<br><br>
L'operazione fondamentale da usare con le variabili è l'assegnazione, che consiste nell'assegnare,
nell'attribuire ad una variabile un valore. La sintassi è intuitiva e semplice:<br><br>
<code>nome_variabile = valore;</code>
dove valore è un'espressione. Ad esempio:<br><br>
<code>var1 = "ciao!";<br>
var2 = 3;<br>
var3 = false;<br>
var4 = var3; //attribuisce a var4 una copia del valore di var3</code><br>|






titolo£[Javascript]-Funzioni|
linguaggio£Javascript|
lezione£ Come molti linguaggio di programmazione, anche JavaScript da la possibilità di creare le proprie
funzioni personalizzate.<br>
Come è stato già accenato in precedenza, una funzione è un sottoprogramma identificato da una
sequenza di caratteri che può accettare o meno nessuno o più parametri e può restituire un valore.<br><br>
<b>Creare le proprie funzioni:</b><br>
La sintassi per la creazione di una nuova funzione è la seguente:<br>
<code>function nome_funzione (arg1, arg2, argN...) {<br>
''codice''<br>
}</code><br>
Ad esempio:<br>
<code>function benvenuto (nome) {<br>
alert("Benvenuto, " + nome);<br>
}</code><br>
Se vogliamo eseguire il codice contenuto nella funzione dobbiamo richiamarla (o invocarla). Ad
esempio:<br>
<code>var n = prompt("Come ti chiami?");<br>
if (n != "")<br>
benvenuto (n);</code><br>
Con questo breve spezzone chiediamo all'utente di inserire il nome e, se non risponde con una
stringa vuota e non ha premuto Annulla, gli porge il benvenuto (si noti che il metodo prompt
restituisce una stringa vuota se l'utente fa clic su "Annulla").<br><br>
<b>Usare i parametri</b><br>
Come abbiamo visto, è possibile prevedere che l'utente possa passare alcuni parametri alla funzione.
Dando una sguardo alla funzione di benvenuto creata precedentemente, vediamo che il parametro
nome della funzione diventa poi automaticamente una variabile; se quando viene chiamata la
funzione viene omesso, il parametro assumerà un valore nullo (che diventa 0 per i numeri, una
stringa vuota per i valori alfanumerici, falso per i valori booleani).<br><br>
<b>Impostare un valore di ritorno</b><br>
Impostare un valore di ritorno di una funzione è molto semplice, basta seguire la sintassi:<br>
<code>return valore;</code><br>
Quando incontra l'istruzione return, JavaScript interrompe l'esecuzione della funzione e
restituisce il valore indicato. Ad esempio:<br>
</code>function somma (a, b)<br>
{ //una semplice funzione<br>
return a+b;<br>
}<br>
var c = somma(3,5); //c assumerà il valore 8</br>
somma(4,12); //in questo caso non succede nulla</code></br>
Si noti che una funzione può essere richiamata solamente dopo che è già stata inserita nel
programma. Un codice come questo genererebbe errore:<br>
<code>var c = somma(3,5); //la funzione somma non esiste ancora!<br>
function somma (a, b)<br>
{ //una semplice funzione<br>
return a+b;<br>
}</code><br>|








titolo£[Javascript]-Oggetti|
linguaggio£Javascript|
lezione£ Il concetto di oggetto è molto importante nella programmazione in JavaScript. In questo modulo
verranno spiegate le caratteristiche comuni degli oggetti; JavaScript permette di creare le proprie classi personalizzate;
tuttavia noi lavoreremo solo su quelle
predefinite.<br>
Per creare un nuovo oggetto è necessario associarlo ad una variabile usando la sintassi:<br>
<code> var nome_oggetto = new nome_classe (); </code><br>
In questo modo la variabile nome_oggetto sarà l'unico modo per fare riferimento all'istanza di
nome_classe appena creata.<br>
Le classi possono per la creazione dell'oggetto prevedere anche l'uso facoltativo di un costruttore,
cioè un metodo che imposta automaticamente alcune proprietà dell'oggetto. La sintassi in questo
caso è:<br>
<code> var nome_oggetto = new nome_classe (parametri_del_costrutture); </code><br>
Per fare un esempio con la nostra macchina:<br>
<code> var la_mia_macchina = new macchina ("Utilitaria", "Rosso");</code><br>
Ovviamente la classe macchina conterrà un costruttore che prevede come parametri il tipo e il
colore della macchina.<br><br>
<b>Proprietà</b><br>
Possiamo pensare ad una proprietà come ad una variabile associata al singolo oggetto; il suo valore
viene attribuito inizialmente dal costruttore (se viene usato) e successivamente viene modificato
agendo sull'oggetto (operando sui metodi, ecc...). Per fare riferimento alla proprietà (per il recupero
o per l'assegnazione) si usa la sintassi:<br>
<code> nome_oggetto.nome_proprietà </code><br>
Alcune proprietà possono essere di sola lettura, cioè il loro valore può essere letto ma non
modificato.
Con la nostra macchina:<br>
<code> alert (' La mia macchina è lunga ' + la_mia_macchina.lunghezza + ' m! ');</code><br>
Come si potrà pensare, la proprietà lunghezza è di sola lettura.<br>|






titolo£[Javascript]-Oggetto String (Costruttore e Proprietà)|
linguaggio£Javascript|
lezione£ L'oggetto String permette di effettuare numerose operazioni sulle stringhe quali ricerca, isolamento
di un carattere e altro ancora.<br><br>
<b>Costruttore</b><br>
Per creare un nuovo oggetto della classe String usiamo la sintassi:<br>
</code> var nome_variabile = new String(stringa);</code> <br>
Il costruttore prende come parametro la stringa che sarà manipolata nel corso dello script.<br>
L'oggetto String è un po' particolare, in quanto, come vi sarete già accorti, corrisponde ad un
"doppione" del tipo di dato primitivo <b>stringa</b>, analizzato precedentemente nel corso delle lezioni.<br>
Dal momento che JavaScript effettua automaticamente la conversioni dei dati quando necessario, la
differenza è dal punto di vista pratico, in quanto:<br><br>
• se creiamo una stringa con la normale sintassi
<code>var variabile = "testo";</code> 
e successivamente volessimo trattarla come un oggetto String usando metodi o proprietà della
classe String, JavaScript converte automaticamente la stringa in un oggetto String<br>
• se abbiamo un oggetto String e volessimo recuperare la sua stringa, JavaScript converte
automaticamente l'oggetto String in una stringa contente la stringa indicata nel costruttore.<br><br>
<b>Proprietà</b><br>
L'oggetto String dispone di una proprietà rilevante, la proprietà length che restituisce il numero
di caratteri contenuti in una stringa:<br>
<code>var esempio = "Sono una stringa primitiva"
alert (esempio.length); //restituisce 26</code><br>
Nell'esempio appena visto, nella seconda riga la variabile esempio viene convertita in un oggetto
String per accedere alla proprietà length.<br>
Sempre per quanto appena detto, potremmo semplicemente scrivere:<br>
<code>alert ("Sono una stringa primitiva".length); //restituisce 26</code><br>|






titolo£[Javascript]-Oggetto String (Metodi)|
linguaggio£Javascript|
lezione£ I metodi della classe String permettono di eseguire molteplici operazioni sulle stringhe; si noti che
questi metodi lavorano sulla stringa contenuta nell'oggetto ma restituiscono il valore desiderato
senza modificare il valore dell'oggetto stringa.<br><br>
<b>toLowerCase( ) e toUpperCase( )</b><br>
Questi due metodi restituiscono la stringa forzando la capitalizzazione o tutta minuscola o tutta
minuscola. Attenzione:<br>
<code>var t1 = new String ("TeStO");<br>
var t2 = t1.toLowerCase( ) //restituisce "testo"<br>
var t3 = t1.toUpperCase( ) //Restituisce "TESTO"<br>
// attenzione: alla fine di questo codice la variabile t1 contiene ancora
"TeStO"!</code><br><br>
<b>charAt( ) e charCodeAt( )</b><br>
Il metodo charAt( ) restituisce il carattere della stringa che si trova alla posizione specificata; il
primo carattere è identificato dalla posizione 0. Ad esempio:<br>
<code>var testo = prompt("Inserisci un testo", "Hello, world!");<br>
var ultimoCarattere = testo.charAt(testo.length - 1);<br>
alert (ultimoCarattere);</code><br>
Questo semplice codice estrapola dalla stringa fornita in input dall'utente l'ultimo carattere. Per fare
ciò recupera il carattere alla posizione testo.length - 1.<br>
Il metodo charCodeAt( ) funziona come charAt( ) ma invece del carattere restituisce il suo
codice Ascii.<br><br>
<b>indexOf( ) e lastIndexOf( )</b><br>
Uno dei metodi dell'oggetto String che useremo più di frequente sarà indexOf( ) la cui sintassi è:<br>
<code> oggetto_string.indexOf(search, start); </code><br>
In pratica, il metodo cerca nella stringa la prima occorrenza della sottostringa search e ne
restituisce la posizione (a partire da 0); se la stringa non viene trovata, restituisce -1. Il parametro
opzionale start specifica la posizione dalla quale iniziare la ricerca (di default è 0). Ad esempio;<br>
<code>var stringa = "Ma la volpe col suo balzo ha raggiunto il quieto fido"<br>
//ricordiamoci che JS converte automaticamente le stringhe<br>
var posiz = stringa.indexOf("v"); //contiene il valore 6)<br>
var posiz2 = stringa.indexOf("k"); // restituisce -1</code><br>
Il metodo lastIndexOf( ) funziona analogamente ad indexOf( ) ma inizia la ricerca dalla
fine della stringa e non dall'inizio<br><br>
<b>replace( )</b><br>
Il metodo replace( ) restituisce la stringa iniziale sostituendo a tutte le occorrenze della stringa
indicata come primo parametro quella fornita come secondo. Ad esempio:<br>
<code>var s = "L'utente Pinco ha modificato questa pagina"<br>
var s2 = s.replace("Pinco", "Pallino");<br>
//s2 ora contiene "L'utente Pallino ha modificato questa pagina"<br>
//s1 contiene ancora "L'utente Pinco ha modificato questa pagina"</code><br>
Con questo metodo è possibile contare il numero di occorrenze di una sottostringa in una stringa.<br>
Ecco una funzione:<br>
<code>function substrCount (string, subString) {<br>
return (string.length - (string.replace(subString, "")).length) /<br>
subString.length<br>
}</code><br>
La funzione elimina tutte le occorrenze della sottostringa nella stringa tramite il metodo
replace( ); poi sottrae la lunghezza della stringa principale a quella della stringa appena
ottenuta; in questo modo si ottiene il numero di caratteri occupati dalla sottostringa che, divisi per la
sua lunghezza, ne danno il numero di occorrenze.<br><br>
<b>split( )</b><br>
Il metodo split( ) viene presentato ora in quanto fa parte della classe String, ma il suo uso
richiede la conoscenza degli array, che verranno esaminati più avanti.
La sintassi è:<br>
<code>stringa.split(separatore);</code><br>
Il metodo restituisce un array contenente le diverse sottostringhe in cui la stringa è divisa dal
separatore. Ad esempio:<br>
<code>"a,e,i,o,u".split(","); //restituisce "a", "e", "i", "o", "u"<br>
"a,e,i,o,u,".split(","); //attenzione: restituisce "a", "e", "i", "o", "u", ""</code><br>|






titolo£[Javascript]-Oggetto Array(Funzionamento e Proprietà)|
linguaggio£Javascript|
lezione£ Esaminiamo gli array, una funzionalità presente nella maggior parte dei
linguaggi di alto livello, che in JavaScript è disponibile tramite l'uso della classe Array.<br><br>
<b>Cos'è un array</b><br>
In informatica, un array (o vettore) è un tipo di dato strutturato (non semplice, che dispone quindi di
altri parametri) che permette di organizzare i dati secondo un indice; in pratica, lo stesso oggetto
contiene a sua volta numerosi valori, ciascuno dei quali contrassegnato da una chiave numerica.<br><br>
<b>Gli array in JavaScript</b><br>
Come è stato già detto, per creare un vettore in JavaScript facciamo riferimento alla classe Array:<br>
<code>var vettore = new Array ( ); //crea un array vuoto</code><br>
Il costruttore della classe può essere tuttavia usato in maniere differenti:<br>
</code>var vettore = new Array ( 5 ); //crea un array contenente 5 elementi<br>
var vocali = new Array ("A", "E", "I", "O", "U"); //crea un array contente le
vocali<br>
var lettere_straniere = ["J", "K", "W", "X", "Y"]; //metodo breve</code><br>
Per accedere ad un elemento dell'array, per leggerlo o modificarlo, usiamo la notazione:<br>
<code>vettore[indice]</code><br>
e potremo lavorare in questo modo:<br>
<code>alert(vocali[0]); //mostra "A"<br>
vocali[1] = "ciao"<br>
alert(vocali[1]); //mostra "ciao"</code><br>
Da notare che la chiave dell'array è numerica e parte da 0 e che il valore di ciascun elemento può
essere di qualsiasi tipo di dato, ciascuno diverso dall'altro.<br>
Ad esempio, potremmo stabilire un metodo per memorizzare le informazioni su dei prodotti
decidendo che all'elemento 0 corrisponde il nome, all'elemento 1 il modello, ecc... creando diversi
array:<br>
<code>var descCampi = new Array ( "ID", "Modello", "Prezzo" )<br>
var prod1 = new Array (1, "3000 plus", 35);<br>
var prod2 = new Array (5, "4000 minus, 12);</code><br><br>
<b>Proprietà</b><br>
L'oggetto Array dispone di una sola proprietà interessante, length, che restituisce il numero di
elementi in esso contenuti (contando anche quelli vuoti); da notare che, poiché gli indici partono da
0, un array di 5 elementi avrà gli elementi con le chiavi 0, 1, 2, 3 e 4.<br>|


titolo£[Javascript]-Oggetto Array (Metodi)|
linguaggio£Javascript|
lezione£ L'uso dell'oggetto Array diventa utile in relazione all'uso dei metodi.<br><br>
<b>concat( )</b><br>
Il metodo concat( ) restituisce un altro array contente tutti gli elementi dell'array a cui è applicato
seguiti da tutti gli elementi dell'array passato come parametro. Ad esempio:<br>
<code>var a = new Array (1, 2, 3);<br>
var b = new Array (4, 5, 6);<br>
var c = a.concat(b); //1, 2, 3, 4, 5, 6</code><br>
Da notare che a contiene ancora solo gli elementi 1, 2 e 3.<br><br>
<b>sort( )</b><br>
Il metodo sort( ) ordina l'array secondo l'ordine alfabetico:<br>
<code>var a = new Array ("e", "a", "u", "i", "o");<br>
a.sort() /ora le vocali sono ordinate nell'array a<br>
//attenzione: lavora direttamente sull'array!</code><br>
Attenzione: in JavaScript le minuscole seguono alle maiuscole, quindi ad esempio<br>
<code>var a = new Array ("E", "a", "U", "i", "o");<br>
a.sort() /ora le vocali sono ordinate in questo modo:<br>
//E U a i o!</code><br>
Per ovviare a questo problema possiamo lavorare su stringhe solo minuscole, usando il metodo
toLowerCase in questo modo:<br>
<code>var a = new Array ("E", "a", "U", "i", "o"); //il nostro array<br>
for (var i = 0; i < a.length, i++) { //itera sui singoli elementi<br>
a[i] = a[i].toLowerCase(); //si rende minuscoli<br>
}</code><br><br>
<b>reverse( )</b><br>
Questo metodo agisce sull'array invertendo l'ordine degli elementi in esso contenuti. Ad esempio:<br>
<code>var vettore = new Array (5); //crea un array contenente 5 elementi<br>
var vocali = new Array ("A", "E", "I", "O", "U");<br>
vocali.reverse(); //ora contiene U O I E A</code><br><br>
<b>slice( )</b><br>
Il metodo slice( ), infine, serve per copiare porzioni di array. La sua sintassi è:<br>
<code>arr.slice(a, b)</code><br>
Il metodo restituisce un array contente gli elementi di arr compresi tra a (incluso) e b (escluso).<br>
Se b non è indicato, vengono copiati tutti gli elementi a partire da a fino alla fine. Ad esempio:<br>
<code>var vettore = new Array (5); //crea un array contenente 5 elementi<br>
var a = new Array ("A", "E", "I", "O", "U");<br>
var b = a.slice(1,4); //b contiene gli elementi E I O</code><br>|


titolo£[Javascript]- Gli Eventi|
linguaggio£Javascript|
lezione£ Per completare la descrizione degli oggetti, ci occuperemo finalmente di un modo
per rendere la nostra pagina HTML veramente dinamica: l'utilizzo degli eventi.<br>
Un evento in JavaScript permette di eseguire determinate porzioni di codice a seconda delle azioni
dell'utente o a stati della pagina: è possibile ad esempio collegare del codice al click di un oggetto
oppure al ridimensionamento della pagina.<br><br>
<b>Gli eventi in JavaScript</b><br>
Di seguito è elencata una lista dei possibili eventi verificabili in JavaScript; da notare che gli eventi
si riferiscono sempre ad un oggetto specifico.<br><br>
<b>Eventi del mouse</b><br>
• <b>onclick</b> e <b>ondblclick</b> si verificano quando l'utente fa click o doppio click sull'elemento in
questione<br>
• <b>onmousdown</b> e <b>onmouseup</b> si verificano quando l'utente schiaccia il pulsante del mouse e
quando lo rilascia<br>
• <b>onmouseover</b> e <b>onmouseout</b> si verificano quando l'utente sposta il mouse dentro l'oggetto
in questione e quando lo sposta fuori<br>
• <b>onmousemove</b> si verifica quando l'utente muove il cursore dentro l'oggetto<br><br>
<b>Eventi della tastiera</b><br>
• <b>onkeypress</b> si verifica quando l'utente preme un tasto sulla tastiera quando il focus è
sull'oggetto specificato<br>
• <b>onkeydown</b> e <b>onkeyup</b> si verificano quando l'utente schiaccia un tasto e lo rilascia<br><br>
<b>Eventi degli elementi HTML</b><br>
• <b>onfocus</b> e <b>onblur </b>si verificano quando l'utente sposta il focus sull'oggetto in questione e
quando toglie il focus dall'oggetto<br>
• <b>onchange</b> si verifica quando l'utente modifica il contenuto dell'oggetto (è applicabile solo ai
campi di modulo)<br>
• <b>onsubmit</b> e <b>onreset</b> si possono applicare solo a moduli HTML e si verificano quando
l'utente invia il form (pulsante di submit) o quando lo resetta (pulsante reset)<br>
• <b>onselect</b> si verifica quando l'utente seleziona del testo<br><br>
<b>Eventi della finestra</b><br>
• <b>onload</b> e <b>onunload</b> si verificano quando la pagina viene caricata o quando viene chiusa<br>
• <b>onresize</b> si verifica quando l'utente ridimensiona la finestra del browser<br>
• alcuni browser supportano anche l'evento <b>onscroll</b> che si verifica allo scrolling della pagina<br><br>
<b>Eventi come attributi HTML</b><br>
Il modo più semplice di definire un evento è quello di inserirlo come attributo agli elementi
HTML della pagina stessa. Ad esempio:<br>
<code>< ..img src="logo.png" width="100px" onclick="alert('hai fatto click
sull\'immagine!')" alt="Clicca per saluti" /></code><br>
